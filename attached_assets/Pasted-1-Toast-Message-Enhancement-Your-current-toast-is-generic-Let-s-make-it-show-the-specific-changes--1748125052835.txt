1. Toast Message Enhancement
Your current toast is generic. Let's make it show the specific changes:
typescript// In moveReservationMutation onSuccess, replace this:
toast({
  title: "Reservation moved successfully",
  description: `${draggedReservation?.guestName} has been moved to the new time slot`,
});

// With this enhanced version:
toast({
  title: "Reservation Updated",
  description: `${draggedReservation?.guestName}'s reservation changed from ${draggedReservation?.currentTime} (Table ${draggedReservation?.currentTableId}) to ${newTime} (Table ${newTableId})`,
});
2. Instant Updates Without Server Overload
Problem: 30-second refresh conflicts with drag & drop instant feedback.
Solution: Optimistic updates + Smart invalidation:
typescript// Replace the current mutation with this approach:
const moveReservationMutation = useMutation({
  mutationFn: async ({ reservationId, newTableId, newTime }: {
    reservationId: number;
    newTableId: number;
    newTime: string;
  }) => {
    // Your existing API call
    const response = await fetch(`/api/reservations/${reservationId}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        tableId: newTableId,
        time: newTime,
        date: selectedDate
      })
    });
    
    if (!response.ok) throw new Error('Failed to move reservation');
    return response.json();
  },
  
  // INSTANT UPDATE - Optimistic UI
  onMutate: async ({ reservationId, newTableId, newTime }) => {
    // Cancel any outgoing refetches
    await queryClient.cancelQueries({ 
      queryKey: ["/api/tables/availability/schedule", selectedDate] 
    });

    // Snapshot the previous value
    const previousData = queryClient.getQueryData(["/api/tables/availability/schedule", selectedDate]);

    // Optimistically update the UI instantly
    queryClient.setQueryData(["/api/tables/availability/schedule", selectedDate], (old: any) => {
      if (!old) return old;
      
      return old.map((slot: any) => ({
        ...slot,
        tables: slot.tables.map((table: any) => {
          // Remove reservation from old location
          if (table.reservation?.id === reservationId) {
            return { ...table, reservation: null, status: 'available' };
          }
          // Add reservation to new location
          if (table.id === newTableId && slot.time === newTime) {
            return { 
              ...table, 
              reservation: draggedReservation ? {
                id: reservationId,
                guestName: draggedReservation.guestName,
                guestCount: draggedReservation.guestCount,
                timeSlot: newTime,
                phone: '', // You might need to track this
                status: 'confirmed'
              } : null
            };
          }
          return table;
        })
      }));
    });

    return { previousData };
  },

  onSuccess: (data, { newTableId, newTime }) => {
    // Find table names for better messaging
    const oldTableName = scheduleData?.find(slot => slot.time === draggedReservation?.currentTime)
      ?.tables?.find(t => t.id === draggedReservation?.currentTableId)?.name || draggedReservation?.currentTableId;
    
    const newTableName = scheduleData?.find(slot => slot.time === newTime)
      ?.tables?.find(t => t.id === newTableId)?.name || newTableId;

    toast({
      title: "Reservation Updated",
      description: `${draggedReservation?.guestName}'s reservation moved from ${draggedReservation?.currentTime} (${oldTableName}) to ${newTime} (${newTableName})`,
    });
    
    // Clean up drag state
    setDraggedReservation(null);
    setDragOverSlot(null);
    
    // Optional: Refresh data after successful move (but UI already updated)
    setTimeout(() => {
      queryClient.invalidateQueries({ 
        queryKey: ["/api/tables/availability/schedule", selectedDate] 
      });
    }, 1000); // Refresh after 1 second to sync with server
  },

  onError: (error: any, variables, context) => {
    // Revert optimistic update on error
    if (context?.previousData) {
      queryClient.setQueryData(
        ["/api/tables/availability/schedule", selectedDate], 
        context.previousData
      );
    }

    toast({
      title: "Failed to move reservation",
      description: error.message || "Please try again",
      variant: "destructive",
    });
    
    setDraggedReservation(null);
    setDragOverSlot(null);
  }
});
3. Reduce Refresh Rate Safely
typescript// Change the refetchInterval from 30 seconds to 2-3 minutes for background sync:
const { data: scheduleData, isLoading } = useQuery({
  queryKey: ["/api/tables/availability/schedule", selectedDate],
  queryFn: async () => {
    // Your existing query function
  },
  enabled: !!restaurant && timeSlots.length > 0,
  refetchInterval: 180000, // 3 minutes instead of 30 seconds
  refetchOnWindowFocus: true, // Refresh when user comes back to tab
  refetchOnMount: true, // Always fresh data on component mount
});
4. Enhanced Drag State Tracking
Add table names to your draggedReservation state:
typescriptconst [draggedReservation, setDraggedReservation] = useState<{
  reservationId: number;
  guestName: string;
  guestCount: number;
  currentTableId: number;
  currentTableName: string; // ADD THIS
  currentTime: string;
} | null>(null);

// Update handleDragStart:
const handleDragStart = (
  e: React.DragEvent,
  reservation: { id: number; guestName: string; guestCount: number; },
  table: TableData, // Pass full table object instead of just ID
  time: string
) => {
  setDraggedReservation({
    reservationId: reservation.id,
    guestName: reservation.guestName,
    guestCount: reservation.guestCount,
    currentTableId: table.id,
    currentTableName: table.name, // CAPTURE TABLE NAME
    currentTime: time
  });
  
  e.dataTransfer.effectAllowed = 'move';
};