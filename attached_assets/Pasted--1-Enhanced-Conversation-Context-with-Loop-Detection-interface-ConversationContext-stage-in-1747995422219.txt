// 1. Enhanced Conversation Context with Loop Detection
interface ConversationContext {
  stage: 'initial' | 'collecting_info' | 'confirming_reservation' | 'suggesting_alternatives';
  partialIntent?: {
    date?: string;
    time?: string;
    guests?: number;
    name?: string;
    phone?: string;
    special_requests?: string;
  };
  lastMessageTimestamp: number;
  restaurantId: number;
  suggestedSlots?: any[];
  lastRequestedGuests?: number;
  
  // NEW: Add these for better conversation management
  messageHistory: string[]; // Track recent messages
  repetitionCount: number; // Count how many times we asked for same info
  lastAskedFor: string | null; // What we last asked for
  userFrustrationLevel: number; // 0-5 scale
  conversationId: string; // Unique conversation identifier
}

// 2. Improved OpenAI Service with Better Prompting
export async function detectReservationIntent(
  message: string, 
  context: ConversationContext
): Promise<any> {
  
  // Enhanced system prompt with conversation awareness
  const systemPrompt = `You are an intelligent restaurant assistant. Your job is to extract booking information while being conversational and context-aware.

CONVERSATION CONTEXT:
- Previous messages: ${JSON.stringify(context.messageHistory.slice(-3))}
- Current info collected: ${JSON.stringify(context.partialIntent || {})}
- Last asked for: ${context.lastAskedFor}
- User seems frustrated: ${context.userFrustrationLevel > 2}

RULES:
1. If user already provided information, DON'T ask for it again
2. If user seems frustrated (repeated questions), acknowledge and offer help
3. Look for implicit confirmations (e.g., "just told you" means they provided info before)
4. Extract ANY information available, even if incomplete
5. Detect if user is asking for alternatives or availability

Current message: "${message}"

Respond with JSON containing:
- extracted_info: {date, time, guests, name, phone, special_requests}
- conversation_action: "collect_more" | "confirm_booking" | "show_alternatives" | "acknowledge_frustration" | "general_inquiry"
- missing_required: array of still-needed fields
- user_sentiment: "positive" | "neutral" | "frustrated" | "confused"
- response_tone: "friendly" | "apologetic" | "helpful" | "reassuring"`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: message }
      ],
      temperature: 0.2, // Slightly higher for more natural responses
      max_tokens: 300,
      response_format: { type: "json_object" }
    });

    return JSON.parse(response.choices[0].message.content || '{}');
  } catch (error) {
    console.error('AI Error:', error);
    return {
      extracted_info: {},
      conversation_action: "general_inquiry",
      missing_required: ["date", "time", "guests", "name", "phone"],
      user_sentiment: "neutral",
      response_tone: "friendly"
    };
  }
}

// 3. Smart Response Generation
export async function generateSmartResponse(
  analysisResult: any,
  context: ConversationContext,
  restaurantInfo: any
): Promise<string> {
  
  const { conversation_action, user_sentiment, response_tone, missing_required } = analysisResult;
  
  // Handle different conversation scenarios
  switch (conversation_action) {
    case "acknowledge_frustration":
      return generateApologyResponse(context, missing_required);
      
    case "show_alternatives":
      return generateAlternativesResponse(context);
      
    case "confirm_booking":
      return generateConfirmationResponse(context.partialIntent);
      
    case "collect_more":
      return generateCollectionResponse(missing_required, response_tone, context);
      
    default:
      return generateGeneralResponse(analysisResult.message || "How can I help you today?");
  }
}

function generateApologyResponse(context: ConversationContext, missing: string[]): string {
  const responses = [
    "I apologize for the confusion! Let me help you more efficiently.",
    "Sorry about that - let me make this easier for you.",
    "I understand this is frustrating. Let me simplify this process."
  ];
  
  const apology = responses[Math.floor(Math.random() * responses.length)];
  
  if (missing.length === 0) {
    return `${apology} I believe I have all your information. Let me confirm your reservation now! ðŸŽ‰`;
  }
  
  const missingText = missing.length === 1 
    ? `I just need your ${missing[0]}` 
    : `I just need: ${missing.join(', ')}`;
    
  return `${apology} ${missingText} and then I can complete your reservation.`;
}

function generateCollectionResponse(missing: string[], tone: string, context: ConversationContext): string {
  // Avoid repetitive asks by varying the approach
  if (context.repetitionCount > 2) {
    return generateApologyResponse(context, missing);
  }
  
  const friendly = [
    "Perfect! I just need a few more details to complete your reservation.",
    "Great! To finish your booking, could I get",
    "Almost there! I just need"
  ];
  
  const helpful = [
    "To secure your table, I'll need",
    "Let me get the remaining details:",
    "I can complete your reservation once I have"
  ];
  
  const phrases = tone === "friendly" ? friendly : helpful;
  const intro = phrases[Math.floor(Math.random() * phrases.length)];
  
  if (missing.length === 1) {
    const field = missing[0];
    const specific = {
      name: "your name",
      phone: "your phone number", 
      date: "which date you'd prefer",
      time: "what time works best",
      guests: "how many people will be dining"
    };
    
    return `${intro} ${specific[field] || field}? ðŸ˜Š`;
  }
  
  return `${intro} ${missing.join(', ')}. What can you share with me?`;
}

// 4. Enhanced Message Handler with Loop Detection
export async function handleTelegramMessage(
  msg: any, 
  restaurantId: number, 
  bot: TelegramBot
) {
  const chatId = msg.chat.id;
  const text = msg.text;
  
  // Get or create conversation context
  let context = getConversationContext(chatId, restaurantId);
  
  // Update message history and detect loops
  context.messageHistory.push(text);
  if (context.messageHistory.length > 10) {
    context.messageHistory = context.messageHistory.slice(-10);
  }
  
  // Detect repetitive patterns
  const recentMessages = context.messageHistory.slice(-3);
  const hasRepetition = recentMessages.filter(m => m.toLowerCase().includes(text.toLowerCase())).length > 1;
  
  if (hasRepetition) {
    context.repetitionCount++;
    context.userFrustrationLevel = Math.min(5, context.userFrustrationLevel + 1);
  }
  
  try {
    // Enhanced AI analysis
    const analysisResult = await detectReservationIntent(text, context);
    
    // Update context with new information
    const newInfo = analysisResult.extracted_info || {};
    if (!context.partialIntent) context.partialIntent = {};
    
    // Merge new information, preserving existing data
    Object.keys(newInfo).forEach(key => {
      if (newInfo[key] && newInfo[key] !== 'NOT_SPECIFIED') {
        context.partialIntent[key] = newInfo[key];
      }
    });
    
    // Generate smart response
    const response = await generateSmartResponse(analysisResult, context, {});
    
    // Update context state
    context.lastMessageTimestamp = Date.now();
    if (analysisResult.missing_required?.length > 0) {
      context.lastAskedFor = analysisResult.missing_required[0];
    }
    
    // Save context
    saveConversationContext(chatId, context);
    
    // Send response
    await bot.sendMessage(chatId, response);
    
    // Try to complete booking if we have everything
    if (analysisResult.conversation_action === "confirm_booking") {
      await attemptBookingCreation(context, bot, chatId);
    }
    
  } catch (error) {
    console.error('Message handling error:', error);
    await bot.sendMessage(chatId, 
      "I apologize, but I'm having trouble processing that. Could you please try rephrasing your request? ðŸ¤”"
    );
  }
}

// 5. Context Management Functions
const conversationContexts = new Map<string, ConversationContext>();

function getConversationContext(chatId: number, restaurantId: number): ConversationContext {
  const key = `${chatId}-${restaurantId}`;
  
  if (!conversationContexts.has(key)) {
    conversationContexts.set(key, {
      stage: 'initial',
      partialIntent: {},
      lastMessageTimestamp: Date.now(),
      restaurantId,
      messageHistory: [],
      repetitionCount: 0,
      lastAskedFor: null,
      userFrustrationLevel: 0,
      conversationId: `conv_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    });
  }
  
  return conversationContexts.get(key)!;
}

function saveConversationContext(chatId: number, context: ConversationContext) {
  const key = `${chatId}-${context.restaurantId}`;
  conversationContexts.set(key, context);
}

// 6. Booking Completion Logic
async function attemptBookingCreation(
  context: ConversationContext, 
  bot: TelegramBot, 
  chatId: number
) {
  const intent = context.partialIntent;
  
  if (!intent || !intent.date || !intent.time || !intent.guests || !intent.name || !intent.phone) {
    return; // Not ready yet
  }
  
  try {
    const result = await createTelegramReservation(
      context.restaurantId,
      intent.date,
      intent.time,
      intent.guests,
      intent.name,
      intent.phone,
      intent.special_requests
    );
    
    if (result.success) {
      const confirmationMessage = `ðŸŽ‰ Excellent! Your reservation is confirmed!

ðŸ“… **${intent.date}** at **${intent.time}**
ðŸ‘¥ **${intent.guests} guests**
ðŸ‘¤ **${intent.name}**
ðŸ“ž **${intent.phone}**
ðŸª‘ **${result.tableAssigned}**

We look forward to seeing you! If you need to make any changes, just let me know. ðŸ˜Š`;

      await bot.sendMessage(chatId, confirmationMessage);
      
      // Reset context for new conversation
      context.stage = 'initial';
      context.partialIntent = {};
      context.repetitionCount = 0;
      context.userFrustrationLevel = 0;
      
    } else {
      await bot.sendMessage(chatId, 
        `I'm sorry, but ${result.message || 'we cannot accommodate that request at this time.'}

Would you like me to suggest some alternative times? ðŸ¤”`
      );
    }
    
  } catch (error) {
    console.error('Booking creation error:', error);
    await bot.sendMessage(chatId, 
      "I apologize, but there was an issue creating your reservation. Let me try again or suggest alternatives."
    );
  }
}

// 7. Additional Utility Functions
export function detectUserIntent(message: string): {
  isAvailabilityCheck: boolean;
  isModification: boolean;
  isCancellation: boolean;
  isGeneralInquiry: boolean;
} {
  const lower = message.toLowerCase();
  
  return {
    isAvailabilityCheck: /\b(available|availability|free|open|check|when|time|tomorrow|today)\b/.test(lower),
    isModification: /\b(change|modify|update|different|move)\b/.test(lower),
    isCancellation: /\b(cancel|remove|delete)\b/.test(lower),
    isGeneralInquiry: /\b(hours|menu|location|address|phone|info|about)\b/.test(lower)
  };
}