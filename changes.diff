diff --git a/changes.diff b/changes.diff
index 53d3576..e69de29 100644
--- a/changes.diff
+++ b/changes.diff
@@ -1,2218 +0,0 @@
-diff --git a/client/src/App.tsx b/client/src/App.tsx
-index b21b056..b794be8 100644
---- a/client/src/App.tsx
-+++ b/client/src/App.tsx
-@@ -3,6 +3,10 @@ import { queryClient } from "./lib/queryClient";
- import { QueryClientProvider } from "@tanstack/react-query";
- import { Toaster } from "@/components/ui/toaster";
- import { TooltipProvider } from "@/components/ui/tooltip";
-+
-+// 🔌 WEBSOCKET INTEGRATION: Import WebSocket provider
-+import { WebSocketProvider } from "@/components/websocket/WebSocketContext";
-+
- import NotFound from "@/pages/not-found";
- import Dashboard from "@/pages/dashboard";
- import Reservations from "@/pages/reservations";
-@@ -436,14 +440,17 @@ function App() {
-         <ErrorBoundary>
-             <QueryClientProvider client={queryClient}>
-                 <AuthProvider>
--                    <TooltipProvider>
--                        <Toaster />
--                        <Router />
--                    </TooltipProvider>
-+                    {/* 🔌 WEBSOCKET INTEGRATION: Add WebSocket provider after AuthProvider */}
-+                    <WebSocketProvider>
-+                        <TooltipProvider>
-+                            <Toaster />
-+                            <Router />
-+                        </TooltipProvider>
-+                    </WebSocketProvider>
-                 </AuthProvider>
-             </QueryClientProvider>
-         </ErrorBoundary>
-     );
- }
- 
--export default App;
-+export default App;
-\ No newline at end of file
-diff --git a/client/src/components/layout/DashboardLayout.tsx b/client/src/components/layout/DashboardLayout.tsx
-index 5f60ca9..a476b2a 100644
---- a/client/src/components/layout/DashboardLayout.tsx
-+++ b/client/src/components/layout/DashboardLayout.tsx
-@@ -115,9 +115,9 @@ export function DashboardLayout({ children }: DashboardLayoutProps) {
-       }
-       
-       return data;
--    },
--    // ✅ CRITICAL: Remove stale time to ensure fresh data
--    staleTime: 0,
-+      },
-+
-+    staleTime: 1000 * 60 * 5,
-     gcTime: 1000 * 30, // Keep for 30 seconds only
-     refetchOnMount: true,
-     refetchOnWindowFocus: true,
-diff --git a/client/src/components/layout/Sidebar.tsx b/client/src/components/layout/Sidebar.tsx
-index ed49e19..bcd30e3 100644
---- a/client/src/components/layout/Sidebar.tsx
-+++ b/client/src/components/layout/Sidebar.tsx
-@@ -15,6 +15,9 @@ import {
- import { Button } from "@/components/ui/button";
- import { cn } from "@/lib/utils";
- 
-+// 🔌 WEBSOCKET INTEGRATION: Import compact WebSocket status component
-+import { WebSocketStatusCompact } from '@/components/websocket/WebSocketStatus';
-+
- interface NavItemProps {
-   href: string;
-   icon: React.ReactNode;
-@@ -47,8 +50,14 @@ export function Sidebar() {
-       {/* Desktop Sidebar */}
-       <aside className="hidden lg:flex flex-col w-64 bg-white border-r border-gray-200">
-         <div className="px-6 py-4 border-b border-gray-200">
--          <h1 className="text-2xl font-semibold text-gray-800">ToBeOut</h1>
--          <p className="text-sm text-gray-500">Restaurant Management</p>
-+          <div className="flex items-center justify-between">
-+            <div>
-+              <h1 className="text-2xl font-semibold text-gray-800">ToBeOut</h1>
-+              <p className="text-sm text-gray-500">Restaurant Management</p>
-+            </div>
-+            {/* 🔌 WEBSOCKET INTEGRATION: Add compact status indicator */}
-+            <WebSocketStatusCompact />
-+          </div>
-         </div>
- 
-         <nav className="flex-1 pt-4 pb-4 overflow-y-auto">
-@@ -105,7 +114,11 @@ export function Sidebar() {
-       {/* Mobile Header */}
-       <div className="lg:hidden fixed top-0 left-0 right-0 z-20 bg-white border-b border-gray-200">
-         <div className="flex items-center justify-between p-4">
--          <h1 className="text-xl font-semibold text-gray-800">ToBeOut</h1>
-+          <div className="flex items-center gap-3">
-+            <h1 className="text-xl font-semibold text-gray-800">ToBeOut</h1>
-+            {/* 🔌 WEBSOCKET INTEGRATION: Add compact status for mobile header */}
-+            <WebSocketStatusCompact />
-+          </div>
-           <Button 
-             variant="ghost" 
-             size="icon" 
-@@ -122,7 +135,11 @@ export function Sidebar() {
-         <div className="lg:hidden fixed inset-0 z-30 bg-black bg-opacity-50">
-           <div className="absolute right-0 top-0 bottom-0 w-64 bg-white">
-             <div className="p-4 border-b border-gray-200 flex justify-between items-center">
--              <h2 className="text-lg font-semibold">Menu</h2>
-+              <div className="flex items-center gap-2">
-+                <h2 className="text-lg font-semibold">Menu</h2>
-+                {/* 🔌 WEBSOCKET INTEGRATION: Add status to mobile menu header */}
-+                <WebSocketStatusCompact />
-+              </div>
-               <Button 
-                 variant="ghost" 
-                 size="icon" 
-@@ -244,4 +261,4 @@ export function Sidebar() {
-       )}
-     </>
-   );
--}
-+}
-\ No newline at end of file
-diff --git a/client/src/pages/dashboard.tsx b/client/src/pages/dashboard.tsx
-index b7cb0f4..b051fb5 100644
---- a/client/src/pages/dashboard.tsx
-+++ b/client/src/pages/dashboard.tsx
-@@ -16,6 +16,9 @@ import { useMutation, useQueryClient } from "@tanstack/react-query";
- import { useToast } from "@/hooks/use-toast";
- import { EnhancedAIAssistant } from '@/components/dashboard/EnhancedAIAssistant';
- 
-+// 🔌 WEBSOCKET INTEGRATION: Import WebSocket status component
-+import { WebSocketStatus } from '@/components/websocket/WebSocketStatus';
-+
- export default function Dashboard() {
-     const [isReservationModalOpen, setIsReservationModalOpen] = useState(false);
-     const [selectedReservationId, setSelectedReservationId] = useState<number | undefined>(undefined);
-@@ -144,7 +147,10 @@ export default function Dashboard() {
-                             )}
-                         </p>
-                     </div>
--                    <div className="mt-4 md:mt-0 flex flex-wrap gap-2">
-+                    <div className="mt-4 md:mt-0 flex flex-wrap gap-2 items-center">
-+                        {/* 🔌 WEBSOCKET INTEGRATION: Add WebSocket status badge */}
-+                        <WebSocketStatus />
-+                        
-                         <Button
-                             className="inline-flex items-center"
-                             onClick={handleCreateReservation}
-@@ -152,6 +158,7 @@ export default function Dashboard() {
-                             <PlusCircle className="mr-2 h-4 w-4" />
-                             New Reservation
-                         </Button>
-+                        
-                         <DropdownMenu>
-                             <DropdownMenuTrigger asChild>
-                                 <Button variant="outline" className="inline-flex items-center">
-@@ -252,4 +259,4 @@ export default function Dashboard() {
-             </AlertDialog>
-         </DashboardLayout>
-     );
--}
-+}
-\ No newline at end of file
-diff --git a/client/src/pages/modern-tables.tsx b/client/src/pages/modern-tables.tsx
-index 66b6781..72cfc44 100644
---- a/client/src/pages/modern-tables.tsx
-+++ b/client/src/pages/modern-tables.tsx
-@@ -15,9 +15,14 @@ import { useToast } from "@/hooks/use-toast";
- import { cn } from "@/lib/utils";
- import { apiRequest } from "@/lib/queryClient";
- import { DashboardLayout } from "@/components/layout/DashboardLayout";
--// ✅ CRITICAL FIX: Import timezone utilities from the correct path
- import { getRestaurantDateTime, getRestaurantDateString, getTomorrowDateString } from "@/lib/utils";
- 
-+// ✅ NEW: Import WebSocket context and dnd-kit
-+import { useWebSocketContext } from "@/components/websocket/WebSocketContext";
-+import { DndContext, DragEndEvent } from '@dnd-kit/core';
-+import { DraggableReservation } from '@/components/reservations/DraggableReservation';
-+import { DroppableSlot } from '@/components/reservations/DroppableSlot';
-+
- interface TableData {
-   id: number;
-   name: string;
-@@ -56,13 +61,12 @@ interface Restaurant {
-   [key: string]: any;
- }
- 
--// ✅ TYPE SAFETY FIX: Define mutation context type
- interface MutationContext {
-   previousData?: any;
- }
- 
- export default function ModernTables() {
--  const [selectedDate, setSelectedDate] = useState(''); // ✅ FIXED: Initialize empty, set after restaurant loads
-+  const [selectedDate, setSelectedDate] = useState('');
-   const [selectedTime, setSelectedTime] = useState("19:00");
-   const [activeView, setActiveView] = useState<"schedule" | "floorplan" | "grid" | "list">("schedule");
-   
-@@ -87,41 +91,35 @@ export default function ModernTables() {
-     guestName?: string;
-   } | null>(null);
- 
--  // Enhanced drag & drop state
--  const [draggedReservation, setDraggedReservation] = useState<{
--    reservationId: number;
--    guestName: string;
--    guestCount: number;
--    currentTableId: number;
--    currentTableName: string;
--    currentTime: string;
--    phone?: string;
--  } | null>(null);
--  const [dragPosition, setDragPosition] = useState({ x: 0, y: 0 });
--  const [dragOverSlot, setDragOverSlot] = useState<{tableId: number; time: string} | null>(null);
--  const [isValidDropZone, setIsValidDropZone] = useState(false);
-+  // ✅ REMOVED: All manual drag-and-drop state variables
-+  // - draggedReservation
-+  // - dragPosition
-+  // - dragOverSlot
-+  // - isValidDropZone
-   
-   const queryClient = useQueryClient();
-   const { toast } = useToast();
- 
--  // ✅ CRITICAL FIX: Get restaurant profile first without timezone in query key
-+  // ✅ NEW: WebSocket context for real-time updates
-+  const { isConnected } = useWebSocketContext();
-+
-+  // Get restaurant profile first
-   const { data: restaurant, isLoading: restaurantLoading, error: restaurantError } = useQuery<Restaurant>({
-     queryKey: ["/api/restaurants/profile"],
-     retry: 3,
-     staleTime: 30000,
-   });
- 
--  // ✅ CRITICAL FIX: Get actual restaurant timezone or fallback
-   const restaurantTimezone = restaurant?.timezone || 'Europe/Belgrade';
- 
--  // ✅ CRITICAL FIX: Set selectedDate after restaurant loads
-+  // Set selectedDate after restaurant loads
-   React.useEffect(() => {
-     if (restaurant && !selectedDate) {
-       setSelectedDate(getRestaurantDateString(restaurantTimezone));
-     }
-   }, [restaurant, restaurantTimezone, selectedDate]);
- 
--  // ✅ CRITICAL FIX: Enhanced overnight-aware time slot generation
-+  // Enhanced overnight-aware time slot generation
-   const timeSlots: string[] = React.useMemo(() => {
-     if (!restaurant?.openingTime || !restaurant?.closingTime) {
-       return [];
-@@ -135,21 +133,17 @@ export default function ModernTables() {
-       const openingMinutes = openHour * 60 + (openMin || 0);
-       const closingMinutes = closeHour * 60 + (closeMin || 0);
-       
--      // ✅ CRITICAL FIX: Detect overnight operation
-       const isOvernightOperation = closingMinutes < openingMinutes;
-       
-       if (isOvernightOperation) {
-         console.log(`[ModernTables] 🌙 Overnight operation detected: ${restaurant.openingTime}-${restaurant.closingTime}`);
-         
--        // ✅ Generate overnight time slots
--        // Part 1: From opening time until midnight (e.g., 22:00 → 24:00)
-         for (let minutes = openingMinutes; minutes < 24 * 60; minutes += 60) {
-           const hour = Math.floor(minutes / 60);
-           const minute = minutes % 60;
-           slots.push(`${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`);
-         }
-         
--        // Part 2: From midnight until closing time (e.g., 00:00 → 03:00)
-         for (let minutes = 0; minutes < closingMinutes; minutes += 60) {
-           const hour = Math.floor(minutes / 60);
-           const minute = minutes % 60;
-@@ -160,9 +154,8 @@ export default function ModernTables() {
-       } else {
-         console.log(`[ModernTables] 📅 Standard operation: ${restaurant.openingTime}-${restaurant.closingTime}`);
-         
--        // ✅ Standard operation: simple range
--        const avgDuration = restaurant.avgReservationDuration || 120; // minutes
--        const lastBookingTime = closingMinutes - avgDuration; // Don't allow bookings too close to closing
-+        const avgDuration = restaurant.avgReservationDuration || 120;
-+        const lastBookingTime = closingMinutes - avgDuration;
-         
-         for (let minutes = openingMinutes; minutes <= lastBookingTime; minutes += 60) {
-           const hour = Math.floor(minutes / 60);
-@@ -179,14 +172,14 @@ export default function ModernTables() {
-     return slots;
-   }, [restaurant]);
- 
--  // ✅ CRITICAL FIX: Get tables with proper timezone context
-+  // Get tables with proper timezone context
-   const { data: tables, isLoading: tablesLoading, error: tablesError } = useQuery({
-     queryKey: ["/api/tables", restaurantTimezone],
-     enabled: !!restaurant,
-     retry: 3,
-   });
- 
--  // ✅ CRITICAL FIX: Enhanced schedule data fetching with comprehensive overnight support
-+  // ✅ UPDATED: Removed refetchInterval for real-time WebSocket updates
-   const { data: scheduleData, isLoading, error: scheduleError } = useQuery({
-     queryKey: ["/api/tables/availability/schedule", selectedDate, restaurantTimezone],
-     queryFn: async () => {
-@@ -197,7 +190,6 @@ export default function ModernTables() {
-       console.log(`🔍 [ModernTables] Fetching schedule for ${selectedDate} with timezone ${restaurantTimezone}`);
-       console.log(`🔍 [ModernTables] Time slots to check: ${timeSlots.length} slots`);
- 
--      // ✅ ENHANCED: Check if this is an overnight operation
-       const isOvernight = restaurant?.openingTime && restaurant?.closingTime && 
-         (parseInt(restaurant.closingTime.split(':')[0]) < parseInt(restaurant.openingTime.split(':')[0]));
- 
-@@ -216,7 +208,6 @@ export default function ModernTables() {
-           if (!response.ok) {
-             console.error(`❌ Failed to fetch availability for ${time}:`, response.status, response.statusText);
-             
--            // ✅ ENHANCED: For overnight operations, provide more context in errors
-             if (isOvernight) {
-               console.error(`❌ [ModernTables] Overnight operation error at ${time} - this might be due to timezone handling`);
-             }
-@@ -227,7 +218,6 @@ export default function ModernTables() {
-           const data = await response.json();
-           const sortedTables = Array.isArray(data) ? data.sort((a: any, b: any) => a.id - b.id) : [];
-           
--          // ✅ ENHANCED: Better logging for overnight operations
-           if (isOvernight && (time === timeSlots[0] || time === timeSlots[Math.floor(timeSlots.length/2)] || time === timeSlots[timeSlots.length-1])) {
-             console.log(`✅ [ModernTables] 🌙 Overnight slot ${time}: ${sortedTables.length} tables`);
-           } else if (!isOvernight && sortedTables.length > 0) {
-@@ -239,19 +229,17 @@ export default function ModernTables() {
-         } catch (error) {
-           console.error(`❌ Error fetching ${time}:`, error);
-           
--          // ✅ ENHANCED: For overnight operations, provide empty data instead of failing completely
-           if (isOvernight) {
-             console.warn(`⚠️ [ModernTables] 🌙 Overnight slot ${time} failed, providing empty data`);
-             return { time, tables: [] };
-           }
-           
--          throw error; // Re-throw for standard operations
-+          throw error;
-         }
-       });
-       
-       const results = await Promise.allSettled(promises);
-       
--      // ✅ ENHANCED: Handle mixed success/failure results better for overnight operations
-       const successfulResults = results
-         .filter((result): result is PromiseFulfilledResult<any> => result.status === 'fulfilled')
-         .map(result => result.value);
-@@ -272,22 +260,59 @@ export default function ModernTables() {
-       return successfulResults;
-     },
-     enabled: !!restaurant && !!selectedDate && timeSlots.length > 0,
--    refetchInterval: 180000,
-+    // ✅ REMOVED: refetchInterval (now using WebSocket for real-time updates)
-     refetchOnWindowFocus: true,
-     refetchOnMount: true,
-     retry: (failureCount, error) => {
--      // ✅ ENHANCED: More lenient retry logic for overnight operations
-       const isOvernight = restaurant?.openingTime && restaurant?.closingTime && 
-         (parseInt(restaurant.closingTime.split(':')[0]) < parseInt(restaurant.openingTime.split(':')[0]));
-       
-       if (isOvernight) {
--        return failureCount < 1; // Only retry once for overnight operations
-+        return failureCount < 1;
-       }
--      return failureCount < 2; // Standard retry logic
-+      return failureCount < 2;
-     },
-   });
- 
--  // ✅ CRITICAL FIX: Enhanced table creation with timezone context
-+  // ✅ NEW: dnd-kit drag end handler (replaces all manual drag-and-drop handlers)
-+  const handleDragEnd = (event: DragEndEvent) => {
-+    const { active, over } = event;
-+
-+    // Exit if the item was dropped in a non-droppable area
-+    if (!over) {
-+      return;
-+    }
-+
-+    // Exit if the item was dropped back into its original spot
-+    if (active.id === over.id) {
-+      return;
-+    }
-+
-+    const reservationId = active.id as number;
-+    const { tableId: newTableId, time: newTime } = over.data.current as { tableId: number, time: string };
-+
-+    // Check for capacity constraints
-+    const draggedGuestCount = active.data.current?.guestCount;
-+    const targetTable = over.data.current?.table;
-+    
-+    if (draggedGuestCount && targetTable && (draggedGuestCount < targetTable.minGuests || draggedGuestCount > targetTable.maxGuests)) {
-+      toast({
-+        title: "Move Failed",
-+        description: `Table ${targetTable.name} cannot accommodate ${draggedGuestCount} guests.`,
-+        variant: "destructive",
-+      });
-+      return;
-+    }
-+    
-+    // Call the existing mutation to move the reservation
-+    moveReservationMutation.mutate({
-+      reservationId,
-+      newTableId,
-+      newTime,
-+    });
-+  };
-+
-+  // Enhanced table creation with timezone context
-   const addTableMutation = useMutation({
-     mutationFn: async (tableData: AddTableForm) => {
-       const payload = {
-@@ -297,7 +322,6 @@ export default function ModernTables() {
-         features: tableData.features ? tableData.features.split(',').map(f => f.trim()) : [],
-         comments: tableData.comments,
-         status: 'free',
--        // ✅ CRITICAL FIX: Include restaurant context
-         restaurantTimezone: restaurantTimezone
-       };
-       
-@@ -325,17 +349,14 @@ export default function ModernTables() {
-       
-       console.log(`✅ [ModernTables] Table created:`, newTable);
-       
--      // ✅ CRITICAL FIX: Comprehensive cache invalidation
-       queryClient.invalidateQueries({ queryKey: ["/api/tables"] });
-       queryClient.invalidateQueries({ queryKey: ["/api/tables/availability/schedule"] });
-       queryClient.invalidateQueries({ queryKey: ["/api/restaurants/profile"] });
-       
--      // Force refetch of schedule data
-       queryClient.refetchQueries({ 
-         queryKey: ["/api/tables/availability/schedule", selectedDate, restaurantTimezone] 
-       });
-       
--      // Reset form and close modal
-       setAddTableForm({
-         name: "",
-         minGuests: 1,
-@@ -355,7 +376,7 @@ export default function ModernTables() {
-     }
-   });
- 
--  // ✅ CRITICAL FIX: Enhanced table deletion with timezone context
-+  // Enhanced table deletion with timezone context
-   const deleteTableMutation = useMutation({
-     mutationFn: async (tableId: number) => {
-       console.log(`🗑️ [ModernTables] Deleting table ${tableId}`);
-@@ -380,11 +401,9 @@ export default function ModernTables() {
-       
-       console.log(`✅ [ModernTables] Table deleted successfully`);
-       
--      // ✅ CRITICAL FIX: Comprehensive cache invalidation
-       queryClient.invalidateQueries({ queryKey: ["/api/tables"] });
-       queryClient.invalidateQueries({ queryKey: ["/api/tables/availability/schedule"] });
-       
--      // Force refetch
-       queryClient.refetchQueries({ 
-         queryKey: ["/api/tables/availability/schedule", selectedDate, restaurantTimezone] 
-       });
-@@ -399,7 +418,7 @@ export default function ModernTables() {
-     }
-   });
- 
--  // ✅ TYPE SAFETY FIX: Enhanced reservation movement with proper mutation types
-+  // Enhanced reservation movement with proper mutation types
-   const moveReservationMutation = useMutation<any, Error, { 
-     reservationId: number; 
-     newTableId: number; 
-@@ -432,19 +451,39 @@ export default function ModernTables() {
-       });
- 
-       const previousData = queryClient.getQueryData(["/api/tables/availability/schedule", selectedDate, restaurantTimezone]);
--      const duration = 2;
-+      // Calculate duration in hour slots based on restaurant's average reservation duration
-+      const durationInSlots = Math.ceil((restaurant?.avgReservationDuration || 120) / 60);
- 
-       queryClient.setQueryData(["/api/tables/availability/schedule", selectedDate, restaurantTimezone], (old: any) => {
--        if (!old || !draggedReservation) return old;
-+        if (!old) return old;
-+        
-+        // Find the current reservation to move
-+        let currentReservation: any = null;
-+        let currentTableId: number = 0;
-+        let currentTime: string = '';
-+        
-+        // Find the reservation in the current data
-+        for (const slot of old) {
-+          for (const table of slot.tables) {
-+            if (table.reservation?.id === reservationId) {
-+              currentReservation = table.reservation;
-+              currentTableId = table.id;
-+              currentTime = slot.time;
-+              break;
-+            }
-+          }
-+          if (currentReservation) break;
-+        }
-         
--        const sourceHour = parseInt(draggedReservation.currentTime.split(':')[0]);
-+        if (!currentReservation) return old;
-+        
-+        const sourceHour = parseInt(currentTime.split(':')[0]);
-         const targetHour = parseInt(newTime.split(':')[0]);
-         
--        // ✅ TYPE SAFETY FIX: Proper array typing
-         const sourceSlots: string[] = [];
-         const targetSlots: string[] = [];
-         
--        for (let i = 0; i < duration; i++) {
-+        for (let i = 0; i < durationInSlots; i++) {
-           sourceSlots.push(`${(sourceHour + i).toString().padStart(2, '0')}:00`);
-           targetSlots.push(`${(targetHour + i).toString().padStart(2, '0')}:00`);
-         }
-@@ -452,7 +491,7 @@ export default function ModernTables() {
-         return old.map((slot: any) => ({
-           ...slot,
-           tables: slot.tables.map((table: any) => {
--            if (table.id === draggedReservation.currentTableId && 
-+            if (table.id === currentTableId && 
-                 sourceSlots.includes(slot.time) &&
-                 table.reservation?.id === reservationId) {
-               return { 
-@@ -467,12 +506,8 @@ export default function ModernTables() {
-                 ...table, 
-                 status: 'reserved',
-                 reservation: {
--                  id: reservationId,
--                  guestName: draggedReservation.guestName,
--                  guestCount: draggedReservation.guestCount,
--                  timeSlot: `${slot.time}-${targetSlots[targetSlots.length - 1]}`,
--                  phone: draggedReservation.phone || '',
--                  status: 'confirmed'
-+                  ...currentReservation,
-+                  timeSlot: `${slot.time}-${targetSlots[targetSlots.length - 1]}`
-                 }
-               };
-             }
-@@ -487,18 +522,16 @@ export default function ModernTables() {
- 
-     onSuccess: (data: any, variables) => {
-       const { newTableId, newTime } = variables;
--      const oldTableName = draggedReservation?.currentTableName || `Table ${draggedReservation?.currentTableId}`;
-+      
-+      // Find table names for the toast message
-       const newTableName = scheduleData?.find(slot => slot.time === newTime)
-         ?.tables?.find((t: any) => t.id === newTableId)?.name || `Table ${newTableId}`;
- 
-       toast({
-         title: "Reservation Updated",
--        description: `${draggedReservation?.guestName}'s reservation moved from ${draggedReservation?.currentTime} (${oldTableName}) to ${newTime} (${newTableName})`,
-+        description: `Reservation moved to ${newTime} (${newTableName})`,
-       });
-       
--      setDraggedReservation(null);
--      setDragOverSlot(null);
--      
-       queryClient.invalidateQueries({ 
-         queryKey: ["/api/reservations", restaurantTimezone] 
-       });
-@@ -517,13 +550,10 @@ export default function ModernTables() {
-         description: error.message || "Please try again",
-         variant: "destructive",
-       });
--      
--      setDraggedReservation(null);
--      setDragOverSlot(null);
-     }
-   });
- 
--  // ✅ TYPE SAFETY FIX: Enhanced reservation cancellation with proper typing
-+  // Enhanced reservation cancellation with proper typing
-   const cancelReservationMutation = useMutation<any, Error, number, MutationContext>({
-     mutationFn: async (reservationId: number) => {
-       const response = await fetch(`/api/reservations/${reservationId}`, {
-@@ -585,7 +615,7 @@ export default function ModernTables() {
-     },
-   });
- 
--  // ✅ TYPE SAFETY FIX: Enhanced quick move with proper typing
-+  // Enhanced quick move with proper typing
-   const quickMoveMutation = useMutation<any, Error, { reservationId: number; direction: 'up' | 'down' }, MutationContext>({
-     mutationFn: async ({ reservationId, direction }) => {
-       const currentSlot = scheduleData?.find(slot => 
-@@ -598,7 +628,6 @@ export default function ModernTables() {
-       const currentHour = parseInt(currentSlot.time.split(':')[0]);
-       const newHour = direction === 'up' ? currentHour - 1 : currentHour + 1;
-       
--      // ✅ ENHANCED: Handle overnight operation boundaries
-       const isOvernight = restaurant?.openingTime && restaurant?.closingTime && 
-         (parseInt(restaurant.closingTime.split(':')[0]) < parseInt(restaurant.openingTime.split(':')[0]));
-       
-@@ -606,7 +635,6 @@ export default function ModernTables() {
-         const openingHour = parseInt(restaurant.openingTime.split(':')[0]);
-         const closingHour = parseInt(restaurant.closingTime.split(':')[0]);
-         
--        // For overnight operations, check boundaries differently
-         if (direction === 'up' && newHour < 0) {
-           throw new Error('Cannot move before midnight');
-         }
-@@ -614,13 +642,11 @@ export default function ModernTables() {
-           throw new Error('Cannot move past 24:00');
-         }
-         
--        // Check if the new hour is within operating hours
-         const isValidHour = (newHour >= openingHour || newHour < closingHour);
-         if (!isValidHour) {
-           throw new Error(`Cannot move outside operating hours (${restaurant.openingTime} - ${restaurant.closingTime})`);
-         }
-       } else {
--        // Standard operation checks
-         const openingHour = parseInt(restaurant?.openingTime?.split(':')[0] || '10');
-         const closingHour = parseInt(restaurant?.closingTime?.split(':')[0] || '22');
-         
-@@ -676,16 +702,16 @@ export default function ModernTables() {
-       const targetHour = direction === 'up' ? currentHour - 1 : currentHour + 1;
-       const targetTime = `${targetHour.toString().padStart(2, '0')}:00`;
-       
--      const duration = 2;
-+      // Calculate duration in hour slots based on restaurant's average reservation duration
-+      const durationInSlots = Math.ceil((restaurant?.avgReservationDuration || 120) / 60);
-       
-       queryClient.setQueryData(["/api/tables/availability/schedule", selectedDate, restaurantTimezone], (old: any) => {
-         if (!old) return old;
-         
--        // ✅ TYPE SAFETY FIX: Proper array typing
-         const sourceSlots: string[] = [];
-         const targetSlots: string[] = [];
-         
--        for (let i = 0; i < duration; i++) {
-+        for (let i = 0; i < durationInSlots; i++) {
-           sourceSlots.push(`${(currentHour + i).toString().padStart(2, '0')}:00`);
-           targetSlots.push(`${(targetHour + i).toString().padStart(2, '0')}:00`);
-         }
-@@ -742,121 +768,18 @@ export default function ModernTables() {
-     },
-   });
- 
--  // Drag & Drop Event Handlers (unchanged)
--  const handleDragStart = (
--    e: React.DragEvent,
--    reservation: {
--      id: number;
--      guestName: string;
--      guestCount: number;
--    },
--    table: TableData,
--    time: string
--  ) => {
--    setDraggedReservation({
--      reservationId: reservation.id,
--      guestName: reservation.guestName,
--      guestCount: reservation.guestCount,
--      currentTableId: table.id,
--      currentTableName: table.name,
--      currentTime: time
--    });
--    
--    e.dataTransfer.effectAllowed = 'move';
--  };
--
--  const checkReservationConflict = (targetTableId: number, targetTime: string, duration: number = 2): boolean => {
--    if (!scheduleData || !draggedReservation) return false;
--    
--    const targetHour = parseInt(targetTime.split(':')[0]);
--    
--    for (let i = 0; i < duration; i++) {
--      const hour = (targetHour + i).toString().padStart(2, '0');
--      const timeSlot = `${hour}:00`;
--      
--      const slot = scheduleData.find(s => s.time === timeSlot);
--      const table = slot?.tables?.find((t: any) => t.id === targetTableId);
--      
--      if (table?.reservation && table.reservation.id !== draggedReservation.reservationId) {
--        return true;
--      }
--    }
--    
--    return false;
--  };
--
--  const isMovingWithinSameReservation = (targetTableId: number, targetTime: string): boolean => {
--    if (!scheduleData || !draggedReservation) return false;
--    
--    return draggedReservation.currentTableId === targetTableId && 
--           draggedReservation.currentTime === targetTime;
--  };
--
--  const handleDragOver = (e: React.DragEvent, tableId: number, time: string) => {
--    e.preventDefault();
--    
--    setDragOverSlot({ tableId, time });
--    
--    if (isMovingWithinSameReservation(tableId, time)) {
--      setIsValidDropZone(false);
--      e.dataTransfer.dropEffect = 'none';
--      return;
--    }
--    
--    const hasConflict = checkReservationConflict(tableId, time, 2);
--    const targetSlot = scheduleData?.find(slot => slot.time === time)?.tables?.find((t: any) => t.id === tableId);
--    const hasExistingReservation = targetSlot?.reservation && 
--      targetSlot.reservation.id !== draggedReservation?.reservationId;
--    
--    const capacityMatch = draggedReservation ? 
--      (targetSlot?.minGuests || 0) <= draggedReservation.guestCount && 
--      draggedReservation.guestCount <= (targetSlot?.maxGuests || 0) : false;
--    
--    const isValidDrop = !hasConflict && !hasExistingReservation && capacityMatch;
--    
--    setIsValidDropZone(isValidDrop);
--    e.dataTransfer.dropEffect = isValidDrop ? 'move' : 'none';
--  };
--
--  const handleDragLeave = () => {
--    setDragOverSlot(null);
--    setIsValidDropZone(false);
--  };
--
--  const handleDrop = (e: React.DragEvent, tableId: number, time: string) => {
--    e.preventDefault();
--    
--    if (!draggedReservation) {
--      setDraggedReservation(null);
--      setDragOverSlot(null);
--      return;
--    }
--
--    if (draggedReservation.currentTableId === tableId && draggedReservation.currentTime === time) {
--      setDraggedReservation(null);
--      setDragOverSlot(null);
--      return;
--    }
--
--    if (!isValidDropZone) {
--      setDraggedReservation(null);
--      setDragOverSlot(null);
--      return;
--    }
-+  // ✅ REMOVED: All manual drag-and-drop handlers
-+  // - handleDragStart
-+  // - handleDragOver
-+  // - handleDragLeave
-+  // - handleDrop
-+  // - checkReservationConflict
-+  // - isMovingWithinSameReservation
- 
--    moveReservationMutation.mutate({
--      reservationId: draggedReservation.reservationId,
--      newTableId: tableId,
--      newTime: time
--    });
--  };
--
--  // ✅ TYPE SAFETY FIX: Status colors for modern design with proper typing
-+  // Status colors for modern design with proper typing
-   const getStatusStyle = (status: string, hasReservation: boolean | undefined, isDragTarget = false) => {
-     if (isDragTarget) {
--      return isValidDropZone
--        ? "bg-gradient-to-br from-green-400 to-green-500 text-white shadow-lg shadow-green-400/50 ring-2 ring-green-300 scale-105"
--        : "bg-gradient-to-br from-red-400 to-red-500 text-white shadow-lg shadow-red-400/50 ring-2 ring-red-300";
-+      return "bg-gradient-to-br from-green-400 to-green-500 text-white shadow-lg shadow-green-400/50 ring-2 ring-green-300 scale-105";
-     }
-     
-     if (hasReservation) {
-@@ -877,7 +800,7 @@ export default function ModernTables() {
-     }
-   };
- 
--  // ✅ CRITICAL FIX: Enhanced form submission with validation
-+  // Enhanced form submission with validation
-   const handleAddTable = (e: React.FormEvent) => {
-     e.preventDefault();
-     
-@@ -912,7 +835,7 @@ export default function ModernTables() {
-     addTableMutation.mutate(addTableForm);
-   };
- 
--  // ✅ CRITICAL FIX: Enhanced date formatting with timezone
-+  // Enhanced date formatting with timezone
-   const formatCurrentDate = () => {
-     try {
-       if (!restaurantTimezone || !selectedDate) {
-@@ -937,7 +860,7 @@ export default function ModernTables() {
-     }
-   };
- 
--  // ✅ CRITICAL FIX: Enhanced date navigation with timezone
-+  // Enhanced date navigation with timezone
-   const getTodayDateStr = () => {
-     return getRestaurantDateString(restaurantTimezone);
-   };
-@@ -946,7 +869,7 @@ export default function ModernTables() {
-     return getTomorrowDateString(restaurantTimezone);
-   };
- 
--  // ✅ CRITICAL FIX: Show loading state while restaurant loads
-+  // Show loading state while restaurant loads
-   if (restaurantLoading) {
-     return (
-       <DashboardLayout>
-@@ -962,7 +885,7 @@ export default function ModernTables() {
-     );
-   }
- 
--  // ✅ CRITICAL FIX: Show error state if restaurant fails to load
-+  // Show error state if restaurant fails to load
-   if (restaurantError || !restaurant) {
-     return (
-       <DashboardLayout>
-@@ -982,7 +905,7 @@ export default function ModernTables() {
-     );
-   }
- 
--  // ✅ ENHANCED: Check if this is an overnight operation
-+  // Check if this is an overnight operation
-   const isOvernightOperation = restaurant?.openingTime && restaurant?.closingTime && 
-     (parseInt(restaurant.closingTime.split(':')[0]) < parseInt(restaurant.openingTime.split(':')[0]));
- 
-@@ -996,7 +919,6 @@ export default function ModernTables() {
-               <div className="flex items-center gap-2">
-                 <Calendar className="h-5 w-5 text-blue-600" />
-                 <CardTitle className="text-lg">Table Management</CardTitle>
--                {/* ✅ CRITICAL FIX: Show timezone and operation type info */}
-                 <Badge variant="outline" className="text-xs">
-                   {restaurantTimezone}
-                 </Badge>
-@@ -1008,6 +930,14 @@ export default function ModernTables() {
-                 )}
-               </div>
-               <div className="flex items-center gap-2">
-+                {/* ✅ NEW: Live Status Indicator */}
-+                {isConnected ? (
-+                    <Badge variant="outline" className="border-green-500 text-green-700 bg-green-50">
-+                        ● Live
-+                    </Badge>
-+                ) : (
-+                    <Badge variant="destructive">● Disconnected</Badge>
-+                )}
-                 <Button 
-                   onClick={() => setShowAddTableModal(true)}
-                   className="bg-green-600 hover:bg-green-700 text-white"
-@@ -1045,7 +975,7 @@ export default function ModernTables() {
-           </CardHeader>
-         </Card>
- 
--        {/* ✅ TYPE SAFETY FIX: Enhanced Table Statistics with proper array checking */}
-+        {/* Table Statistics */}
-         {tablesLoading ? (
-           <Card className="bg-blue-50 border-blue-200">
-             <CardContent className="pt-4">
-@@ -1114,7 +1044,7 @@ export default function ModernTables() {
-                   Restaurant Management - {formatCurrentDate()}
-                 </h3>
-                 <p className="text-gray-500 dark:text-gray-400 mt-1">
--                  Real-time availability across all tables • Auto-refreshes every 3 minutes
-+                  Real-time availability across all tables • Live updates via WebSocket
-                   <span className="ml-2 text-blue-600">
-                     • {restaurantTimezone}
-                   </span>
-@@ -1171,7 +1101,6 @@ export default function ModernTables() {
-         <div className="p-6">
-           {activeView === 'schedule' && (
-             <>
--              {/* ✅ CRITICAL FIX: Enhanced error handling and loading states for overnight */}
-               {scheduleError ? (
-                 <div className="text-center py-12">
-                   <p className="text-red-600 mb-4">
-@@ -1202,133 +1131,142 @@ export default function ModernTables() {
-                   )}
-                 </div>
-               ) : scheduleData && scheduleData.length > 0 && scheduleData[0]?.tables?.length > 0 ? (
--                <div className="overflow-x-auto">
--                  <div className="min-w-[800px]">
--                    {/* Sticky Header */}
--                    <div className="sticky top-0 bg-gradient-to-r from-gray-50 to-gray-100 dark:from-gray-800 dark:to-gray-750 border-b border-gray-200/50 dark:border-gray-700/50 px-4 py-2 z-10 rounded-lg mb-4">
--                      <div className="flex">
--                        <div className="w-20 flex-shrink-0 font-semibold text-gray-700 dark:text-gray-300 text-xs py-2">
--                          TIME
--                          {isOvernightOperation && (
--                            <div className="text-xs text-blue-600 mt-1">24h</div>
--                          )}
--                        </div>
--                        <div className="flex overflow-x-auto gap-1 flex-1">
--                          {scheduleData[0]?.tables?.map((table: TableData) => (
--                            <div key={table.id} className="w-24 flex-shrink-0 text-center bg-white/50 dark:bg-gray-700/50 rounded-lg p-1.5 border border-gray-200/50 dark:border-gray-600/50 relative group">
--                              <div className="font-medium text-xs text-gray-900 dark:text-gray-100">{table.name}</div>
--                              <div className="text-xs text-gray-500 dark:text-gray-400 flex items-center justify-center gap-1">
--                                <Users className="h-3 w-3" />
--                                {table.minGuests}-{table.maxGuests}
-+                <DndContext onDragEnd={handleDragEnd}>
-+                  <div className="overflow-x-auto">
-+                    <div className="min-w-[800px]">
-+                      {/* Sticky Header */}
-+                      <div className="sticky top-0 bg-gradient-to-r from-gray-50 to-gray-100 dark:from-gray-800 dark:to-gray-750 border-b border-gray-200/50 dark:border-gray-700/50 px-4 py-2 z-10 rounded-lg mb-4">
-+                        <div className="flex">
-+                          <div className="w-20 flex-shrink-0 font-semibold text-gray-700 dark:text-gray-300 text-xs py-2">
-+                            TIME
-+                            {isOvernightOperation && (
-+                              <div className="text-xs text-blue-600 mt-1">24h</div>
-+                            )}
-+                          </div>
-+                          <div className="flex overflow-x-auto gap-1 flex-1">
-+                            {scheduleData[0]?.tables?.map((table: TableData) => (
-+                              <div key={table.id} className="w-24 flex-shrink-0 text-center bg-white/50 dark:bg-gray-700/50 rounded-lg p-1.5 border border-gray-200/50 dark:border-gray-600/50 relative group">
-+                                <div className="font-medium text-xs text-gray-900 dark:text-gray-100">{table.name}</div>
-+                                <div className="text-xs text-gray-500 dark:text-gray-400 flex items-center justify-center gap-1">
-+                                  <Users className="h-3 w-3" />
-+                                  {table.minGuests}-{table.maxGuests}
-+                                </div>
-+                                <Button
-+                                  variant="destructive"
-+                                  size="sm"
-+                                  onClick={() => {
-+                                    if (confirm(`Delete table ${table.name}? This cannot be undone.`)) {
-+                                      deleteTableMutation.mutate(table.id);
-+                                    }
-+                                  }}
-+                                  className="absolute -top-2 -right-2 h-6 w-6 p-0 opacity-0 group-hover:opacity-100 transition-opacity"
-+                                >
-+                                  <X className="h-3 w-3" />
-+                                </Button>
-                               </div>
--                              <Button
--                                variant="destructive"
--                                size="sm"
--                                onClick={() => {
--                                  if (confirm(`Delete table ${table.name}? This cannot be undone.`)) {
--                                    deleteTableMutation.mutate(table.id);
--                                  }
--                                }}
--                                className="absolute -top-2 -right-2 h-6 w-6 p-0 opacity-0 group-hover:opacity-100 transition-opacity"
--                              >
--                                <X className="h-3 w-3" />
--                              </Button>
--                            </div>
--                          ))}
-+                            ))}
-+                          </div>
-                         </div>
-                       </div>
--                    </div>
- 
--                    {/* ✅ ENHANCED: Time Slots with overnight operation visual cues */}
--                    <div className="space-y-1">
--                      {scheduleData?.map((slot: ScheduleSlot) => {
--                        const hour = parseInt(slot.time.split(':')[0]);
--                        const isEarlyMorning = isOvernightOperation && hour < 6;
--                        const isLateNight = isOvernightOperation && hour >= 22;
--                        
--                        return (
--                          <div 
--                            key={slot.time} 
--                            className={cn(
--                              "flex hover:bg-gray-50/50 dark:hover:bg-gray-800/50 rounded-lg transition-colors duration-200",
--                              isEarlyMorning && "bg-blue-50/30",
--                              isLateNight && "bg-purple-50/30"
--                            )}
--                          >
--                            <div className={cn(
--                              "w-20 flex-shrink-0 px-4 py-3 text-sm font-medium border-r border-gray-200/50 dark:border-gray-700/50",
--                              isEarlyMorning && "text-blue-700 dark:text-blue-300",
--                              isLateNight && "text-purple-700 dark:text-purple-300",
--                              !isEarlyMorning && !isLateNight && "text-gray-700 dark:text-gray-300"
--                            )}>
--                              {slot.time}
--                              {isOvernightOperation && (
--                                <div className="text-xs opacity-60">
--                                  {isEarlyMorning ? "Early" : isLateNight ? "Night" : "Day"}
--                                </div>
-+                      {/* Time Slots with overnight operation visual cues */}
-+                      <div className="space-y-1">
-+                        {scheduleData?.map((slot: ScheduleSlot) => {
-+                          const hour = parseInt(slot.time.split(':')[0]);
-+                          const isEarlyMorning = isOvernightOperation && hour < 6;
-+                          const isLateNight = isOvernightOperation && hour >= 22;
-+                          
-+                          return (
-+                            <div 
-+                              key={slot.time} 
-+                              className={cn(
-+                                "flex hover:bg-gray-50/50 dark:hover:bg-gray-800/50 rounded-lg transition-colors duration-200",
-+                                isEarlyMorning && "bg-blue-50/30",
-+                                isLateNight && "bg-purple-50/30"
-                               )}
--                            </div>
--                            <div className="flex overflow-x-auto gap-1 flex-1 px-2 py-1">
--                              {slot.tables?.map((table: TableData) => {
--                                const hasReservation = table.reservation && table.reservation.status === 'confirmed';
--                                const isDragTarget = dragOverSlot?.tableId === table.id && dragOverSlot?.time === slot.time;
--                                
--                                return (
--                                  <div
--                                    key={table.id}
--                                    className={cn(
--                                      "w-24 flex-shrink-0 rounded-lg p-2 text-center transition-all duration-200",
--                                      getStatusStyle(table.status, hasReservation, isDragTarget),
--                                      !hasReservation && "hover:scale-105"
--                                    )}
--                                    draggable={hasReservation}
--                                    onDragStart={(e) => hasReservation && table.reservation && handleDragStart(
--                                      e,
--                                      {
--                                        id: table.reservation.id || 0,
--                                        guestName: table.reservation.guestName,
--                                        guestCount: table.reservation.guestCount
--                                      },
--                                      table,
--                                      slot.time
--                                    )}
--                                    onDragOver={(e) => handleDragOver(e, table.id, slot.time)}
--                                    onDragLeave={handleDragLeave}
--                                    onDrop={(e) => handleDrop(e, table.id, slot.time)}
--                                    onContextMenu={(e) => {
--                                      e.preventDefault();
--                                      setContextMenu({
--                                        x: e.clientX,
--                                        y: e.clientY,
--                                        reservationId: hasReservation ? table.reservation?.id : undefined,
--                                        tableId: table.id,
--                                        timeSlot: slot.time,
--                                        guestName: hasReservation ? table.reservation?.guestName : undefined,
--                                      });
--                                    }}
--                                  >
--                                    <div className="text-xs font-bold opacity-90 flex items-center justify-center gap-1">
--                                      {hasReservation && <Move className="h-3 w-3" />}
--                                      {table.name}
--                                    </div>
--                                    {hasReservation && table.reservation && (
--                                      <div className="text-xs opacity-75 mt-1 truncate">
--                                        {table.reservation.guestName}
--                                      </div>
--                                    )}
--                                    <div className="text-xs opacity-60 mt-1">
--                                      {hasReservation ? `${table.reservation?.guestCount} guests` : table.status}
--                                    </div>
-+                            >
-+                              <div className={cn(
-+                                "w-20 flex-shrink-0 px-4 py-3 text-sm font-medium border-r border-gray-200/50 dark:border-gray-700/50",
-+                                isEarlyMorning && "text-blue-700 dark:text-blue-300",
-+                                isLateNight && "text-purple-700 dark:text-purple-300",
-+                                !isEarlyMorning && !isLateNight && "text-gray-700 dark:text-gray-300"
-+                              )}>
-+                                {slot.time}
-+                                {isOvernightOperation && (
-+                                  <div className="text-xs opacity-60">
-+                                    {isEarlyMorning ? "Early" : isLateNight ? "Night" : "Day"}
-                                   </div>
--                                );
--                              })}
-+                                )}
-+                              </div>
-+                              <div className="flex overflow-x-auto gap-1 flex-1 px-2 py-1">
-+                                {slot.tables?.map((table: TableData) => {
-+                                  const hasReservation = table.reservation && table.reservation.status === 'confirmed';
-+                                  const uniqueSlotId = `${table.id}-${slot.time}`; // Unique ID for the droppable area
-+                                  
-+                                  return (
-+                                    <div
-+                                      key={table.id}
-+                                      className={cn(
-+                                        "w-24 flex-shrink-0 rounded-lg p-2 text-center transition-all duration-200",
-+                                        getStatusStyle(table.status, hasReservation),
-+                                        !hasReservation && "hover:scale-105"
-+                                      )}
-+                                      onContextMenu={(e) => {
-+                                        e.preventDefault();
-+                                        setContextMenu({
-+                                          x: e.clientX,
-+                                          y: e.clientY,
-+                                          reservationId: hasReservation ? table.reservation?.id : undefined,
-+                                          tableId: table.id,
-+                                          timeSlot: slot.time,
-+                                          guestName: hasReservation ? table.reservation?.guestName : undefined,
-+                                        });
-+                                      }}
-+                                    >
-+                                      {/* ✅ NEW: Use DraggableReservation and DroppableSlot components */}
-+                                      {hasReservation && table.reservation ? (
-+                                        <DraggableReservation 
-+                                          id={table.reservation.id} 
-+                                          data={{
-+                                            guestName: table.reservation.guestName,
-+                                            guestCount: table.reservation.guestCount,
-+                                          }}
-+                                        >
-+                                          {/* The content of the reservation card */}
-+                                          <div className="text-xs font-bold opacity-90 flex items-center justify-center gap-1 cursor-grab active:cursor-grabbing">
-+                                            <Move className="h-3 w-3" />
-+                                            {table.name}
-+                                          </div>
-+                                          <div className="text-xs opacity-75 mt-1 truncate">
-+                                            {table.reservation.guestName}
-+                                          </div>
-+                                          <div className="text-xs opacity-60 mt-1">
-+                                            {`${table.reservation.guestCount} guests`}
-+                                          </div>
-+                                        </DraggableReservation>
-+                                      ) : (
-+                                        <DroppableSlot 
-+                                          id={uniqueSlotId}
-+                                          data={{ tableId: table.id, time: slot.time, table: table }}
-+                                        >
-+                                          {/* The content of an empty, droppable slot */}
-+                                          <div className="h-full flex flex-col justify-center">
-+                                            <div className="text-xs font-bold opacity-90">{table.name}</div>
-+                                            <div className="text-xs opacity-60 mt-1">{table.status}</div>
-+                                          </div>
-+                                        </DroppableSlot>
-+                                      )}
-+                                    </div>
-+                                  );
-+                                })}
-+                              </div>
-                             </div>
--                          </div>
--                        );
--                      })}
-+                          );
-+                        })}
-+                      </div>
-                     </div>
-                   </div>
--                </div>
-+                </DndContext>
-               ) : (
-                 <div className="text-center py-12">
-                   <Users className="h-12 w-12 text-gray-400 mx-auto mb-4" />
-@@ -1365,7 +1303,7 @@ export default function ModernTables() {
-       </div>
-       </div>
- 
--      {/* ✅ CRITICAL FIX: Enhanced Add Table Modal */}
-+      {/* Enhanced Add Table Modal */}
-       <Dialog open={showAddTableModal} onOpenChange={setShowAddTableModal}>
-         <DialogContent className="max-w-md">
-           <DialogHeader>
-@@ -1475,7 +1413,7 @@ export default function ModernTables() {
-         </DialogContent>
-       </Dialog>
- 
--      {/* Context Menu (unchanged) */}
-+      {/* Context Menu */}
-       {contextMenu && (
-         <>
-           <div 
-diff --git a/client/src/pages/reservations.tsx b/client/src/pages/reservations.tsx
-index 6600783..0ad06a7 100644
---- a/client/src/pages/reservations.tsx
-+++ b/client/src/pages/reservations.tsx
-@@ -23,6 +23,7 @@ import {
- } from "lucide-react";
- import { RollingCalendar } from "@/components/ui/rolling-calendar";
- import { useRestaurantTimezone } from "@/components/layout/DashboardLayout";
-+import { useWebSocketContext } from "@/components/websocket/WebSocketContext";
- 
- // ✅ Helper function to safely parse PostgreSQL timestamps
- const parsePostgresTimestamp = (timestamp: string): DateTime | null => {
-@@ -73,6 +74,9 @@ const extractReservationData = (reservationData: any) => {
- };
- 
- export default function Reservations() {
-+    // ✅ Get WebSocket connection status for real-time indicator
-+    const { isConnected, connectionStatus } = useWebSocketContext();
-+    
-     // ✅ Get timezone and restaurant from context
-     const { restaurantTimezone, restaurant, refreshRestaurant } = useRestaurantTimezone();
-     const restaurantId = restaurant?.id || 1;
-@@ -158,7 +162,7 @@ export default function Reservations() {
-         };
-     };
- 
--    // ✅ Restaurant reservations query with timezone dependency
-+    // ✅ Restaurant reservations query with REAL-TIME WEBSOCKET UPDATES (no more polling!)
-     const { data: reservations, isLoading, error } = useQuery({
-         queryKey: ["/api/reservations", restaurantId, restaurantTimezone, dateRangeFilter, statusFilter],
-         queryFn: async () => {
-@@ -190,7 +194,7 @@ export default function Reservations() {
-                 throw error;
-             }
-         },
--        refetchInterval: 30000,
-+        // ✅ REMOVED: refetchInterval: 30000 - Now using real-time WebSocket updates!
-         refetchOnWindowFocus: true,
-         enabled: !!restaurantId && !!restaurantTimezone,
-         staleTime: 0,
-@@ -749,6 +753,17 @@ export default function Reservations() {
-                         </p>
-                     </div>
-                     <div className="mt-4 flex space-x-3 md:mt-0">
-+                        {/* ✅ REAL-TIME STATUS INDICATOR */}
-+                        {isConnected ? (
-+                            <Badge variant="outline" className="border-green-500 text-green-700 bg-green-50">
-+                                ● Live Updates
-+                            </Badge>
-+                        ) : (
-+                            <Badge variant="destructive" className="animate-pulse">
-+                                ● Disconnected
-+                            </Badge>
-+                        )}
-+                        
-                         <Button onClick={() => setIsReservationModalOpen(true)}>
-                             <Plus className="mr-2 h-4 w-4" />
-                             New Reservation
-diff --git a/package-lock.json b/package-lock.json
-index 867dc09..0192fa5 100644
---- a/package-lock.json
-+++ b/package-lock.json
-@@ -10,6 +10,7 @@
-       "license": "MIT",
-       "dependencies": {
-         "@anthropic-ai/sdk": "^0.56.0",
-+        "@dnd-kit/core": "^6.3.1",
-         "@google/generative-ai": "^0.24.1",
-         "@hookform/resolvers": "^3.10.0",
-         "@jridgewell/trace-mapping": "^0.3.25",
-@@ -573,6 +574,45 @@
-         "kuler": "^2.0.0"
-       }
-     },
-+    "node_modules/@dnd-kit/accessibility": {
-+      "version": "3.1.1",
-+      "resolved": "https://registry.npmjs.org/@dnd-kit/accessibility/-/accessibility-3.1.1.tgz",
-+      "integrity": "sha512-2P+YgaXF+gRsIihwwY1gCsQSYnu9Zyj2py8kY5fFvUM1qm2WA2u639R6YNVfU4GWr+ZM5mqEsfHZZLoRONbemw==",
-+      "license": "MIT",
-+      "dependencies": {
-+        "tslib": "^2.0.0"
-+      },
-+      "peerDependencies": {
-+        "react": ">=16.8.0"
-+      }
-+    },
-+    "node_modules/@dnd-kit/core": {
-+      "version": "6.3.1",
-+      "resolved": "https://registry.npmjs.org/@dnd-kit/core/-/core-6.3.1.tgz",
-+      "integrity": "sha512-xkGBRQQab4RLwgXxoqETICr6S5JlogafbhNsidmrkVv2YRs5MLwpjoF2qpiGjQt8S9AoxtIV603s0GIUpY5eYQ==",
-+      "license": "MIT",
-+      "dependencies": {
-+        "@dnd-kit/accessibility": "^3.1.1",
-+        "@dnd-kit/utilities": "^3.2.2",
-+        "tslib": "^2.0.0"
-+      },
-+      "peerDependencies": {
-+        "react": ">=16.8.0",
-+        "react-dom": ">=16.8.0"
-+      }
-+    },
-+    "node_modules/@dnd-kit/utilities": {
-+      "version": "3.2.2",
-+      "resolved": "https://registry.npmjs.org/@dnd-kit/utilities/-/utilities-3.2.2.tgz",
-+      "integrity": "sha512-+MKAJEOfaBe5SmV6t34p80MMKhjvUz0vRrvVJbPT0WElzaOJ/1xs+D+KDv+tD/NE5ujfrChEcshd4fLn0wpiqg==",
-+      "license": "MIT",
-+      "dependencies": {
-+        "tslib": "^2.0.0"
-+      },
-+      "peerDependencies": {
-+        "react": ">=16.8.0"
-+      }
-+    },
-     "node_modules/@drizzle-team/brocli": {
-       "version": "0.10.2",
-       "resolved": "https://registry.npmjs.org/@drizzle-team/brocli/-/brocli-0.10.2.tgz",
-@@ -5224,9 +5264,9 @@
-       }
-     },
-     "node_modules/caniuse-lite": {
--      "version": "1.0.30001677",
--      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001677.tgz",
--      "integrity": "sha512-fmfjsOlJUpMWu+mAAtZZZHz7UEwsUxIIvu1TJfO1HqFQvB/B+ii0xr9B5HpbZY/mC4XZ8SvjHJqtAY6pDPQEog==",
-+      "version": "1.0.30001731",
-+      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001731.tgz",
-+      "integrity": "sha512-lDdp2/wrOmTRWuoB5DpfNkC0rJDU8DqRa6nYL6HK6sytw70QMopt/NIc/9SM7ylItlBWfACXk0tEn37UWM/+mg==",
-       "dev": true,
-       "funding": [
-         {
-diff --git a/package.json b/package.json
-index bdfd3e3..71ab6ad 100644
---- a/package.json
-+++ b/package.json
-@@ -16,6 +16,7 @@
-   },
-   "dependencies": {
-     "@anthropic-ai/sdk": "^0.56.0",
-+    "@dnd-kit/core": "^6.3.1",
-     "@google/generative-ai": "^0.24.1",
-     "@hookform/resolvers": "^3.10.0",
-     "@jridgewell/trace-mapping": "^0.3.25",
-diff --git a/server/index.ts b/server/index.ts
-index d51e0f8..ab38fae 100644
---- a/server/index.ts
-+++ b/server/index.ts
-@@ -1,6 +1,10 @@
- import 'dotenv/config';
- import express, { type Request, Response, NextFunction } from "express";
--// 🔽 ADD THIS IMPORT AT THE TOP
-+// 🔽 ADD WEBSOCKET IMPORTS
-+import { createServer } from "http";
-+import { WebSocketServer } from "ws";
-+import { WebSocketManager } from './services/websocket-manager.js';
-+import { ExtendedWebSocketServer } from './types/websocket.js';
- import serveIndex from 'serve-index';
- import { registerRoutes } from "./routes";
- import { setupVite, serveStatic, log } from "./vite";
-@@ -13,6 +17,7 @@ import { aiService } from './services/ai-service';
- // 🔧 ES MODULE FIX: Moved to top-level imports
- import fs from 'fs';
- import path from 'path';
-+import { URL } from 'url'; // 👈 ADD URL IMPORT
- 
- // 🔒 SUPER ADMIN: Authentication imports (moved from routes.ts)
- import bcrypt from "bcryptjs";
-@@ -100,7 +105,7 @@ passport.use('local-tenant', new LocalStrategy(
-                 console.log(`[Auth] Invalid password for tenant user: ${email}`);
-                 return done(null, false, { message: "Incorrect password." });
-             }
--            
-+
-             // Enhanced user object with isSuperAdmin flag
-             const authenticatedUser: BaseTenantUser = {
-                 id: user.id,
-@@ -109,7 +114,7 @@ passport.use('local-tenant', new LocalStrategy(
-                 role: user.role as 'restaurant' | 'staff',
-                 isSuperAdmin: false
-             };
--            
-+
-             console.log(`✅ [Auth] Tenant user authenticated: ${email} (ID: ${user.id})`);
-             return done(null, authenticatedUser);
-         } catch (err) {
-@@ -125,26 +130,26 @@ passport.use('local-superadmin', new LocalStrategy(
-     async (email, password, done) => {
-         try {
-             console.log(`[SuperAdmin] Super admin login attempt for: ${email}`);
--            
-+
-             const superAdmin = await storage.getSuperAdminByEmail(email);
-             if (!superAdmin) {
-                 console.log(`[SuperAdmin] Super admin not found: ${email}`);
-                 return done(null, false, { message: "Invalid super admin credentials." });
-             }
--            
-+
-             // ✅ FIXED: Verify password against the correct 'passwordHash' property
-             const isValidPassword = await bcrypt.compare(password, superAdmin.passwordHash);
-             if (!isValidPassword) {
-                 console.log(`[SuperAdmin] Invalid password for super admin: ${email}`);
-                 return done(null, false, { message: "Invalid super admin credentials." });
-             }
--            
-+
-             // Check if super admin account is active
-             if (superAdmin.isActive === false) { // Check for explicit false value
-                 console.log(`[SuperAdmin] Inactive super admin attempted login: ${email}`);
-                 return done(null, false, { message: "Super admin account is inactive." });
-             }
--            
-+
-             const authenticatedSuperAdmin: SuperAdminUser = {
-                 id: superAdmin.id,
-                 email: superAdmin.email,
-@@ -152,16 +157,16 @@ passport.use('local-superadmin', new LocalStrategy(
-                 role: 'super_admin',
-                 isSuperAdmin: true
-             };
--            
-+
-             console.log(`✅ [SuperAdmin] Super admin authenticated: ${email} (ID: ${superAdmin.id})`);
--            
-+
-             // The logSuperAdminActivity function does not exist on the storage object yet.
-             // We can comment this out to allow login to succeed. We can add this feature back later.
-             // await storage.logSuperAdminActivity(superAdmin.id, 'login', {
-             //     userAgent: 'web-dashboard',
-             //     timestamp: new Date().toISOString()
-             // });
--            
-+
-             return done(null, authenticatedSuperAdmin);
-         } catch (err) {
-             console.error(`[SuperAdmin] Error during super admin authentication:`, err);
-@@ -205,7 +210,7 @@ passport.serializeUser((user: any, done) => {
- passport.deserializeUser(async (sessionData: any, done) => {
-     try {
-         let user: AuthenticatedUser;
--        
-+
-         if (sessionData.isSuperAdmin) {
-             // Load super admin user
-             const superAdmin = await storage.getSuperAdmin(sessionData.id);
-@@ -213,7 +218,7 @@ passport.deserializeUser(async (sessionData: any, done) => {
-                 console.log(`[Auth] Inactive or missing super admin during deserialization: ID=${sessionData.id}`);
-                 return done(null, false);
-             }
--            
-+
-             user = {
-                 id: superAdmin.id,
-                 email: superAdmin.email,
-@@ -229,7 +234,7 @@ passport.deserializeUser(async (sessionData: any, done) => {
-                 console.log(`[Auth] Missing tenant user during deserialization: ID=${sessionData.id}`);
-                 return done(null, false);
-             }
--            
-+
-             user = {
-                 id: tenantUser.id,
-                 email: tenantUser.email,
-@@ -239,7 +244,7 @@ passport.deserializeUser(async (sessionData: any, done) => {
-             };
-             console.log(`[Auth] Deserialized tenant user: ${tenantUser.email} (ID: ${tenantUser.id})`);
-         }
--        
-+
-         done(null, user);
-     } catch (err) {
-         console.error(`[Auth] Error during user deserialization:`, err);
-@@ -457,6 +462,8 @@ app.use('/reports', serveIndex('reports', { 'icons': true }));
- app.use('/analytics', express.static('analytics', { etag: false, lastModified: false })); // Recommended change
- app.use('/analytics', serveIndex('analytics', { 'icons': true }));
- 
-+// 🔌 WEBSOCKET MANAGER: Global variable to store WebSocket manager instance
-+let wsManager: WebSocketManager | null = null;
- 
- // Self-executing async function to initialize the server
- (async () => {
-@@ -488,8 +495,40 @@ app.use('/analytics', serveIndex('analytics', { 'icons': true }));
-             dashboardEnabled: process.env.ENABLE_FREE_DASHBOARD === 'true'
-         });
- 
--        // 🔒 Register all API routes (authentication is now set up above)
--        const server = await registerRoutes(app);
-+        // 🔌 WEBSOCKET SETUP: Create HTTP server
-+        console.log('🔌 [Server] Creating HTTP server with WebSocket support');
-+        const httpServer = createServer(app);
-+
-+        // ✅ FIX: Create WebSocket server WITHOUT attaching it to the HTTP server automatically
-+        const wss = new WebSocketServer({
-+            noServer: true
-+        }) as ExtendedWebSocketServer;
-+
-+        // Initialize WebSocket manager
-+        wsManager = new WebSocketManager(wss);
-+        console.log('✅ [Server] WebSocket manager initialized');
-+
-+        // Add broadcast methods to WebSocketServer for routes to use
-+        wss.broadcast = (data: object) => {
-+            wsManager!.broadcast(data as any);
-+        };
-+
-+        wss.broadcastToTenant = (tenantId: number, data: object) => {
-+            wsManager!.broadcastToTenant(tenantId, data as any);
-+        };
-+
-+        // Log WebSocket initialization as business event
-+        smartLog.businessEvent('websocket_initialized', {
-+            path: '/ws',
-+            tenantIsolation: true,
-+            authenticationRequired: true
-+        });
-+
-+        console.log('✅ [Server] WebSocket server initialized');
-+
-+        // 🔒 Register all API routes (pass WebSocket server to routes)
-+        await registerRoutes(app, wss);
-+        console.log('✅ [Server] Routes registered with WebSocket support');
- 
-         // [FIX] Corrected global error handling middleware with Smart Logging.
-         // This should be placed AFTER all routes have been registered.
-@@ -514,7 +553,7 @@ app.use('/analytics', serveIndex('analytics', { 'icons': true }));
-         // In development mode, set up Vite for hot module replacement.
-         // In production, serve the pre-built static client files.
-         if (app.get("env") === "development") {
--            await setupVite(app, server);
-+            await setupVite(app, httpServer);
-         } else {
-             serveStatic(app);
-         }
-@@ -524,8 +563,29 @@ app.use('/analytics', serveIndex('analytics', { 'icons': true }));
-         await initializeAllTelegramBots();
-         smartLog.info('Telegram bots initialized successfully');
- 
-+        // ✅ FIX: Add manual 'upgrade' handler to route WebSocket traffic
-+        httpServer.on('upgrade', (request, socket, head) => {
-+            // Use URL to parse the path
-+            const pathname = request.url ? new URL(request.url, `http://${request.headers.host}`).pathname : '';
-+
-+            console.log(`[Upgrade] Handling upgrade request for path: ${pathname}`);
-+
-+            if (pathname === '/ws') {
-+                // If the path is for our app's WebSocket, handle it
-+                wss.handleUpgrade(request, socket, head, (ws) => {
-+                    wss.emit('connection', ws, request);
-+                });
-+            } else {
-+                // IMPORTANT: For any other path, do nothing.
-+                // This allows Vite's HMR WebSocket to be handled by its own listener,
-+                // which was attached in setupVite().
-+                // If we were to destroy the socket here, HMR would break.
-+                console.log(`[Upgrade] Path not /ws, ignoring for Vite HMR to handle.`);
-+            }
-+        });
-+
-         const port = process.env.PORT || 5000;
--        server.listen({
-+        httpServer.listen({
-             port,
-             host: "0.0.0.0",
-         }, () => {
-@@ -538,7 +598,8 @@ app.use('/analytics', serveIndex('analytics', { 'icons': true }));
-                 host: '0.0.0.0',
-                 environment: process.env.NODE_ENV || 'development',
-                 dashboardUrl: process.env.ENABLE_FREE_DASHBOARD === 'true' ? `http://localhost:${port}/dashboard` : null,
--                healthUrl: `http://localhost:${port}/health`
-+                healthUrl: `http://localhost:${port}/health`,
-+                websocketUrl: `ws://localhost:${port}/ws`
-             });
- 
-             // 📊 Display useful URLs
-@@ -550,9 +611,10 @@ app.use('/analytics', serveIndex('analytics', { 'icons': true }));
-             console.log(`   📁 Log Files: http://localhost:${port}/logs/app.log`);
-             console.log(`   📁 Reports Dir: http://localhost:${port}/reports/`);
-             console.log(`   📁 Analytics Dir: http://localhost:${port}/analytics/`);
-+            console.log(`   🔌 WebSocket: ws://localhost:${port}/ws`);
-         });
- 
--        // 📊 ENHANCED: Graceful shutdown logic with Smart Logging
-+        // 📊 ENHANCED: Graceful shutdown logic with Smart Logging and WebSocket cleanup
-         const shutdown = (signal: string) => {
-             smartLog.info('Graceful shutdown initiated', {
-                 signal,
-@@ -567,11 +629,18 @@ app.use('/analytics', serveIndex('analytics', { 'icons': true }));
- 
-             console.log(`\nReceived ${signal}. Shutting down gracefully...`);
- 
-+            // 🔌 WEBSOCKET CLEANUP: Cleanup WebSocket connections
-+            if (wsManager) {
-+                console.log('🔌 [Server] Cleaning up WebSocket connections...');
-+                wsManager.cleanup();
-+                smartLog.info('WebSocket connections cleaned up');
-+            }
-+
-             // Stop all active Telegram bots
-             cleanupTelegramBots();
- 
-             // Close the HTTP server
--            server.close(() => {
-+            httpServer.close(() => {
-                 smartLog.info('HTTP server closed successfully');
-                 console.log("✅ HTTP server closed.");
- 
-@@ -643,4 +712,4 @@ app.use('/analytics', serveIndex('analytics', { 'icons': true }));
-         console.error('❌ Application startup failed:', startupError);
-         process.exit(1);
-     }
--})();
-\ No newline at end of file
-+})();
-diff --git a/server/routes.ts b/server/routes.ts
-index 84e3e36..a87918e 100644
---- a/server/routes.ts
-+++ b/server/routes.ts
-@@ -1,5 +1,7 @@
- import type { Express, Request, Response, NextFunction } from "express";
- import { createServer, type Server } from "http";
-+// 🔌 ADD WEBSOCKET IMPORTS
-+import { ExtendedWebSocketServer } from './types/websocket.js';
- import { storage } from "./storage";
- import { db, pool, getDatabaseHealth } from "./db";
- import {
-@@ -118,7 +120,12 @@ function isOvernightOperation(openingTime: string, closingTime: string): boolean
-     return closingMinutes < openingMinutes;
- }
- 
--export async function registerRoutes(app: Express): Promise<Server> {
-+// 🔌 WEBSOCKET INTEGRATION: Updated function signature to accept WebSocket server
-+export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer): Promise<Server> {
-+
-+    // 🔌 WEBSOCKET SETUP: Store WebSocket server in Express app context
-+    app.set('wss', wss);
-+    console.log('✅ [Routes] WebSocket server stored in Express app context');
- 
-     // 🔒 SUPER ADMIN: Authorization Middleware Functions
-     
-@@ -279,7 +286,48 @@ export async function registerRoutes(app: Express): Promise<Server> {
-     });
- 
-     // ============================================================================
--    // 🔒 SUPER ADMIN: Tenant Management API Routes (NEW)
-+    // 🔌 WEBSOCKET STATS ENDPOINT (Optional debugging endpoint)
-+    // ============================================================================
-+    app.get("/api/websocket/stats", isAuthenticated, tenantIsolation, async (req, res, next) => {
-+        try {
-+            const wsServer = req.app.get('wss') as ExtendedWebSocketServer;
-+            
-+            if (!wsServer) {
-+                return res.status(503).json({ error: 'WebSocket server not available' });
-+            }
-+
-+            let stats = {
-+                connected: false,
-+                totalConnections: 0,
-+                authenticatedConnections: 0,
-+                tenantGroups: 0,
-+                tenantStats: {},
-+                serverAvailable: true
-+            };
-+
-+            try {
-+                if (wsServer.clients) {
-+                    stats.totalConnections = wsServer.clients.size;
-+                    stats.connected = true;
-+                }
-+            } catch (error) {
-+                console.error('[WebSocket Stats] Error getting stats:', error);
-+                stats.serverAvailable = false;
-+            }
-+
-+            res.json({
-+                ...stats,
-+                timestamp: new Date().toISOString(),
-+                path: '/ws'
-+            });
-+        } catch (error) {
-+            console.error('[WebSocket Stats] Endpoint error:', error);
-+            next(error);
-+        }
-+    });
-+
-+    // ============================================================================
-+    // 🔒 SUPER ADMIN: Tenant Management API Routes (Existing - no WebSocket needed)
-     // ============================================================================
- 
-     // 🔒 SUPER ADMIN: Get all tenants with filtering and pagination
-@@ -555,9 +603,15 @@ export async function registerRoutes(app: Express): Promise<Server> {
- 
-             // If status changed to suspended, log it specifically
-             if (validatedData.status === 'suspended') {
--                await storage.logTenantAudit(tenantId, 'suspended', 'Tenant suspended by super admin', {
--                    adminId: (req.user as SuperAdminUser).id,
--                    reason: validatedData.adminNotes || 'No reason provided'
-+                await storage.logTenantAudit({
-+                    restaurantId: tenantId,
-+                    action: 'suspended',
-+                    performedBy: 'super_admin',
-+                    performedByType: 'super_admin',
-+                    details: {
-+                        adminId: (req.user as SuperAdminUser).id,
-+                        reason: validatedData.adminNotes || 'No reason provided'
-+                    }
-                 });
-             }
- 
-@@ -603,17 +657,20 @@ export async function registerRoutes(app: Express): Promise<Server> {
-             }
- 
-             // Suspend the tenant
--            await storage.suspendTenant(tenantId, {
--                reason: reason || 'Suspended by administrator',
--                suspendedBy: (req.user as SuperAdminUser).id,
--                notifyOwner: notifyOwner
--            });
-+            await storage.suspendTenant(tenantId, reason || 'Suspended by administrator');
- 
-             // Log the suspension
--            await storage.logTenantAudit(tenantId, 'suspended', reason || 'Suspended by administrator', {
--                adminId: (req.user as SuperAdminUser).id,
--                adminEmail: (req.user as SuperAdminUser).email,
--                notifyOwner: notifyOwner
-+            await storage.logTenantAudit({
-+                restaurantId: tenantId,
-+                action: 'suspended',
-+                performedBy: 'super_admin',
-+                performedByType: 'super_admin',
-+                details: {
-+                    adminId: (req.user as SuperAdminUser).id,
-+                    adminEmail: (req.user as SuperAdminUser).email,
-+                    notifyOwner: notifyOwner,
-+                    reason: reason || 'Suspended by administrator'
-+                }
-             });
- 
-             console.log(`✅ [SuperAdmin] Tenant ${tenantId} suspended successfully`);
-@@ -654,17 +711,20 @@ export async function registerRoutes(app: Express): Promise<Server> {
-             }
- 
-             // Reactivate the tenant
--            await storage.reactivateTenant(tenantId, {
--                notes: notes || 'Reactivated by administrator',
--                reactivatedBy: (req.user as SuperAdminUser).id,
--                notifyOwner: notifyOwner
--            });
-+            await storage.reactivateTenant(tenantId);
- 
-             // Log the reactivation
--            await storage.logTenantAudit(tenantId, 'reactivated', notes || 'Reactivated by administrator', {
--                adminId: (req.user as SuperAdminUser).id,
--                adminEmail: (req.user as SuperAdminUser).email,
--                notifyOwner: notifyOwner
-+            await storage.logTenantAudit({
-+                restaurantId: tenantId,
-+                action: 'reactivated',
-+                performedBy: 'super_admin',
-+                performedByType: 'super_admin',
-+                details: {
-+                    adminId: (req.user as SuperAdminUser).id,
-+                    adminEmail: (req.user as SuperAdminUser).email,
-+                    notifyOwner: notifyOwner,
-+                    notes: notes || 'Reactivated by administrator'
-+                }
-             });
- 
-             console.log(`✅ [SuperAdmin] Tenant ${tenantId} reactivated successfully`);
-@@ -690,10 +750,7 @@ export async function registerRoutes(app: Express): Promise<Server> {
- 
-             console.log(`[SuperAdmin] Fetching platform metrics: timeframe=${timeframe}`);
- 
--            const metrics = await storage.getPlatformMetrics({
--                timeframe: timeframe as string,
--                includeDetails: includeDetails === 'true'
--            });
-+            const metrics = await storage.getPlatformMetrics();
- 
-             res.json({
-                 metrics: metrics,
-@@ -746,7 +803,7 @@ export async function registerRoutes(app: Express): Promise<Server> {
-         const user = req.user as SuperAdminUser;
-         
-         try {
--            const profile = await storage.getSuperAdminProfile(user.id);
-+            const profile = await storage.getSuperAdmin(user.id);
-             
-             res.json({
-                 id: user.id,
-@@ -842,7 +899,7 @@ export async function registerRoutes(app: Express): Promise<Server> {
-         }
-     });
- 
--    // 🔒 Table routes with tenant isolation and usage tracking
-+    // 🔒 Table routes with tenant isolation and usage tracking + WebSocket integration
-     app.get("/api/tables", isAuthenticated, tenantIsolation, async (req, res, next) => {
-         try {
-             const context = getTenantContext(req);
-@@ -887,8 +944,10 @@ export async function registerRoutes(app: Express): Promise<Server> {
-         }
-     });
- 
-+    // 🔌 WEBSOCKET INTEGRATION: Table updates broadcast status changes
-     app.patch("/api/tables/:id", isAuthenticated, tenantIsolation, async (req, res, next) => {
-         try {
-+            const wss = req.app.get('wss') as ExtendedWebSocketServer;
-             const context = getTenantContext(req);
-             const tableId = parseInt(req.params.id);
-             const table = await storage.getTable(tableId);
-@@ -902,6 +961,21 @@ export async function registerRoutes(app: Express): Promise<Server> {
-             
-             CacheInvalidation.onTableChange(context.restaurant.id);
-             
-+            // 🔌 WEBSOCKET: Broadcast table status change
-+            if (validatedData.status && validatedData.status !== table.status) {
-+                wss.broadcastToTenant(context.restaurant.id, {
-+                    type: 'TABLE_STATUS_UPDATED',
-+                    payload: {
-+                        tableId: updatedTable.id,
-+                        tableName: updatedTable.name,
-+                        oldStatus: table.status,
-+                        newStatus: updatedTable.status,
-+                        timestamp: new Date().toISOString()
-+                    }
-+                });
-+                console.log(`🔌 [WebSocket] Broadcasted table status change: ${table.name} ${table.status} → ${updatedTable.status}`);
-+            }
-+            
-             res.json(updatedTable);
-         } catch (error: any) {
-             if (error instanceof z.ZodError) {
-@@ -944,10 +1018,14 @@ export async function registerRoutes(app: Express): Promise<Server> {
- 
-     app.post("/api/guests", isAuthenticated, tenantIsolation, trackUsage('guest_added'), async (req, res, next) => {
-         try {
--            const validatedData = insertGuestSchema.parse(req.body);
--            let guest: Guest | undefined = await storage.getGuestByPhone(validatedData.phone as string);
-+            const context = getTenantContext(req);
-+            const validatedData = insertGuestSchema.parse({
-+                ...req.body,
-+                restaurantId: context.restaurant.id,
-+            });
-+            let guest: Guest | undefined = await storage.getGuestByPhone(validatedData.phone as string, context.restaurant.id);
-             if (guest) {
--                guest = await storage.updateGuest(guest.id, validatedData);
-+                guest = await storage.updateGuest(guest.id, validatedData, context.restaurant.id);
-             } else {
-                 guest = await storage.createGuest(validatedData);
-             }
-@@ -966,7 +1044,7 @@ export async function registerRoutes(app: Express): Promise<Server> {
-             const guestId = parseInt(req.params.id);
-             const context = getTenantContext(req);
- 
--            const guest = await storage.getGuest(guestId);
-+            const guest = await storage.getGuest(guestId, context.restaurant.id);
-             if (!guest) {
-                 return res.status(404).json({ message: "Guest not found" });
-             }
-@@ -1251,12 +1329,9 @@ export async function registerRoutes(app: Express): Promise<Server> {
-     // ✅ ENHANCED: Available Times with Exact Time Support
-     app.get("/api/booking/available-times", isAuthenticated, tenantIsolation, async (req: Request, res: Response, next) => {
-         try {
--            const { restaurantId, date, guests, exactTime } = req.query; // NEW: exactTime param
-             const context = getTenantContext(req);
--            
--            if (parseInt(restaurantId as string) !== context.restaurant.id) {
--                return res.status(403).json({ message: "Access denied to this restaurant" });
--            }
-+            const { date, guests, exactTime } = req.query; // NEW: exactTime param
-+            const restaurantId = context.restaurant.id;           
-             
-             if (!restaurantId || !date || !guests) {
-                 return res.status(400).json({ message: "Missing required parameters" });
-@@ -1467,9 +1542,15 @@ export async function registerRoutes(app: Express): Promise<Server> {
-         }
-     });
- 
--    // ✅ CRITICAL SECURITY FIX: Reservation creation with authenticated tenant ID
-+    // ============================================================================
-+    // 🔌 WEBSOCKET INTEGRATION: Modified Reservation Routes
-+    // ============================================================================
-+
-+    // ✅ CRITICAL SECURITY FIX + WEBSOCKET INTEGRATION: Reservation creation
-     app.post("/api/reservations", isAuthenticated, tenantIsolation, trackUsage('reservation_created'), async (req, res, next) => {
-         try {
-+            // 🔌 GET WEBSOCKET SERVER from Express app context
-+            const wss = req.app.get('wss') as ExtendedWebSocketServer;
-             const context = getTenantContext(req);
-             const { guestName, guestPhone, date, time, guests: numGuests } = req.body;
-             
-@@ -1477,12 +1558,13 @@ export async function registerRoutes(app: Express): Promise<Server> {
-                 return res.status(400).json({ message: "Missing required fields: guestName, guestPhone, date, time, guests" });
-             }
-             
--            let guest: Guest | undefined = await storage.getGuestByPhone(guestPhone);
-+            let guest: Guest | undefined = await storage.getGuestByPhone(guestPhone, context.restaurant.id);
-             if (!guest) {
-                 guest = await storage.createGuest({
-                     name: guestName,
-                     phone: guestPhone,
-                     email: req.body.guestEmail || null,
-+                    restaurantId: context.restaurant.id,
-                 });
-             }
-             if (!guest) {
-@@ -1516,8 +1598,9 @@ export async function registerRoutes(app: Express): Promise<Server> {
-             }
- 
-             try {
--                // ✅ CRITICAL SECURITY FIX: Pass authenticated tenant ID first, remove restaurantId from request
-+                // 🔌 WEBSOCKET INTEGRATION: Pass WebSocket server to createReservation
-                 const bookingResult = await createReservation(
-+                    wss, // 🔽 Pass WebSocket server for broadcasting
-                     context.restaurant.id, // ✅ Authenticated tenant ID from middleware
-                     {
-                         // ❌ REMOVED: restaurantId - no longer accepted by booking service
-@@ -1530,6 +1613,7 @@ export async function registerRoutes(app: Express): Promise<Server> {
-                         booking_guest_name: guestName,
-                         lang: req.body.lang || context.restaurant.languages?.[0] || 'en',
-                         tableId: req.body.tableId || undefined,
-+                        tenantContext: context, // Pass full context for limit checking
-                     }
-                 );
- 
-@@ -1576,7 +1660,7 @@ export async function registerRoutes(app: Express): Promise<Server> {
-                     bookingResult.reservation.duration || 120
-                 );
- 
--                console.log(`✅ [Reservation Creation] Success - Reservation ID ${bookingResult.reservation.id} created with UTC-based cache invalidation`);
-+                console.log(`✅ [Reservation Creation] Success - Reservation ID ${bookingResult.reservation.id} created with WebSocket broadcasting`);
- 
-                 return res.status(201).json({
-                     ...bookingResult.reservation,
-@@ -1676,10 +1760,6 @@ export async function registerRoutes(app: Express): Promise<Server> {
-                 existingReservation.duration || 120
-             );
- 
--            // ✅ BUG 3 FIX: REMOVED DEAD CODE BLOCK
--            // The dead code that checked for validatedData.date && validatedData.time has been removed
--            // because the validation schema only supports reservation_utc, not separate date/time fields
--
-             const updatedReservation = await storage.updateReservation(reservationId, validatedData);
- 
-             res.json(updatedReservation);
-@@ -1691,9 +1771,11 @@ export async function registerRoutes(app: Express): Promise<Server> {
-         }
-     });
- 
--    // ✅ CRITICAL SECURITY FIX: Reservation cancellation with authenticated tenant ID
-+    // ✅ CRITICAL SECURITY FIX + WEBSOCKET INTEGRATION: Reservation cancellation
-     app.delete("/api/reservations/:id", isAuthenticated, tenantIsolation, async (req, res, next) => {
-         try {
-+            // 🔌 GET WEBSOCKET SERVER from Express app context
-+            const wss = req.app.get('wss') as ExtendedWebSocketServer;
-             const context = getTenantContext(req);
-             const reservationId = parseInt(req.params.id);
-             const existingResult = await storage.getReservation(reservationId);
-@@ -1704,8 +1786,9 @@ export async function registerRoutes(app: Express): Promise<Server> {
- 
-             const existingReservation = existingResult.reservation;
- 
--            // ✅ CRITICAL SECURITY FIX: Pass authenticated tenant ID first
-+            // 🔌 WEBSOCKET INTEGRATION: Pass WebSocket server to cancelReservation
-             await cancelReservation(
-+                wss, // 🔽 Pass WebSocket server for broadcasting
-                 context.restaurant.id, // ✅ Authenticated tenant ID from middleware
-                 reservationId, 
-                 context.restaurant.languages?.[0] || 'en'
-@@ -1718,18 +1801,24 @@ export async function registerRoutes(app: Express): Promise<Server> {
-                 existingReservation.duration || 120
-             );
- 
-+            console.log(`✅ [Reservation Cancellation] Success - Reservation ID ${reservationId} cancelled with WebSocket broadcasting`);
-+
-             res.json({ success: true, message: "Reservation canceled successfully." });
- 
-         } catch (error) {
-+            console.error('❌ [Reservation Cancellation] Error:', error);
-             next(error);
-         }
-     });
- 
--    // ✅ NEW: PHASE 3 - ENHANCED RESERVATION STATUS MANAGEMENT
--    
--    // Seat guests - transition from confirmed to seated
-+    // ============================================================================
-+    // 🔌 WEBSOCKET INTEGRATION: Reservation Status Management with Broadcasting
-+    // ============================================================================
-+
-+    // Seat guests - transition from confirmed to seated + WebSocket broadcast
-     app.post("/api/reservations/:id/seat", isAuthenticated, tenantIsolation, async (req, res, next) => {
-         try {
-+            const wss = req.app.get('wss') as ExtendedWebSocketServer;
-             const { tableNotes, staffMember } = req.body;
-             const reservationId = parseInt(req.params.id);
-             const context = getTenantContext(req);
-@@ -1766,7 +1855,20 @@ export async function registerRoutes(app: Express): Promise<Server> {
-                 CacheInvalidation.onTableChange(context.restaurant.id);
-             }
- 
--            console.log(`✅ [Reservation Status] Seated guests for reservation ${reservationId} by ${staffMember || 'Unknown staff'}`);
-+            // 🔌 WEBSOCKET: Broadcast reservation status change
-+            wss.broadcastToTenant(context.restaurant.id, {
-+                type: 'RESERVATION_UPDATED',
-+                payload: {
-+                    id: reservationId,
-+                    newStatus: 'seated',
-+                    tableName: reservation.table?.name || 'Unknown Table',
-+                    guestName: reservation.reservation.booking_guest_name || reservation.guest?.name || 'Guest',
-+                    staffMember: staffMember || 'Unknown staff',
-+                    timestamp: new Date().toISOString()
-+                }
-+            });
-+
-+            console.log(`✅ [Reservation Status] Seated guests for reservation ${reservationId} by ${staffMember || 'Unknown staff'} + WebSocket broadcast`);
- 
-             res.json({ 
-                 success: true, 
-@@ -1781,9 +1883,10 @@ export async function registerRoutes(app: Express): Promise<Server> {
-         }
-     });
- 
--    // Complete visit - transition from seated/in_progress to completed
-+    // Complete visit - transition from seated/in_progress to completed + WebSocket broadcast
-     app.post("/api/reservations/:id/complete", isAuthenticated, tenantIsolation, async (req, res, next) => {
-         try {
-+            const wss = req.app.get('wss') as ExtendedWebSocketServer;
-             const { feedback, totalAmount, staffMember } = req.body;
-             const reservationId = parseInt(req.params.id);
-             const context = getTenantContext(req);
-@@ -1825,7 +1928,7 @@ export async function registerRoutes(app: Express): Promise<Server> {
-                 visitCompleted: true,
-                 duration,
-                 totalSpent: totalAmount ? parseFloat(totalAmount) : 0
--            });
-+            }, context.restaurant.id);
- 
-             // Free up table
-             if (reservation.reservation.tableId) {
-@@ -1837,7 +1940,22 @@ export async function registerRoutes(app: Express): Promise<Server> {
-                 CacheInvalidation.onTableChange(context.restaurant.id);
-             }
- 
--            console.log(`✅ [Reservation Status] Completed visit for reservation ${reservationId}, duration: ${duration}min, amount: $${totalAmount || 0}`);
-+            // 🔌 WEBSOCKET: Broadcast reservation completion
-+            wss.broadcastToTenant(context.restaurant.id, {
-+                type: 'RESERVATION_UPDATED',
-+                payload: {
-+                    id: reservationId,
-+                    newStatus: 'completed',
-+                    tableName: reservation.table?.name || 'Unknown Table',
-+                    guestName: reservation.reservation.booking_guest_name || reservation.guest?.name || 'Guest',
-+                    duration,
-+                    totalAmount: totalAmount ? parseFloat(totalAmount) : null,
-+                    staffMember: staffMember || 'Unknown staff',
-+                    timestamp: new Date().toISOString()
-+                }
-+            });
-+
-+            console.log(`✅ [Reservation Status] Completed visit for reservation ${reservationId}, duration: ${duration}min, amount: $${totalAmount || 0} + WebSocket broadcast`);
- 
-             res.json({ 
-                 success: true, 
-@@ -1854,9 +1972,10 @@ export async function registerRoutes(app: Express): Promise<Server> {
-         }
-     });
- 
--    // Mark as no-show
-+    // Mark as no-show + WebSocket broadcast
-     app.post("/api/reservations/:id/no-show", isAuthenticated, tenantIsolation, async (req, res, next) => {
-         try {
-+            const wss = req.app.get('wss') as ExtendedWebSocketServer;
-             const { reason, staffMember } = req.body;
-             const reservationId = parseInt(req.params.id);
-             const context = getTenantContext(req);
-@@ -1887,7 +2006,7 @@ export async function registerRoutes(app: Express): Promise<Server> {
-             // Update guest analytics (negative impact)
-             await storage.updateGuestAnalytics(reservation.reservation.guestId, {
-                 noShowOccurred: true
--            });
-+            }, context.restaurant.id);
- 
-             // Free up table
-             if (reservation.reservation.tableId) {
-@@ -1899,7 +2018,21 @@ export async function registerRoutes(app: Express): Promise<Server> {
-                 CacheInvalidation.onTableChange(context.restaurant.id);
-             }
- 
--            console.log(`⚠️ [Reservation Status] Marked reservation ${reservationId} as no-show: ${reason || 'No reason provided'}`);
-+            // 🔌 WEBSOCKET: Broadcast no-show status
-+            wss.broadcastToTenant(context.restaurant.id, {
-+                type: 'RESERVATION_UPDATED',
-+                payload: {
-+                    id: reservationId,
-+                    newStatus: 'no_show',
-+                    tableName: reservation.table?.name || 'Unknown Table',
-+                    guestName: reservation.reservation.booking_guest_name || reservation.guest?.name || 'Guest',
-+                    reason: reason || 'No reason provided',
-+                    staffMember: staffMember || 'Unknown staff',
-+                    timestamp: new Date().toISOString()
-+                }
-+            });
-+
-+            console.log(`⚠️ [Reservation Status] Marked reservation ${reservationId} as no-show: ${reason || 'No reason provided'} + WebSocket broadcast`);
- 
-             res.json({ 
-                 success: true, 
-@@ -1950,7 +2083,9 @@ export async function registerRoutes(app: Express): Promise<Server> {
-         }
-     });
- 
--    // ✅ NEW: PHASE 3 - MENU MANAGEMENT SYSTEM with feature gate
-+    // ============================================================================
-+    // ✅ MENU MANAGEMENT SYSTEM with feature gate (No WebSocket needed - configuration)
-+    // ============================================================================
- 
-     // Get menu items with advanced filtering
-     app.get("/api/menu-items", isAuthenticated, tenantIsolation, requireMenuManagement, async (req, res, next) => {
-@@ -1972,7 +2107,7 @@ export async function registerRoutes(app: Express): Promise<Server> {
-             
-             // Group by category for better UI organization
-             const groupedItems = menuItems.reduce((acc, item) => {
--                const cat = item.category || 'other';
-+                const cat = item.categoryName || 'other';
-                 if (!acc[cat]) acc[cat] = [];
-                 acc[cat].push(item);
-                 return acc;
-@@ -2380,7 +2515,6 @@ export async function registerRoutes(app: Express): Promise<Server> {
- 
-             console.log(`[API] Created Sofia chat session ${sessionId} for restaurant ${context.restaurant.id} with greeting in ${context.restaurant.languages?.[0] || 'en'}`);
- 
--
-             // ✅ Get restaurant greeting based on restaurant language/country
-             let restaurantGreeting: string;
-             try {
-diff --git a/server/services/booking.ts b/server/services/booking.ts
-index 62d31ef..1f294c6 100644
---- a/server/services/booking.ts
-+++ b/server/services/booking.ts
-@@ -2,6 +2,7 @@
- // ✅ CRITICAL SECURITY FIX: All functions now receive authenticated tenant ID
- // ❌ NEVER trust client-provided restaurantId - always use server-validated tenant ID
- // 🔧 BUG-20250725-001 FIX: Correctly pass authenticatedTenantId to storage.getGuest to fix tenant isolation bug.
-+// 🔌 WEBSOCKET INTEGRATION: Real-time broadcasting for reservation events
- 
- import { storage } from '../storage';
- import {
-@@ -9,6 +10,9 @@ import {
-     type AvailabilitySlot as ServiceAvailabilitySlot,
- } from './availability.service';
- 
-+// 🔌 WEBSOCKET IMPORTS: Add WebSocket types for broadcasting
-+import { ExtendedWebSocketServer } from '../types/websocket.js';
-+
- import type {
-     Restaurant,
-     Reservation as SchemaReservation,
-@@ -167,8 +171,9 @@ function detectConflictType(error: any): 'AVAILABILITY' | 'TRANSACTION' | 'DEADL
-     return 'AVAILABILITY'; // Default fallback
- }
- 
--// ✅ CRITICAL SECURITY FIX: Function now receives authenticated tenant ID
-+// ✅ CRITICAL SECURITY FIX + 🔌 WEBSOCKET INTEGRATION: Function now receives authenticated tenant ID and WebSocket server
- export async function createReservation(
-+    wss: ExtendedWebSocketServer, // 🔌 WebSocket server for real-time broadcasting
-     authenticatedTenantId: number, // ✅ From middleware - NEVER trust client
-     bookingRequest: BookingRequest
- ): Promise<BookingResponse> {
-@@ -373,6 +378,25 @@ export async function createReservation(
-                 allCreatedReservationIds.push(primaryReservation.id);
-                 logger.info(`✅ Single Reservation ID ${primaryReservation.id} created for Table ${selectedSlot.tableName} with UTC timestamp.`);
- 
-+                // 🔌 WEBSOCKET BROADCAST: Notify all connected clients about new reservation
-+                try {
-+                    wss.broadcastToTenant(authenticatedTenantId, {
-+                        type: 'RESERVATION_CREATED',
-+                        payload: {
-+                            ...primaryReservation,
-+                            guestName: nameForConfirmationMessage,
-+                            tableName: selectedSlot.tableName,
-+                            formattedTime: formatTimeForRestaurant(displayTime, restaurantTimezone, bookingRequest.lang || 'en'),
-+                            restaurantName: restaurant.name,
-+                            isCombined: false
-+                        }
-+                    });
-+                    logger.info(`📢 [WebSocket] Broadcasted RESERVATION_CREATED for reservation ${primaryReservation.id} to tenant ${authenticatedTenantId}`);
-+                } catch (wsError) {
-+                    logger.error(`❌ [WebSocket] Failed to broadcast RESERVATION_CREATED:`, wsError);
-+                    // Don't fail the reservation for WebSocket errors
-+                }
-+
-                 const tableDetails = await storage.getTable(selectedSlot.tableId) as Table;
- 
-                 return {
-@@ -521,6 +545,26 @@ export async function createReservation(
-                     }
-                 }
- 
-+                // 🔌 WEBSOCKET BROADCAST: Notify all connected clients about new combined reservation
-+                try {
-+                    wss.broadcastToTenant(authenticatedTenantId, {
-+                        type: 'RESERVATION_CREATED',
-+                        payload: {
-+                            ...primaryReservation,
-+                            guestName: nameForConfirmationMessage,
-+                            tableName: selectedSlot.tableName,
-+                            isCombined: true,
-+                            tablesInvolved: selectedSlot.constituentTables?.map(t => t.name).join(', '),
-+                            formattedTime: formatTimeForRestaurant(displayTime, restaurantTimezone, bookingRequest.lang || 'en'),
-+                            restaurantName: restaurant.name
-+                        }
-+                    });
-+                    logger.info(`📢 [WebSocket] Broadcasted RESERVATION_CREATED for combined reservation ${primaryReservation.id} to tenant ${authenticatedTenantId}`);
-+                } catch (wsError) {
-+                    logger.error(`❌ [WebSocket] Failed to broadcast RESERVATION_CREATED:`, wsError);
-+                    // Don't fail the reservation for WebSocket errors
-+                }
-+
-                 return {
-                     success: true,
-                     reservation: primaryReservation,
-@@ -582,8 +626,9 @@ export async function createReservation(
-     }
- }
- 
--// ✅ CRITICAL SECURITY FIX: Ensure user can only cancel their own restaurant's reservations
-+// ✅ CRITICAL SECURITY FIX + 🔌 WEBSOCKET INTEGRATION: Ensure user can only cancel their own restaurant's reservations
- export async function cancelReservation(
-+    wss: ExtendedWebSocketServer, // 🔌 WebSocket server for real-time broadcasting
-     authenticatedTenantId: number, // ✅ From middleware
-     reservationId: number,
-     lang?: Language
-@@ -618,6 +663,9 @@ export async function cancelReservation(
-             return { success: false, message: locale.reservationAlreadyCancelled(reservationId) };
-         }
- 
-+        // Store guest name for WebSocket broadcast before cancellation
-+        const guestName = reservation.booking_guest_name || reservationResult.guest?.name || 'Guest';
-+
-         // Get restaurant for timezone context
-         const restaurant = await storage.getRestaurant(reservation.restaurantId);
-         const restaurantTimezone = restaurant?.timezone || 'Europe/Moscow';
-@@ -655,6 +703,26 @@ export async function cancelReservation(
-             logger.info(`Cancelled a linked part of a combined booking (Res ID: ${reservationId}).`);
-         }
- 
-+        // 🔌 WEBSOCKET BROADCAST: Notify all connected clients about reservation cancellation
-+        try {
-+            wss.broadcastToTenant(authenticatedTenantId, {
-+                type: 'RESERVATION_CANCELED',
-+                payload: {
-+                    id: reservationId,
-+                    restaurantId: authenticatedTenantId,
-+                    status: 'canceled',
-+                    guestName: guestName,
-+                    tableName: reservationResult.table?.name || 'Unknown Table',
-+                    isCombined: isCombinedPrimary,
-+                    timestamp: new Date().toISOString()
-+                }
-+            });
-+            logger.info(`📢 [WebSocket] Broadcasted RESERVATION_CANCELED for reservation ${reservationId} to tenant ${authenticatedTenantId}`);
-+        } catch (wsError) {
-+            logger.error(`❌ [WebSocket] Failed to broadcast RESERVATION_CANCELED:`, wsError);
-+            // Don't fail the cancellation for WebSocket errors
-+        }
-+
-         logger.info(`✅ Reservation ID ${reservationId} cancelled successfully (timezone: ${restaurantTimezone}).`);
-         return { success: true, message: locale.reservationCancelledSuccessfully };
- 
-@@ -728,4 +796,4 @@ export async function findAlternativeSlots(
-         logger.error('Error in findAlternativeSlots (secure wrapper):', error);
-         return [];
-     }
--}
-+}
-\ No newline at end of file
diff --git a/client/src/App.tsx b/client/src/App.tsx
index b794be8..446f13c 100644
--- a/client/src/App.tsx
+++ b/client/src/App.tsx
@@ -18,6 +18,7 @@ import AISettings from "@/pages/ai-settings";
 import Preferences from "@/pages/preferences";
 import Integrations from "@/pages/integrations";
 import Login from "@/pages/auth/login";
+import MenuPage from "@/pages/menu"; // ✨ IMPORT THE NEW MENU PAGE
 
 // 🔒 SUPER ADMIN: Import admin components
 import AdminLogin from "@/pages/auth/admin-login";
@@ -382,6 +383,13 @@ function Router() {
                 </ProtectedRoute>
             </Route>
 
+            {/* ✨ ADDED MENU ROUTE */}
+            <Route path="/menu">
+                <ProtectedRoute>
+                    <MenuPage />
+                </ProtectedRoute>
+            </Route>
+
             <Route path="/analytics">
                 <ProtectedRoute>
                     <Analytics />
@@ -453,4 +461,4 @@ function App() {
     );
 }
 
-export default App;
\ No newline at end of file
+export default App;
diff --git a/client/src/components/layout/Sidebar.tsx b/client/src/components/layout/Sidebar.tsx
index bcd30e3..808a77d 100644
--- a/client/src/components/layout/Sidebar.tsx
+++ b/client/src/components/layout/Sidebar.tsx
@@ -1,264 +1,168 @@
-import { useState } from "react";
-import { Link, useLocation } from "wouter";
-import { 
-  LayoutDashboard, 
-  CalendarDays, 
-  Utensils, 
-  Users, 
-  BarChart3,
-  Store, 
-  Bot, 
-  Settings, 
-  Puzzle,
-  Menu
-} from "lucide-react";
-import { Button } from "@/components/ui/button";
-import { cn } from "@/lib/utils";
-
-// 🔌 WEBSOCKET INTEGRATION: Import compact WebSocket status component
-import { WebSocketStatusCompact } from '@/components/websocket/WebSocketStatus';
-
-interface NavItemProps {
-  href: string;
-  icon: React.ReactNode;
-  children: React.ReactNode;
-  active?: boolean;
-}
-
-const NavItem = ({ href, icon, children, active }: NavItemProps) => (
-  <Link href={href}>
-    <div 
-      className={cn(
-        "flex items-center px-6 py-3 text-gray-700 hover:bg-gray-50 cursor-pointer",
-        active && "bg-blue-50 border-r-4 border-blue-500"
-      )}
-    >
-      <div className={cn("w-5", active ? "text-blue-500" : "text-gray-400")}>
-        {icon}
-      </div>
-      <span className="mx-3">{children}</span>
-    </div>
-  </Link>
-);
-
-export function Sidebar() {
-  const [location] = useLocation();
-  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);
-
-  return (
-    <>
-      {/* Desktop Sidebar */}
-      <aside className="hidden lg:flex flex-col w-64 bg-white border-r border-gray-200">
-        <div className="px-6 py-4 border-b border-gray-200">
-          <div className="flex items-center justify-between">
-            <div>
-              <h1 className="text-2xl font-semibold text-gray-800">ToBeOut</h1>
-              <p className="text-sm text-gray-500">Restaurant Management</p>
-            </div>
-            {/* 🔌 WEBSOCKET INTEGRATION: Add compact status indicator */}
-            <WebSocketStatusCompact />
-          </div>
-        </div>
-
-        <nav className="flex-1 pt-4 pb-4 overflow-y-auto">
-          <div className="px-4 mb-2">
-            <h2 className="text-xs uppercase tracking-wider text-gray-500 font-semibold">Main</h2>
-          </div>
-          <NavItem href="/dashboard" icon={<LayoutDashboard size={18} />} active={location === "/dashboard"}>
-            Dashboard
-          </NavItem>
-          <NavItem href="/reservations" icon={<CalendarDays size={18} />} active={location === "/reservations"}>
-            Reservations
-          </NavItem>
-          <NavItem href="/tables" icon={<Utensils size={18} />} active={location === "/tables"}>
-            Tables
-          </NavItem>
-          <NavItem href="/guests" icon={<Users size={18} />} active={location === "/guests"}>
-            Guests
-          </NavItem>
-          <NavItem href="/analytics" icon={<BarChart3 size={18} />} active={location === "/analytics"}>
-            Analytics
-          </NavItem>
-
-          <div className="px-4 mt-6 mb-2">
-            <h2 className="text-xs uppercase tracking-wider text-gray-500 font-semibold">Settings</h2>
-          </div>
-          <NavItem href="/profile" icon={<Store size={18} />} active={location === "/profile"}>
-            Restaurant Profile
-          </NavItem>
-          <NavItem href="/ai-settings" icon={<Bot size={18} />} active={location === "/ai-settings"}>
-            AI Assistant
-          </NavItem>
-          <NavItem href="/preferences" icon={<Settings size={18} />} active={location === "/preferences"}>
-            Preferences
-          </NavItem>
-          <NavItem href="/integrations" icon={<Puzzle size={18} />} active={location === "/integrations"}>
-            Integrations
-          </NavItem>
-        </nav>
-
-        <div className="border-t border-gray-200 p-4">
-          <div className="flex items-center">
-            {/* This will use actual user data from the authentication context */}
-            <div className="h-10 w-10 rounded-full bg-blue-100 flex items-center justify-center text-blue-500">
-              <Users size={18} />
-            </div>
-            <div className="ml-3">
-              <p className="text-sm font-medium text-gray-700">Restaurant Admin</p>
-              <p className="text-xs text-gray-500">Restaurant Name</p>
-            </div>
-          </div>
-        </div>
-      </aside>
-
-      {/* Mobile Header */}
-      <div className="lg:hidden fixed top-0 left-0 right-0 z-20 bg-white border-b border-gray-200">
-        <div className="flex items-center justify-between p-4">
-          <div className="flex items-center gap-3">
-            <h1 className="text-xl font-semibold text-gray-800">ToBeOut</h1>
-            {/* 🔌 WEBSOCKET INTEGRATION: Add compact status for mobile header */}
-            <WebSocketStatusCompact />
-          </div>
-          <Button 
-            variant="ghost" 
-            size="icon" 
-            onClick={() => setIsMobileMenuOpen(true)}
-            className="text-gray-500 hover:text-gray-600"
-          >
-            <Menu size={24} />
-          </Button>
-        </div>
-      </div>
-
-      {/* Mobile Navigation Menu */}
-      {isMobileMenuOpen && (
-        <div className="lg:hidden fixed inset-0 z-30 bg-black bg-opacity-50">
-          <div className="absolute right-0 top-0 bottom-0 w-64 bg-white">
-            <div className="p-4 border-b border-gray-200 flex justify-between items-center">
-              <div className="flex items-center gap-2">
-                <h2 className="text-lg font-semibold">Menu</h2>
-                {/* 🔌 WEBSOCKET INTEGRATION: Add status to mobile menu header */}
-                <WebSocketStatusCompact />
-              </div>
-              <Button 
-                variant="ghost" 
-                size="icon" 
-                onClick={() => setIsMobileMenuOpen(false)}
-                className="text-gray-500"
-              >
-                <span className="sr-only">Close</span>
-                <span aria-hidden="true">&times;</span>
-              </Button>
-            </div>
-            <nav className="p-4">
-              <Link href="/dashboard">
-                <a 
-                  className={cn(
-                    "block py-2 px-4 rounded mb-1",
-                    location === "/dashboard" 
-                      ? "text-blue-500 bg-blue-50" 
-                      : "text-gray-700 hover:bg-gray-50"
-                  )}
-                  onClick={() => setIsMobileMenuOpen(false)}
-                >
-                  Dashboard
-                </a>
-              </Link>
-              <Link href="/reservations">
-                <a 
-                  className={cn(
-                    "block py-2 px-4 rounded mb-1",
-                    location === "/reservations" 
-                      ? "text-blue-500 bg-blue-50" 
-                      : "text-gray-700 hover:bg-gray-50"
-                  )}
-                  onClick={() => setIsMobileMenuOpen(false)}
-                >
-                  Reservations
-                </a>
-              </Link>
-              <Link href="/tables">
-                <a 
-                  className={cn(
-                    "block py-2 px-4 rounded mb-1",
-                    location === "/tables" 
-                      ? "text-blue-500 bg-blue-50" 
-                      : "text-gray-700 hover:bg-gray-50"
-                  )}
-                  onClick={() => setIsMobileMenuOpen(false)}
-                >
-                  Tables
-                </a>
-              </Link>
-              <Link href="/guests">
-                <a 
-                  className={cn(
-                    "block py-2 px-4 rounded mb-1",
-                    location === "/guests" 
-                      ? "text-blue-500 bg-blue-50" 
-                      : "text-gray-700 hover:bg-gray-50"
-                  )}
-                  onClick={() => setIsMobileMenuOpen(false)}
-                >
-                  Guests
-                </a>
-              </Link>
-              <Link href="/profile">
-                <a 
-                  className={cn(
-                    "block py-2 px-4 rounded mb-1",
-                    location === "/profile" 
-                      ? "text-blue-500 bg-blue-50" 
-                      : "text-gray-700 hover:bg-gray-50"
-                  )}
-                  onClick={() => setIsMobileMenuOpen(false)}
-                >
-                  Restaurant Profile
-                </a>
-              </Link>
-              <Link href="/ai-settings">
-                <a 
-                  className={cn(
-                    "block py-2 px-4 rounded mb-1",
-                    location === "/ai-settings" 
-                      ? "text-blue-500 bg-blue-50" 
-                      : "text-gray-700 hover:bg-gray-50"
-                  )}
-                  onClick={() => setIsMobileMenuOpen(false)}
-                >
-                  AI Assistant
-                </a>
-              </Link>
-              <Link href="/preferences">
-                <a 
-                  className={cn(
-                    "block py-2 px-4 rounded mb-1",
-                    location === "/preferences" 
-                      ? "text-blue-500 bg-blue-50" 
-                      : "text-gray-700 hover:bg-gray-50"
-                  )}
-                  onClick={() => setIsMobileMenuOpen(false)}
-                >
-                  Preferences
-                </a>
-              </Link>
-              <Link href="/integrations">
-                <a 
-                  className={cn(
-                    "block py-2 px-4 rounded mb-1",
-                    location === "/integrations" 
-                      ? "text-blue-500 bg-blue-50" 
-                      : "text-gray-700 hover:bg-gray-50"
-                  )}
-                  onClick={() => setIsMobileMenuOpen(false)}
-                >
-                  Integrations
-                </a>
-              </Link>
-            </nav>
-          </div>
-        </div>
-      )}
-    </>
-  );
-}
\ No newline at end of file
+import { useState } from "react";
+import { Link, useLocation } from "wouter";
+import { 
+  LayoutDashboard, 
+  CalendarDays, 
+  Utensils, 
+  Users, 
+  BarChart3,
+  Store, 
+  Bot, 
+  Settings, 
+  Puzzle,
+  Menu as MenuIcon // Aliased to avoid conflict with mobile menu button
+} from "lucide-react";
+import { Button } from "@/components/ui/button";
+import { cn } from "@/lib/utils";
+import { WebSocketStatusCompact } from '@/components/websocket/WebSocketStatus';
+
+interface NavItemProps {
+  href: string;
+  icon: React.ReactNode;
+  children: React.ReactNode;
+  active?: boolean;
+}
+
+const NavItem = ({ href, icon, children, active }: NavItemProps) => (
+  <Link href={href}>
+    <div 
+      className={cn(
+        "flex items-center px-6 py-3 text-gray-700 hover:bg-gray-50 cursor-pointer transition-colors duration-150",
+        active && "bg-blue-50 border-r-4 border-blue-500 font-semibold"
+      )}
+    >
+      <div className={cn("w-5", active ? "text-blue-500" : "text-gray-400")}>
+        {icon}
+      </div>
+      <span className={cn("mx-3", active ? "text-blue-600" : "text-gray-700")}>{children}</span>
+    </div>
+  </Link>
+);
+
+export function Sidebar() {
+  const [location] = useLocation();
+  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);
+
+  const navLinks = [
+    { href: "/dashboard", icon: <LayoutDashboard size={18} />, text: "Dashboard" },
+    { href: "/reservations", icon: <CalendarDays size={18} />, text: "Reservations" },
+    { href: "/tables", icon: <Utensils size={18} />, text: "Tables" },
+    { href: "/menu", icon: <MenuIcon size={18} />, text: "Menu" },
+    { href: "/guests", icon: <Users size={18} />, text: "Guests" },
+    { href: "/analytics", icon: <BarChart3 size={18} />, text: "Analytics" },
+  ];
+
+  const settingsLinks = [
+    { href: "/profile", icon: <Store size={18} />, text: "Restaurant Profile" },
+    { href: "/ai-settings", icon: <Bot size={18} />, text: "AI Assistant" },
+    { href: "/preferences", icon: <Settings size={18} />, text: "Preferences" },
+    { href: "/integrations", icon: <Puzzle size={18} />, text: "Integrations" },
+  ];
+
+  return (
+    <>
+      {/* Desktop Sidebar */}
+      <aside className="hidden lg:flex flex-col w-64 bg-white border-r border-gray-200">
+        <div className="px-6 py-4 border-b border-gray-200">
+          <div className="flex items-center justify-between">
+            <div>
+              <h1 className="text-2xl font-semibold text-gray-800">ToBeOut</h1>
+              <p className="text-sm text-gray-500">Restaurant Management</p>
+            </div>
+            <WebSocketStatusCompact />
+          </div>
+        </div>
+
+        <nav className="flex-1 pt-4 pb-4 overflow-y-auto">
+          <div className="px-4 mb-2">
+            <h2 className="text-xs uppercase tracking-wider text-gray-500 font-semibold">Main</h2>
+          </div>
+          {navLinks.map(link => (
+            <NavItem key={link.href} href={link.href} icon={link.icon} active={location === link.href}>
+              {link.text}
+            </NavItem>
+          ))}
+
+          <div className="px-4 mt-6 mb-2">
+            <h2 className="text-xs uppercase tracking-wider text-gray-500 font-semibold">Settings</h2>
+          </div>
+          {settingsLinks.map(link => (
+            <NavItem key={link.href} href={link.href} icon={link.icon} active={location === link.href}>
+              {link.text}
+            </NavItem>
+          ))}
+        </nav>
+
+        <div className="border-t border-gray-200 p-4">
+          <div className="flex items-center">
+            <div className="h-10 w-10 rounded-full bg-blue-100 flex items-center justify-center text-blue-500">
+              <Users size={18} />
+            </div>
+            <div className="ml-3">
+              <p className="text-sm font-medium text-gray-700">Restaurant Admin</p>
+              <p className="text-xs text-gray-500">Restaurant Name</p>
+            </div>
+          </div>
+        </div>
+      </aside>
+
+      {/* Mobile Header */}
+      <div className="lg:hidden fixed top-0 left-0 right-0 z-20 bg-white border-b border-gray-200">
+        <div className="flex items-center justify-between p-4">
+          <div className="flex items-center gap-3">
+            <h1 className="text-xl font-semibold text-gray-800">ToBeOut</h1>
+            <WebSocketStatusCompact />
+          </div>
+          <Button 
+            variant="ghost" 
+            size="icon" 
+            onClick={() => setIsMobileMenuOpen(true)}
+            className="text-gray-500 hover:text-gray-600"
+          >
+            <MenuIcon size={24} />
+          </Button>
+        </div>
+      </div>
+
+      {/* Mobile Navigation Menu */}
+      {isMobileMenuOpen && (
+        <div className="lg:hidden fixed inset-0 z-30 bg-black bg-opacity-50" onClick={() => setIsMobileMenuOpen(false)}>
+          <div className="absolute right-0 top-0 bottom-0 w-64 bg-white" onClick={e => e.stopPropagation()}>
+            <div className="p-4 border-b border-gray-200 flex justify-between items-center">
+              <div className="flex items-center gap-2">
+                <h2 className="text-lg font-semibold">Menu</h2>
+                <WebSocketStatusCompact />
+              </div>
+              <Button 
+                variant="ghost" 
+                size="icon" 
+                onClick={() => setIsMobileMenuOpen(false)}
+                className="text-gray-500"
+              >
+                <span className="sr-only">Close</span>
+                <span aria-hidden="true" className="text-2xl">&times;</span>
+              </Button>
+            </div>
+            <nav className="p-4">
+              {[...navLinks, ...settingsLinks].map(link => (
+                 <Link key={link.href} href={link.href}>
+                    <a 
+                      className={cn(
+                        "block py-2 px-4 rounded mb-1",
+                        location === link.href 
+                          ? "text-blue-500 bg-blue-50" 
+                          : "text-gray-700 hover:bg-gray-50"
+                      )}
+                      onClick={() => setIsMobileMenuOpen(false)}
+                    >
+                      {link.text}
+                    </a>
+                  </Link>
+              ))}
+            </nav>
+          </div>
+        </div>
+      )}
+    </>
+  );
+}
diff --git a/client/src/pages/analytics.tsx b/client/src/pages/analytics.tsx
index 3abde38..8f8e8d7 100644
--- a/client/src/pages/analytics.tsx
+++ b/client/src/pages/analytics.tsx
@@ -1,429 +1,222 @@
+import { useState } from "react";
 import { useQuery } from "@tanstack/react-query";
-import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
+import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
 import { Badge } from "@/components/ui/badge";
-import { Button } from "@/components/ui/button";
 import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
 import { DashboardLayout, useRestaurantTimezone } from "@/components/layout/DashboardLayout";
+import { apiRequest } from "@/lib/queryClient";
+import { Skeleton } from "@/components/ui/skeleton";
 import {
-    Users,
-    TrendingUp,
-    DollarSign,
-    Calendar,
-    Phone,
-    MessageSquare,
-    Star,
-    Table,
-    Clock,
-    UserCheck,
-    Repeat,
-    Target,
-    BarChart3
+    Users, TrendingUp, DollarSign, Calendar, Phone, MessageSquare, Star, Table, Clock, UserCheck,
+    Repeat, Target, BarChart3, AlertTriangle, ArrowDown, ArrowUp, Minus, Info
 } from "lucide-react";
 import { DateTime } from "luxon";
+import {
+    BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, PieChart, Pie, Cell
+} from 'recharts';
+
+// Define the shape of the analytics data from our new backend endpoint.
+// This matches the AnalyticsOverview interface in storage.ts
+interface AnalyticsOverview {
+    timeframe: {
+        start: string;
+        end: string;
+        timezone: string;
+    };
+    revenue: {
+        totalRevenue: string;
+        avgRevenuePerBooking: string;
+        sources: { source: string; revenue: string; count: number }[];
+    };
+    reservations: {
+        total: number;
+        byStatus: Record<string, number>;
+        funnel: {
+            created: number;
+            confirmed: number;
+            seated: number;
+            completed: number;
+            noShowRate: number;
+            cancellationRate: number;
+        };
+        avgGuests: number;
+        bySource: { source: string; count: number }[];
+    };
+    guests: {
+        total: number;
+        new: number;
+        returning: number;
+        segmentation: {
+            vip: number;
+            regulars: number;
+            atRisk: number;
+        };
+    };
+    tables: {
+        performance: {
+            id: number;
+            name: string;
+            bookingCount: number;
+            revenue: string;
+            avgGuests: number;
+        }[];
+        turnaroundTime: number;
+    };
+    operations: {
+        seatingEfficiency: number;
+        popularTimes: { hour: number; count: number }[];
+    };
+}
 
-// Helper function to parse PostgreSQL timestamp format to Luxon
-const parsePostgresTimestamp = (timestampStr: string): DateTime => {
-  // Handle PostgreSQL format: "2025-06-24 10:00:00+00"
-  if (timestampStr.includes(' ') && !timestampStr.includes('T')) {
-    const isoString = timestampStr.replace(' ', 'T').replace('+00', '.000Z');
-    return DateTime.fromISO(isoString, { zone: 'utc' });
-  }
-  // Handle standard ISO format: "2025-06-24T10:00:00.000Z"
-  return DateTime.fromISO(timestampStr, { zone: 'utc' });
+// A single, efficient API call to fetch all pre-calculated analytics.
+const fetchAnalyticsOverview = async (days: number): Promise<AnalyticsOverview> => {
+    const response = await apiRequest("GET", `/api/analytics/overview?days=${days}`);
+    if (!response.ok) {
+        throw new Error("Failed to fetch analytics overview.");
+    }
+    return response.json();
 };
 
-export default function Analytics() {
-    const { restaurant, restaurantTimezone } = useRestaurantTimezone();
-
-    console.log(`📊 [Analytics] Context - restaurant: ${!!restaurant}, timezone: ${restaurantTimezone}`);
+const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042', '#8884d8'];
 
-    // ✅ FIXED: Simplified reservations query without over-strict conditions
-    const { data: reservations, isLoading: reservationsLoading, error: reservationsError } = useQuery({
-        queryKey: ["/api/reservations"],
-        queryFn: async () => {
-            console.log(`📊 [Analytics] Fetching reservations for analytics`);
-            
-            // ✅ FIXED: Use standard API endpoint without parameters
-            const response = await fetch('/api/reservations', {
-                credentials: "include"
-            });
-            
-            if (!response.ok) {
-                throw new Error(`Failed to fetch reservations: ${response.status}`);
-            }
-            
-            const data = await response.json();
-            console.log(`📊 [Analytics] Received ${data?.length || 0} reservations`);
-            return data || [];
-        },
-        // ✅ FIXED: Remove restaurant dependency - backend handles auth context
-        staleTime: 30000, // 30 seconds
-        retry: 2
-    });
-
-    // ✅ FIXED: Simplified guests query
-    const { data: guests, isLoading: guestsLoading, error: guestsError } = useQuery({
-        queryKey: ["/api/guests"],
-        queryFn: async () => {
-            console.log(`📊 [Analytics] Fetching guests for analytics`);
-            
-            // ✅ FIXED: Use standard API endpoint without parameters
-            const response = await fetch('/api/guests', {
-                credentials: "include"
-            });
-            
-            if (!response.ok) {
-                throw new Error(`Failed to fetch guests: ${response.status}`);
-            }
-            
-            const data = await response.json();
-            console.log(`📊 [Analytics] Received ${data?.length || 0} guests`);
-            return data || [];
-        },
-        // ✅ FIXED: Remove restaurant dependency - backend handles auth context
-        staleTime: 60000, // 1 minute
-        retry: 2
-    });
-
-    // ✅ FIXED: Simplified tables query
-    const { data: tables, isLoading: tablesLoading, error: tablesError } = useQuery({
-        queryKey: ["/api/tables"],
-        queryFn: async () => {
-            console.log(`📊 [Analytics] Fetching tables for analytics`);
-            
-            // ✅ FIXED: Use standard API endpoint without parameters
-            const response = await fetch('/api/tables', { 
-                credentials: "include" 
-            });
-            
-            if (!response.ok) {
-                throw new Error(`Failed to fetch tables: ${response.status}`);
-            }
-            
-            const data = await response.json();
-            console.log(`📊 [Analytics] Received ${data?.length || 0} tables`);
-            return data || [];
-        },
-        // ✅ FIXED: Remove restaurant dependency - backend handles auth context
-        staleTime: 300000, // 5 minutes
-        retry: 2
+export default function Analytics() {
+    const { restaurantTimezone } = useRestaurantTimezone();
+    const [timeframe, setTimeframe] = useState(30);
+
+    // This single, lightweight query replaces all the previous heavy data fetching.
+    const { data: analytics, isLoading, error } = useQuery<AnalyticsOverview>({
+        queryKey: ["analyticsOverview", timeframe],
+        queryFn: () => fetchAnalyticsOverview(timeframe),
+        staleTime: 5 * 60 * 1000, // Cache for 5 minutes
     });
 
-    // ✅ FIXED: Get today's date in restaurant timezone
-    const getRestaurantToday = () => {
-        try {
-            return DateTime.now().setZone(restaurantTimezone || 'UTC').toISODate();
-        } catch (error) {
-            console.warn(`[Analytics] Invalid timezone ${restaurantTimezone}, falling back to UTC`);
-            return DateTime.now().toISODate();
-        }
-    };
-
-    // ✅ FIXED: Check if UTC timestamp is today in restaurant timezone
-    const isToday = (reservation_utc: string) => {
-        try {
-            const restaurantToday = getRestaurantToday();
-            const utcDateTime = parsePostgresTimestamp(reservation_utc);
-            const localDate = utcDateTime.setZone(restaurantTimezone || 'UTC').toISODate();
-            return localDate === restaurantToday;
-        } catch (error) {
-            console.warn(`[Analytics] Error checking if ${reservation_utc} is today:`, error);
-            return false;
-        }
-    };
-
-    // ✅ FIXED: Extract hour from UTC timestamp in restaurant timezone
-    const getHourFromReservation = (reservation_utc: string) => {
-        try {
-            const utcDateTime = parsePostgresTimestamp(reservation_utc);
-            const localDateTime = utcDateTime.setZone(restaurantTimezone || 'UTC');
-            return localDateTime.hour.toString();
-        } catch (error) {
-            console.warn(`[Analytics] Error extracting hour from ${reservation_utc}:`, error);
-            return '12'; // Default fallback
-        }
-    };
-
-    // Loading state
-    if (reservationsLoading || guestsLoading || tablesLoading) {
+    if (isLoading) {
         return (
             <DashboardLayout>
                 <div className="px-4 py-6 lg:px-8">
                     <header className="mb-6">
                         <h2 className="text-2xl font-bold text-gray-800">Analytics Dashboard</h2>
-                        <p className="text-gray-500 mt-1">Loading analytics data...</p>
+                        <p className="text-gray-500 mt-1">Crunching the latest numbers for you...</p>
                     </header>
-                    <div className="flex items-center justify-center h-64">
-                        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
+                    <div className="space-y-6">
+                        <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
+                            <Skeleton className="h-28 w-full" />
+                            <Skeleton className="h-28 w-full" />
+                            <Skeleton className="h-28 w-full" />
+                            <Skeleton className="h-28 w-full" />
+                        </div>
+                        <Skeleton className="h-80 w-full" />
                     </div>
                 </div>
             </DashboardLayout>
         );
     }
 
-    // Error state
-    if (reservationsError || guestsError || tablesError) {
-        console.error('❌ [Analytics] Errors:', { reservationsError, guestsError, tablesError });
-        
+    if (error) {
         return (
             <DashboardLayout>
                 <div className="px-4 py-6 lg:px-8">
                     <header className="mb-6">
                         <h2 className="text-2xl font-bold text-gray-800">Analytics Dashboard</h2>
-                        <p className="text-red-500 mt-1">Error loading analytics data. Please try refreshing the page.</p>
                     </header>
-                    <div className="text-center py-12 text-gray-500">
-                        <BarChart3 className="h-12 w-12 mx-auto mb-4 text-gray-300" />
-                        <p>Unable to load analytics data</p>
-                        <p className="text-sm mt-2">Check your connection and try again</p>
+                    <div className="text-center py-12 text-gray-500 bg-red-50 rounded-lg border border-red-200">
+                        <AlertTriangle className="h-12 w-12 mx-auto mb-4 text-red-400" />
+                        <h3 className="text-lg font-semibold text-red-700">Could not load analytics data</h3>
+                        <p className="text-sm mt-2">Please check your connection and try refreshing the page.</p>
                     </div>
                 </div>
             </DashboardLayout>
         );
     }
 
-    // Safe data processing with defaults
-    const safeReservations = Array.isArray(reservations) ? reservations : [];
-    const safeGuests = Array.isArray(guests) ? guests : [];
-    const safeTables = Array.isArray(tables) ? tables : [];
-
-    // ✅ FIXED: Filter today's reservations using UTC timestamps
-    const todaysReservations = safeReservations.filter((r: any) => {
-        const reservation = r.reservation || r;
-        return reservation.reservation_utc && 
-               isToday(reservation.reservation_utc) && 
-               reservation.status !== 'canceled';
-    });
-
-    console.log(`📊 [Analytics] Today's reservations (${restaurantTimezone || 'UTC'}): ${todaysReservations.length}`);
-
-    // Guest Analytics
-    const totalGuests = safeGuests.length;
-    const telegramGuests = safeGuests.filter((g: any) => g.telegram_user_id).length;
-    const regularGuests = safeGuests.filter((g: any) => {
-        const guestReservations = safeReservations.filter((r: any) => {
-            const reservation = r.reservation || r;
-            return reservation.guestId === g.id || r.guestId === g.id;
-        });
-        return guestReservations.length > 1;
-    }).length;
-
-    // Today's stats
-    const todayStats = {
-        total: todaysReservations.length,
-        confirmed: todaysReservations.filter((r: any) => {
-            const reservation = r.reservation || r;
-            return reservation.status === 'confirmed';
-        }).length,
-        totalGuests: todaysReservations.reduce((sum: number, r: any) => {
-            const reservation = r.reservation || r;
-            return sum + (reservation.guests || 0);
-        }, 0)
-    };
-
-    // Reservation Analytics
-    const totalReservations = safeReservations.length;
-    const confirmedReservations = safeReservations.filter((r: any) => {
-        const reservation = r.reservation || r;
-        return reservation.status === 'confirmed';
-    }).length;
-    const telegramBookings = safeReservations.filter((r: any) => {
-        const reservation = r.reservation || r;
-        return reservation.source === 'telegram';
-    }).length;
-
-    // Connected guests analysis
-    const connectedGuests = safeGuests.reduce((acc: any, guest: any) => {
-        const guestReservations = safeReservations.filter((r: any) => {
-            const reservation = r.reservation || r;
-            return reservation.guestId === guest.id || r.guestId === guest.id;
-        });
-
-        if (guest.telegram_user_id) {
-            const telegramGroup = acc.find((g: any) => g.telegram_user_id === guest.telegram_user_id);
-            if (telegramGroup) {
-                telegramGroup.guests.push({ ...guest, reservationCount: guestReservations.length });
-            } else {
-                acc.push({
-                    telegram_user_id: guest.telegram_user_id,
-                    guests: [{ ...guest, reservationCount: guestReservations.length }],
-                    totalBookings: guestReservations.length
-                });
-            }
-        }
-        return acc;
-    }, []);
-
-    // ✅ FIXED: Table usage analysis with UTC timestamps
-    const tableUsage = safeTables.map((table: any) => {
-        const tableReservations = safeReservations.filter((r: any) => {
-            const reservation = r.reservation || r;
-            return reservation.tableId === table.id || r.tableId === table.id;
-        });
-        
-        const uniqueGuests = new Set(tableReservations.map((r: any) => {
-            const reservation = r.reservation || r;
-            return reservation.guestId || r.guestId;
-        })).size;
-        
-        const popularTimes = tableReservations.reduce((acc: any, r: any) => {
-            const reservation = r.reservation || r;
-            if (reservation.reservation_utc) {
-                const hour = getHourFromReservation(reservation.reservation_utc);
-                acc[hour] = (acc[hour] || 0) + 1;
-            }
-            return acc;
-        }, {});
-        
-        return {
-            ...table,
-            bookings: tableReservations.length,
-            uniqueGuests,
-            popularTimes
-        };
-    });
-
-    // ✅ FIXED: Party size statistics
-    const partySizeStats = safeReservations.reduce((acc: any, r: any) => {
-        const reservation = r.reservation || r;
-        const guests = reservation.guests || r.guests;
-        if (guests) {
-            acc[guests] = (acc[guests] || 0) + 1;
-        }
-        return acc;
-    }, {});
+    if (!analytics) {
+        return (
+            <DashboardLayout>
+                <div className="px-4 py-6 lg:px-8">
+                    <header className="mb-6">
+                        <h2 className="text-2xl font-bold text-gray-800">Analytics Dashboard</h2>
+                        <p className="text-gray-500 mt-1">No analytics data available yet. Check back after some reservations have been made.</p>
+                    </header>
+                </div>
+            </DashboardLayout>
+        )
+    }
 
-    // Average party size
-    const avgPartySize = totalReservations ? 
-        (safeReservations.reduce((sum: number, r: any) => {
-            const reservation = r.reservation || r;
-            return sum + (reservation.guests || r.guests || 0);
-        }, 0) / totalReservations).toFixed(1) : '0';
+    const { revenue, reservations, guests, tables, operations } = analytics;
+    const funnelData = [
+        { name: 'Confirmed', value: reservations.funnel.confirmed },
+        { name: 'Seated', value: reservations.funnel.seated },
+        { name: 'Completed', value: reservations.funnel.completed },
+    ];
 
     return (
         <DashboardLayout>
             <div className="px-4 py-6 lg:px-8">
-                <header className="mb-6">
-                    <h2 className="text-2xl font-bold text-gray-800">Analytics Dashboard</h2>
-                    <p className="text-gray-500 mt-1">
-                        Deep insights into your guest behavior and restaurant performance
-                        {restaurantTimezone && (
-                            <span className="ml-2 text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded">
-                                {restaurantTimezone} • Today: {getRestaurantToday()}
-                            </span>
-                        )}
-                    </p>
+                <header className="mb-6 flex flex-col md:flex-row md:items-center md:justify-between">
+                    <div>
+                        <h2 className="text-2xl font-bold text-gray-800">Analytics Dashboard</h2>
+                        <p className="text-gray-500 mt-1">
+                            Insights for the last {timeframe} days in <span className="font-semibold">{restaurantTimezone}</span>
+                        </p>
+                    </div>
+                    <Tabs value={String(timeframe)} onValueChange={(val) => setTimeframe(Number(val))} className="mt-4 md:mt-0">
+                        <TabsList>
+                            <TabsTrigger value="7">7 Days</TabsTrigger>
+                            <TabsTrigger value="30">30 Days</TabsTrigger>
+                            <TabsTrigger value="90">90 Days</TabsTrigger>
+                        </TabsList>
+                    </Tabs>
                 </header>
 
                 <Tabs defaultValue="overview" className="space-y-6">
-                    <TabsList className="grid w-full grid-cols-4">
+                    <TabsList className="grid w-full grid-cols-2 md:grid-cols-4">
                         <TabsTrigger value="overview">Overview</TabsTrigger>
+                        <TabsTrigger value="revenue">Revenue</TabsTrigger>
                         <TabsTrigger value="guests">Guest Insights</TabsTrigger>
-                        <TabsTrigger value="connections">Guest Connections</TabsTrigger>
-                        <TabsTrigger value="tables">Table Analytics</TabsTrigger>
+                        <TabsTrigger value="operations">Operations</TabsTrigger>
                     </TabsList>
 
                     <TabsContent value="overview" className="space-y-6">
-                        <div className="mb-6">
-                            <h3 className="text-lg font-semibold mb-4 text-gray-800">Today's Performance</h3>
-                            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
-                                <Card className="bg-blue-50 border-blue-200">
-                                    <CardHeader className="pb-2">
-                                        <CardTitle className="text-sm font-medium text-blue-800">Today's Reservations</CardTitle>
-                                    </CardHeader>
-                                    <CardContent>
-                                        <div className="text-2xl font-bold text-blue-900">{todayStats.total}</div>
-                                        <p className="text-xs text-blue-600">{todayStats.confirmed} confirmed</p>
-                                    </CardContent>
-                                </Card>
-                                <Card className="bg-green-50 border-green-200">
-                                    <CardHeader className="pb-2">
-                                        <CardTitle className="text-sm font-medium text-green-800">Today's Guests</CardTitle>
-                                    </CardHeader>
-                                    <CardContent>
-                                        <div className="text-2xl font-bold text-green-900">{todayStats.totalGuests}</div>
-                                        <p className="text-xs text-green-600">expected to dine</p>
-                                    </CardContent>
-                                </Card>
-                                <Card className="bg-purple-50 border-purple-200">
-                                    <CardHeader className="pb-2">
-                                        <CardTitle className="text-sm font-medium text-purple-800">Avg Party Today</CardTitle>
-                                    </CardHeader>
-                                    <CardContent>
-                                        <div className="text-2xl font-bold text-purple-900">
-                                            {todayStats.total ? (todayStats.totalGuests / todayStats.total).toFixed(1) : '0'}
-                                        </div>
-                                        <p className="text-xs text-purple-600">guests per reservation</p>
-                                    </CardContent>
-                                </Card>
-                            </div>
-                        </div>
-
                         <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
-                            <Card>
-                                <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
-                                    <CardTitle className="text-sm font-medium">Total Guests</CardTitle>
-                                    <Users className="h-4 w-4 text-muted-foreground" />
-                                </CardHeader>
-                                <CardContent>
-                                    <div className="text-2xl font-bold">{totalGuests}</div>
-                                    <p className="text-xs text-muted-foreground">
-                                        {regularGuests} repeat customers
-                                    </p>
-                                </CardContent>
-                            </Card>
-
-                            <Card>
-                                <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
-                                    <CardTitle className="text-sm font-medium">Total Reservations</CardTitle>
-                                    <Calendar className="h-4 w-4 text-muted-foreground" />
-                                </CardHeader>
-                                <CardContent>
-                                    <div className="text-2xl font-bold">{totalReservations}</div>
-                                    <p className="text-xs text-muted-foreground">
-                                        {confirmedReservations} confirmed
-                                    </p>
-                                </CardContent>
-                            </Card>
-
-                            <Card>
-                                <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
-                                    <CardTitle className="text-sm font-medium">Telegram Bookings</CardTitle>
-                                    <MessageSquare className="h-4 w-4 text-muted-foreground" />
-                                </CardHeader>
-                                <CardContent>
-                                    <div className="text-2xl font-bold">{telegramBookings}</div>
-                                    <p className="text-xs text-muted-foreground">
-                                        {telegramGuests} unique Telegram users
-                                    </p>
-                                </CardContent>
-                            </Card>
-
-                            <Card>
-                                <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
-                                    <CardTitle className="text-sm font-medium">Avg Party Size</CardTitle>
-                                    <Users className="h-4 w-4 text-muted-foreground" />
-                                </CardHeader>
-                                <CardContent>
-                                    <div className="text-2xl font-bold">{avgPartySize}</div>
-                                    <p className="text-xs text-muted-foreground">guests per reservation</p>
-                                </CardContent>
-                            </Card>
+                            <Card><CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2"><CardTitle className="text-sm font-medium">Total Revenue</CardTitle><DollarSign className="h-4 w-4 text-muted-foreground" /></CardHeader><CardContent><div className="text-2xl font-bold">${revenue.totalRevenue}</div><p className="text-xs text-muted-foreground">from {reservations.funnel.completed} completed bookings</p></CardContent></Card>
+                            <Card><CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2"><CardTitle className="text-sm font-medium">Total Reservations</CardTitle><Calendar className="h-4 w-4 text-muted-foreground" /></CardHeader><CardContent><div className="text-2xl font-bold">{reservations.total}</div><p className="text-xs text-muted-foreground">{reservations.funnel.confirmed} confirmed</p></CardContent></Card>
+                            <Card><CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2"><CardTitle className="text-sm font-medium">Total Guests</CardTitle><Users className="h-4 w-4 text-muted-foreground" /></CardHeader><CardContent><div className="text-2xl font-bold">{guests.total}</div><p className="text-xs text-muted-foreground">{guests.new} new guests</p></CardContent></Card>
+                            <Card><CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2"><CardTitle className="text-sm font-medium">No-Show Rate</CardTitle><AlertTriangle className="h-4 w-4 text-muted-foreground" /></CardHeader><CardContent><div className="text-2xl font-bold">{reservations.funnel.noShowRate.toFixed(1)}%</div><p className="text-xs text-muted-foreground">{reservations.byStatus.no_show || 0} no-shows</p></CardContent></Card>
                         </div>
 
                         <Card>
                             <CardHeader>
-                                <CardTitle className="flex items-center">
-                                    <BarChart3 className="h-5 w-5 mr-2" />
-                                    Party Size Distribution
-                                </CardTitle>
+                                <CardTitle>Reservation Funnel</CardTitle>
+                                <CardDescription>From confirmed booking to completed visit.</CardDescription>
                             </CardHeader>
+                            <CardContent className="h-[300px]">
+                                <ResponsiveContainer width="100%" height="100%">
+                                    <BarChart data={funnelData} layout="vertical">
+                                        <CartesianGrid strokeDasharray="3 3" />
+                                        <XAxis type="number" />
+                                        <YAxis type="category" dataKey="name" width={80} />
+                                        <Tooltip />
+                                        <Bar dataKey="value" fill="#8884d8" />
+                                    </BarChart>
+                                </ResponsiveContainer>
+                            </CardContent>
+                        </Card>
+                    </TabsContent>
+
+                    <TabsContent value="revenue" className="space-y-6">
+                        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
+                            <Card><CardHeader><CardTitle>Total Revenue</CardTitle></CardHeader><CardContent><p className="text-3xl font-bold">${revenue.totalRevenue}</p></CardContent></Card>
+                            <Card><CardHeader><CardTitle>Avg. Revenue per Booking</CardTitle></CardHeader><CardContent><p className="text-3xl font-bold">${revenue.avgRevenuePerBooking}</p></CardContent></Card>
+                            <Card><CardHeader><CardTitle>Avg. Party Size</CardTitle></CardHeader><CardContent><p className="text-3xl font-bold">{reservations.avgGuests.toFixed(1)}</p></CardContent></Card>
+                        </div>
+                        <Card>
+                            <CardHeader><CardTitle>Top Performing Tables by Revenue</CardTitle></CardHeader>
                             <CardContent>
-                                <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4">
-                                    {Object.entries(partySizeStats).map(([size, count]) => (
-                                        <div key={size} className="text-center p-4 bg-gray-50 rounded-lg">
-                                            <div className="text-2xl font-bold text-blue-600">{count as number}</div>
-                                            <div className="text-sm text-gray-500">{size} {size === '1' ? 'guest' : 'guests'}</div>
+                                <div className="space-y-3">
+                                    {tables.performance.sort((a, b) => parseFloat(b.revenue) - parseFloat(a.revenue)).slice(0, 5).map(table => (
+                                        <div key={table.id} className="flex items-center justify-between p-2 bg-gray-50 rounded-lg">
+                                            <p className="font-medium">Table {table.name}</p>
+                                            <Badge variant="secondary">${parseFloat(table.revenue).toFixed(2)} from {table.bookingCount} bookings</Badge>
                                         </div>
                                     ))}
                                 </div>
@@ -432,206 +225,58 @@ export default function Analytics() {
                     </TabsContent>
 
                     <TabsContent value="guests" className="space-y-6">
-                        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
-                            <Card>
-                                <CardHeader>
-                                    <CardTitle className="flex items-center">
-                                        <Star className="h-5 w-5 mr-2" />
-                                        Most Loyal Guests
-                                    </CardTitle>
-                                </CardHeader>
-                                <CardContent>
-                                    <div className="space-y-3">
-                                        {safeGuests.map((guest: any) => {
-                                            const guestReservations = safeReservations.filter((r: any) => {
-                                                const reservation = r.reservation || r;
-                                                return reservation.guestId === guest.id || r.guestId === guest.id;
-                                            });
-                                            if (guestReservations.length === 0) return null;
-
-                                            return (
-                                                <div key={guest.id} className="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
-                                                    <div className="flex items-center">
-                                                        <div className="w-8 h-8 bg-blue-100 rounded-full flex items-center justify-center mr-3">
-                                                            <UserCheck className="h-4 w-4 text-blue-600" />
-                                                        </div>
-                                                        <div>
-                                                            <div className="font-medium">{guest.name}</div>
-                                                            <div className="text-sm text-gray-500">{guest.phone || 'No phone'}</div>
-                                                        </div>
-                                                    </div>
-                                                    <div className="text-right">
-                                                        <Badge variant="secondary">{guestReservations.length} bookings</Badge>
-                                                        {guest.telegram_user_id && (
-                                                            <div className="text-xs text-blue-600 mt-1">via Telegram</div>
-                                                        )}
-                                                    </div>
-                                                </div>
-                                            );
-                                        }).filter(Boolean)}
-                                    </div>
-                                </CardContent>
-                            </Card>
-
-                            <Card>
-                                <CardHeader>
-                                    <CardTitle className="flex items-center">
-                                        <Phone className="h-5 w-5 mr-2" />
-                                        Booking Channels
-                                    </CardTitle>
-                                </CardHeader>
-                                <CardContent>
-                                    <div className="space-y-4">
-                                        {['direct', 'telegram', 'web'].map((source) => {
-                                            const sourceBookings = safeReservations.filter((r: any) => {
-                                                const reservation = r.reservation || r;
-                                                return (reservation.source || r.source) === source;
-                                            }).length;
-                                            const percentage = totalReservations ? ((sourceBookings / totalReservations) * 100).toFixed(1) : 0;
-
-                                            return (
-                                                <div key={source} className="flex items-center justify-between">
-                                                    <div className="flex items-center">
-                                                        <div className="w-3 h-3 bg-blue-600 rounded-full mr-3"></div>
-                                                        <span className="capitalize font-medium">{source}</span>
-                                                    </div>
-                                                    <div className="text-right">
-                                                        <div className="font-bold">{sourceBookings}</div>
-                                                        <div className="text-sm text-gray-500">{percentage}%</div>
-                                                    </div>
-                                                </div>
-                                            );
-                                        })}
-                                    </div>
-                                </CardContent>
-                            </Card>
+                        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
+                            <Card><CardHeader><CardTitle>Total Unique Guests</CardTitle></CardHeader><CardContent><p className="text-3xl font-bold">{guests.total}</p></CardContent></Card>
+                            <Card><CardHeader><CardTitle>New Guests</CardTitle></CardHeader><CardContent><p className="text-3xl font-bold">{guests.new}</p></CardContent></Card>
+                            <Card><CardHeader><CardTitle>Returning Guests</CardTitle></CardHeader><CardContent><p className="text-3xl font-bold">{guests.returning}</p></CardContent></Card>
                         </div>
-                    </TabsContent>
-
-                    <TabsContent value="connections" className="space-y-6">
                         <Card>
-                            <CardHeader>
-                                <CardTitle className="flex items-center">
-                                    <Repeat className="h-5 w-5 mr-2" />
-                                    Connected Guest Groups
-                                </CardTitle>
-                                <CardContent>
-                                    <p className="text-sm text-gray-500 mb-4">
-                                        Guests linked through shared Telegram accounts or phone numbers
-                                    </p>
-                                </CardContent>
-                            </CardHeader>
-                            <CardContent>
-                                <div className="space-y-4">
-                                    {connectedGuests.length > 0 ? (
-                                        connectedGuests.map((group: any, index: number) => (
-                                            <div key={index} className="p-4 border rounded-lg bg-gray-50">
-                                                <div className="flex items-center justify-between mb-3">
-                                                    <div className="flex items-center">
-                                                        <MessageSquare className="h-4 w-4 text-blue-600 mr-2" />
-                                                        <span className="font-medium">Telegram Group {index + 1}</span>
-                                                    </div>
-                                                    <Badge variant="outline">{group.totalBookings} total bookings</Badge>
-                                                </div>
-                                                <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
-                                                    {group.guests.map((guest: any) => (
-                                                        <div key={guest.id} className="flex items-center justify-between p-2 bg-white rounded">
-                                                            <div>
-                                                                <div className="font-medium">{guest.name}</div>
-                                                                <div className="text-sm text-gray-500">{guest.phone || 'No phone'}</div>
-                                                            </div>
-                                                            <Badge variant="secondary">{guest.reservationCount} bookings</Badge>
-                                                        </div>
-                                                    ))}
-                                                </div>
-                                            </div>
-                                        ))
-                                    ) : (
-                                        <div className="text-center py-8 text-gray-500">
-                                            <Users className="h-12 w-12 mx-auto mb-4 text-gray-300" />
-                                            <p>No connected guest groups found yet</p>
-                                            <p className="text-sm">Connected groups will appear when multiple guests use the same contact methods</p>
-                                        </div>
-                                    )}
-                                </div>
+                            <CardHeader><CardTitle>Guest Segmentation</CardTitle></CardHeader>
+                            <CardContent className="h-[300px]">
+                                <ResponsiveContainer width="100%" height="100%">
+                                    <PieChart>
+                                        <Pie data={[
+                                            { name: 'VIP', value: guests.segmentation.vip },
+                                            { name: 'Regulars', value: guests.segmentation.regulars },
+                                            { name: 'At Risk', value: guests.segmentation.atRisk },
+                                            { name: 'Standard', value: guests.total - guests.segmentation.vip - guests.segmentation.regulars - guests.segmentation.atRisk }
+                                        ]}
+                                            dataKey="value" nameKey="name" cx="50%" cy="50%" outerRadius={100} label>
+                                            {[{ name: 'VIP', value: guests.segmentation.vip }].map((entry, index) => (
+                                                <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
+                                            ))}
+                                        </Pie>
+                                        <Tooltip />
+                                        <Legend />
+                                    </PieChart>
+                                </ResponsiveContainer>
                             </CardContent>
                         </Card>
                     </TabsContent>
 
-                    <TabsContent value="tables" className="space-y-6">
-                        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
-                            <Card>
-                                <CardHeader>
-                                    <CardTitle className="flex items-center">
-                                        <Table className="h-5 w-5 mr-2" />
-                                        Table Performance
-                                    </CardTitle>
-                                </CardHeader>
-                                <CardContent>
-                                    <div className="space-y-3">
-                                        {tableUsage.map((table: any) => (
-                                            <div key={table.id} className="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
-                                                <div>
-                                                    <div className="font-medium">Table {table.name}</div>
-                                                    <div className="text-sm text-gray-500">
-                                                        {table.minGuests}-{table.maxGuests} guests
-                                                    </div>
-                                                </div>
-                                                <div className="text-right">
-                                                    <div className="font-bold">{table.bookings} bookings</div>
-                                                    <div className="text-sm text-gray-500">{table.uniqueGuests} unique guests</div>
-                                                </div>
-                                            </div>
-                                        ))}
-                                    </div>
-                                </CardContent>
-                            </Card>
-
-                            <Card>
-                                <CardHeader>
-                                    <CardTitle className="flex items-center">
-                                        <Clock className="h-5 w-5 mr-2" />
-                                        Popular Time Slots
-                                    </CardTitle>
-                                </CardHeader>
-                                <CardContent>
-                                    <div className="space-y-3">
-                                        {(() => {
-                                            // ✅ FIXED: Calculate time slots using UTC timestamps
-                                            const timeSlots = safeReservations.reduce((acc: any, r: any) => {
-                                                const reservation = r.reservation || r;
-                                                if (reservation.reservation_utc) {
-                                                    const hour = getHourFromReservation(reservation.reservation_utc);
-                                                    acc[hour] = (acc[hour] || 0) + 1;
-                                                }
-                                                return acc;
-                                            }, {});
-
-                                            return Object.entries(timeSlots)
-                                                .sort(([, a], [, b]) => (b as number) - (a as number))
-                                                .slice(0, 8)
-                                                .map(([hour, count]) => (
-                                                    <div key={hour} className="flex items-center justify-between">
-                                                        <span className="font-medium">{hour}:00</span>
-                                                        <div className="flex items-center">
-                                                            <div className="w-20 bg-gray-200 rounded-full h-2 mr-3">
-                                                                <div
-                                                                    className="bg-blue-600 h-2 rounded-full"
-                                                                    style={{ width: `${((count as number) / Math.max(...Object.values(timeSlots) as number[])) * 100}%` }}
-                                                                ></div>
-                                                            </div>
-                                                            <Badge variant="outline">{count as number}</Badge>
-                                                        </div>
-                                                    </div>
-                                                ));
-                                        })()}
-                                    </div>
-                                </CardContent>
-                            </Card>
+                    <TabsContent value="operations" className="space-y-6">
+                        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
+                            <Card><CardHeader><CardTitle>Avg. Table Turnaround</CardTitle><CardDescription>Time from seated to completed</CardDescription></CardHeader><CardContent><p className="text-3xl font-bold">{tables.turnaroundTime} min</p></CardContent></Card>
+                            <Card><CardHeader><CardTitle>Avg. Seating Efficiency</CardTitle><CardDescription>Time from confirmed to seated</CardDescription></CardHeader><CardContent><p className="text-3xl font-bold">{operations.seatingEfficiency} min</p></CardContent></Card>
+                            <Card><CardHeader><CardTitle>Cancellation Rate</CardTitle><CardDescription>Bookings cancelled by guest or staff</CardDescription></CardHeader><CardContent><p className="text-3xl font-bold">{reservations.funnel.cancellationRate.toFixed(1)}%</p></CardContent></Card>
                         </div>
+                        <Card>
+                            <CardHeader><CardTitle>Popular Booking Times</CardTitle></CardHeader>
+                            <CardContent className="h-[300px]">
+                                <ResponsiveContainer width="100%" height="100%">
+                                    <BarChart data={operations.popularTimes}>
+                                        <CartesianGrid strokeDasharray="3 3" />
+                                        <XAxis dataKey="hour" tickFormatter={(hour) => `${hour}:00`} />
+                                        <YAxis />
+                                        <Tooltip />
+                                        <Bar dataKey="count" fill="#82ca9d" name="Bookings" />
+                                    </BarChart>
+                                </ResponsiveContainer>
+                            </CardContent>
+                        </Card>
                     </TabsContent>
                 </Tabs>
             </div>
         </DashboardLayout>
     );
-}
\ No newline at end of file
+}
diff --git a/client/src/pages/guests.tsx b/client/src/pages/guests.tsx
index 7a8429e..056969f 100644
--- a/client/src/pages/guests.tsx
+++ b/client/src/pages/guests.tsx
@@ -17,828 +17,835 @@ import { useForm } from "react-hook-form";
 import { zodResolver } from "@hookform/resolvers/zod";
 import { z } from "zod";
 import { DateTime } from "luxon";
-import { Search, Plus, Edit, Trash2, Download, CalendarDays, User, Phone, Tag, Users } from "lucide-react";
+import { Search, Plus, Edit, Trash2, Download, CalendarDays, User, Phone, Tag, Users, Eye } from "lucide-react";
+
+// ✅ NEW: Import the GuestAnalyticsDrawer component created
+import { GuestAnalyticsDrawer } from "@/components/guests/GuestAnalyticsDrawer";
 
 const guestFormSchema = z.object({
-  name: z.string().min(1, "Guest name is required"),
-  phone: z.string().min(1, "Phone number is required"),
-  email: z.string().email("Invalid email").optional().or(z.literal("")),
-  language: z.string().default("en"),
-  birthday: z.string().optional().or(z.literal("")),
-  tags: z.string().optional(),
-  comments: z.string().optional(),
+    name: z.string().min(1, "Guest name is required"),
+    phone: z.string().min(1, "Phone number is required"),
+    email: z.string().email("Invalid email").optional().or(z.literal("")),
+    language: z.string().default("en"),
+    birthday: z.string().optional().or(z.literal("")),
+    tags: z.string().optional(),
+    comments: z.string().optional(),
 });
 
 type GuestFormValues = z.infer<typeof guestFormSchema>;
 
 export default function Guests() {
-  const [searchQuery, setSearchQuery] = useState("");
-  const [isGuestModalOpen, setIsGuestModalOpen] = useState(false);
-  const [selectedGuestId, setSelectedGuestId] = useState<number | undefined>(undefined);
-  const [deleteConfirmOpen, setDeleteConfirmOpen] = useState(false);
-  const [guestToDelete, setGuestToDelete] = useState<number | undefined>(undefined);
-  
-  const { toast } = useToast();
-  const queryClient = useQueryClient();
-  const { restaurant, restaurantTimezone } = useRestaurantTimezone();
-
-  console.log(`👥 [Guests] Context - restaurant: ${!!restaurant}, timezone: ${restaurantTimezone}`);
-
-  const form = useForm<GuestFormValues>({
-    resolver: zodResolver(guestFormSchema),
-    defaultValues: {
-      name: "",
-      phone: "",
-      email: "",
-      language: "en",
-      birthday: "",
-      tags: "",
-      comments: "",
-    },
-  });
-
-  // ✅ FIXED: Simplified guests query without over-strict conditions
-  const { data: guests, isLoading: guestsLoading, error: guestsError } = useQuery({
-    queryKey: ["/api/guests"],
-    queryFn: async () => {
-      console.log(`👥 [Guests] Fetching guests for restaurant`);
-      
-      // ✅ FIXED: Use standard API endpoint without parameters
-      const response = await fetch('/api/guests', {
-        credentials: "include"
-      });
-      
-      if (!response.ok) {
-        throw new Error(`Failed to fetch guests: ${response.status}`);
-      }
-      
-      const data = await response.json();
-      console.log(`👥 [Guests] Received ${data?.length || 0} guests`);
-      return data || [];
-    },
-    // ✅ FIXED: Remove restaurant dependency - backend handles auth context
-    staleTime: 60000, // 1 minute - guest data doesn't change frequently
-    retry: 2
-  });
-
-  // ✅ FIXED: Simplified reservations query for guest statistics
-  const { data: reservations } = useQuery({
-    queryKey: ["/api/reservations"],
-    queryFn: async () => {
-      console.log(`👥 [Guests] Fetching reservations for guest statistics`);
-      
-      // ✅ FIXED: Use standard API endpoint without parameters
-      const response = await fetch('/api/reservations', {
-        credentials: "include"
-      });
-      
-      if (!response.ok) {
-        throw new Error(`Failed to fetch reservations: ${response.status}`);
-      }
-      
-      const data = await response.json();
-      console.log(`👥 [Guests] Received ${data?.length || 0} reservations for statistics`);
-      return data || [];
-    },
-    // ✅ FIXED: Remove restaurant dependency - backend handles auth context
-    staleTime: 30000, // 30 seconds
-    retry: 2
-  });
-
-  const createGuestMutation = useMutation({
-    mutationFn: async (values: GuestFormValues) => {
-      console.log(`👥 [Guests] Creating guest`);
-      
-      // Convert tags from comma-separated string to array if provided
-      const tagsArray = values.tags ? values.tags.split(',').map(t => t.trim()) : undefined;
-      
-      const response = await apiRequest("POST", "/api/guests", {
-        name: values.name,
-        phone: values.phone,
-        email: values.email || undefined,
-        language: values.language,
-        birthday: values.birthday || undefined,
-        tags: tagsArray,
-        comments: values.comments,
-      });
-      return response.json();
-    },
-    onSuccess: (data) => {
-      console.log(`✅ [Guests] Successfully created guest:`, data);
-      
-      toast({
-        title: "Success",
-        description: "Guest created successfully",
-      });
-      
-      // ✅ FIXED: Simplified cache invalidation
-      queryClient.invalidateQueries({ queryKey: ['/api/guests'] });
-      queryClient.invalidateQueries({ queryKey: ['/api/reservations'] });
-      
-      setIsGuestModalOpen(false);
-      form.reset();
-    },
-    onError: (error: any) => {
-      console.error(`❌ [Guests] Error creating guest:`, error);
-      
-      toast({
-        title: "Error",
-        description: `Failed to create guest: ${error.message}`,
-        variant: "destructive",
-      });
-    }
-  });
-
-  const updateGuestMutation = useMutation({
-    mutationFn: async ({ id, values }: { id: number; values: GuestFormValues }) => {
-      console.log(`👥 [Guests] Updating guest ${id}`);
-      
-      // Convert tags from comma-separated string to array if provided
-      const tagsArray = values.tags ? values.tags.split(',').map(t => t.trim()) : undefined;
-      
-      const response = await apiRequest("PATCH", `/api/guests/${id}`, {
-        name: values.name,
-        phone: values.phone,
-        email: values.email || undefined,
-        language: values.language,
-        birthday: values.birthday || undefined,
-        tags: tagsArray,
-        comments: values.comments,
-      });
-      return response.json();
-    },
-    onSuccess: (data) => {
-      console.log(`✅ [Guests] Successfully updated guest:`, data);
-      
-      toast({
-        title: "Success",
-        description: "Guest updated successfully",
-      });
-      
-      // ✅ FIXED: Simplified cache invalidation
-      queryClient.invalidateQueries({ queryKey: ['/api/guests'] });
-      queryClient.invalidateQueries({ queryKey: ['/api/reservations'] });
-      
-      setIsGuestModalOpen(false);
-      form.reset();
-    },
-    onError: (error: any) => {
-      console.error(`❌ [Guests] Error updating guest:`, error);
-      
-      toast({
-        title: "Error",
-        description: `Failed to update guest: ${error.message}`,
-        variant: "destructive",
-      });
-    }
-  });
-
-  const deleteGuestMutation = useMutation({
-    mutationFn: async (id: number) => {
-      console.log(`👥 [Guests] Deleting guest ${id}`);
-      
-      const response = await apiRequest("DELETE", `/api/guests/${id}`, undefined);
-      return response.json();
-    },
-    onSuccess: (data) => {
-      console.log(`✅ [Guests] Successfully deleted guest:`, data);
-      
-      toast({
-        title: "Success",
-        description: "Guest deleted successfully",
-      });
-      
-      // ✅ FIXED: Simplified cache invalidation
-      queryClient.invalidateQueries({ queryKey: ['/api/guests'] });
-      queryClient.invalidateQueries({ queryKey: ['/api/reservations'] });
-      
-      setDeleteConfirmOpen(false);
-    },
-    onError: (error: any) => {
-      console.error(`❌ [Guests] Error deleting guest:`, error);
-      
-      toast({
-        title: "Error",
-        description: `Failed to delete guest: ${error.message}`,
-        variant: "destructive",
-      });
-    }
-  });
+    const [searchQuery, setSearchQuery] = useState("");
+    const [isGuestModalOpen, setIsGuestModalOpen] = useState(false);
+    const [selectedGuestId, setSelectedGuestId] = useState<number | undefined>(undefined);
+    const [deleteConfirmOpen, setDeleteConfirmOpen] = useState(false);
+    const [guestToDelete, setGuestToDelete] = useState<number | undefined>(undefined);
+
+    // ✅ NEW: State to manage the selected guest for the analytics drawer
+    const [selectedGuestForAnalytics, setSelectedGuestForAnalytics] = useState<any | null>(null);
+
+    const { toast } = useToast();
+    const queryClient = useQueryClient();
+    const { restaurant, restaurantTimezone } = useRestaurantTimezone();
+
+    console.log(`👥 [Guests] Context - restaurant: ${!!restaurant}, timezone: ${restaurantTimezone}`);
+
+    const form = useForm<GuestFormValues>({
+        resolver: zodResolver(guestFormSchema),
+        defaultValues: {
+            name: "",
+            phone: "",
+            email: "",
+            language: "en",
+            birthday: "",
+            tags: "",
+            comments: "",
+        },
+    });
 
-  const onSubmit = (values: GuestFormValues) => {
-    if (selectedGuestId) {
-      updateGuestMutation.mutate({ id: selectedGuestId, values });
-    } else {
-      createGuestMutation.mutate(values);
-    }
-  };
-
-  const handleAddGuest = () => {
-    setSelectedGuestId(undefined);
-    form.reset({
-      name: "",
-      phone: "",
-      email: "",
-      language: "en",
-      birthday: "",
-      tags: "",
-      comments: "",
+    const { data: guests, isLoading: guestsLoading, error: guestsError } = useQuery({
+        queryKey: ["/api/guests"],
+        queryFn: async () => {
+            console.log(`👥 [Guests] Fetching guests for restaurant`);
+
+            const response = await fetch('/api/guests', {
+                credentials: "include"
+            });
+
+            if (!response.ok) {
+                throw new Error(`Failed to fetch guests: ${response.status}`);
+            }
+
+            const data = await response.json();
+            console.log(`👥 [Guests] Received ${data?.length || 0} guests`);
+            return data || [];
+        },
+        staleTime: 60000,
+        retry: 2
     });
-    setIsGuestModalOpen(true);
-  };
-
-  const handleEditGuest = (guest: any) => {
-    setSelectedGuestId(guest.id);
-    form.reset({
-      name: guest.name,
-      phone: guest.phone,
-      email: guest.email || '',
-      language: guest.language || 'en',
-      birthday: guest.birthday || '',
-      tags: guest.tags ? guest.tags.join(', ') : '',
-      comments: guest.comments || '',
+
+    const { data: reservations } = useQuery({
+        queryKey: ["/api/reservations"],
+        queryFn: async () => {
+            console.log(`👥 [Guests] Fetching reservations for guest statistics`);
+
+            const response = await fetch('/api/reservations', {
+                credentials: "include"
+            });
+
+            if (!response.ok) {
+                throw new Error(`Failed to fetch reservations: ${response.status}`);
+            }
+
+            const data = await response.json();
+            console.log(`👥 [Guests] Received ${data?.length || 0} reservations for statistics`);
+            return data || [];
+        },
+        staleTime: 30000,
+        retry: 2
     });
-    setIsGuestModalOpen(true);
-  };
 
-  const handleDeleteGuest = (id: number) => {
-    setGuestToDelete(id);
-    setDeleteConfirmOpen(true);
-  };
+    const createGuestMutation = useMutation({
+        mutationFn: async (values: GuestFormValues) => {
+            console.log(`👥 [Guests] Creating guest`);
+
+            const tagsArray = values.tags ? values.tags.split(',').map(t => t.trim()) : undefined;
+
+            const response = await apiRequest("POST", "/api/guests", {
+                name: values.name,
+                phone: values.phone,
+                email: values.email || undefined,
+                language: values.language,
+                birthday: values.birthday || undefined,
+                tags: tagsArray,
+                comments: values.comments,
+            });
+            return response.json();
+        },
+        onSuccess: (data) => {
+            console.log(`✅ [Guests] Successfully created guest:`, data);
+
+            toast({
+                title: "Success",
+                description: "Guest created successfully",
+            });
+
+            queryClient.invalidateQueries({ queryKey: ['/api/guests'] });
+            queryClient.invalidateQueries({ queryKey: ['/api/reservations'] });
+
+            setIsGuestModalOpen(false);
+            form.reset();
+        },
+        onError: (error: any) => {
+            console.error(`❌ [Guests] Error creating guest:`, error);
+
+            toast({
+                title: "Error",
+                description: `Failed to create guest: ${error.message}`,
+                variant: "destructive",
+            });
+        }
+    });
 
-  const confirmDelete = () => {
-    if (guestToDelete) {
-      deleteGuestMutation.mutate(guestToDelete);
-    }
-  };
-
-  const exportGuests = () => {
-    if (!guests || guests.length === 0) {
-      toast({
-        title: "Error",
-        description: "No guests to export",
-        variant: "destructive",
-      });
-      return;
-    }
+    const updateGuestMutation = useMutation({
+        mutationFn: async ({ id, values }: { id: number; values: GuestFormValues }) => {
+            console.log(`👥 [Guests] Updating guest ${id}`);
+
+            const tagsArray = values.tags ? values.tags.split(',').map(t => t.trim()) : undefined;
+
+            const response = await apiRequest("PATCH", `/api/guests/${id}`, {
+                name: values.name,
+                phone: values.phone,
+                email: values.email || undefined,
+                language: values.language,
+                birthday: values.birthday || undefined,
+                tags: tagsArray,
+                comments: values.comments,
+            });
+            return response.json();
+        },
+        onSuccess: (data) => {
+            console.log(`✅ [Guests] Successfully updated guest:`, data);
+
+            toast({
+                title: "Success",
+                description: "Guest updated successfully",
+            });
+
+            queryClient.invalidateQueries({ queryKey: ['/api/guests'] });
+            queryClient.invalidateQueries({ queryKey: ['/api/reservations'] });
+
+            setIsGuestModalOpen(false);
+            form.reset();
+        },
+        onError: (error: any) => {
+            console.error(`❌ [Guests] Error updating guest:`, error);
+
+            toast({
+                title: "Error",
+                description: `Failed to update guest: ${error.message}`,
+                variant: "destructive",
+            });
+        }
+    });
 
-    // Create CSV content with timezone-aware export filename
-    const headers = ["Name", "Phone", "Email", "Language", "Birthday", "Tags", "Comments", "Booking Count"];
-    const rows = guests.map((guest: any) => [
-      guest.name,
-      guest.phone,
-      guest.email || '',
-      guest.language || 'en',
-      guest.birthday || '',
-      guest.tags ? guest.tags.join(', ') : '',
-      guest.comments || '',
-      guest.reservationCount || 0
-    ]);
-
-    const csvContent = [
-      headers.join(','),
-      ...rows.map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(','))
-    ].join('\n');
-
-    // Create a blob and download it with timezone-aware filename
-    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
-    const url = URL.createObjectURL(blob);
-    const link = document.createElement('a');
-    
-    const exportDate = DateTime.now().setZone(restaurantTimezone || 'UTC').toFormat('yyyy-MM-dd');
-    link.setAttribute('href', url);
-    link.setAttribute('download', `guests_${exportDate}_${restaurantTimezone?.replace('/', '_') || 'UTC'}.csv`);
-    link.style.visibility = 'hidden';
-    document.body.appendChild(link);
-    link.click();
-    document.body.removeChild(link);
-
-    toast({
-      title: "Success",
-      description: `Exported ${guests.length} guests to CSV`,
+    const deleteGuestMutation = useMutation({
+        mutationFn: async (id: number) => {
+            console.log(`👥 [Guests] Deleting guest ${id}`);
+
+            const response = await apiRequest("DELETE", `/api/guests/${id}`, undefined);
+            return response.json();
+        },
+        onSuccess: (data) => {
+            console.log(`✅ [Guests] Successfully deleted guest:`, data);
+
+            toast({
+                title: "Success",
+                description: "Guest deleted successfully",
+            });
+
+            queryClient.invalidateQueries({ queryKey: ['/api/guests'] });
+            queryClient.invalidateQueries({ queryKey: ['/api/reservations'] });
+
+            setDeleteConfirmOpen(false);
+        },
+        onError: (error: any) => {
+            console.error(`❌ [Guests] Error deleting guest:`, error);
+
+            toast({
+                title: "Error",
+                description: `Failed to delete guest: ${error.message}`,
+                variant: "destructive",
+            });
+        }
     });
-  };
 
-  // Enhanced guest statistics with reservation data
-  const getGuestStatistics = () => {
-    if (!guests || !reservations) {
-      return { total: 0, withBirthday: 0, withEmail: 0, withBookings: 0, avgBookings: 0 };
-    }
+    const onSubmit = (values: GuestFormValues) => {
+        if (selectedGuestId) {
+            updateGuestMutation.mutate({ id: selectedGuestId, values });
+        } else {
+            createGuestMutation.mutate(values);
+        }
+    };
 
-    const safeGuests = Array.isArray(guests) ? guests : [];
-    const safeReservations = Array.isArray(reservations) ? reservations : [];
+    const handleAddGuest = () => {
+        setSelectedGuestId(undefined);
+        form.reset({
+            name: "",
+            phone: "",
+            email: "",
+            language: "en",
+            birthday: "",
+            tags: "",
+            comments: "",
+        });
+        setIsGuestModalOpen(true);
+    };
 
-    // Calculate booking counts per guest
-    const guestBookingCounts = safeGuests.map(guest => {
-      const guestReservations = safeReservations.filter((r: any) => {
-        const reservation = r.reservation || r;
-        return reservation.guestId === guest.id || r.guestId === guest.id;
-      });
-      return guestReservations.length;
-    });
+    const handleEditGuest = (guest: any) => {
+        setSelectedGuestId(guest.id);
+        form.reset({
+            name: guest.name,
+            phone: guest.phone,
+            email: guest.email || '',
+            language: guest.language || 'en',
+            birthday: guest.birthday || '',
+            tags: guest.tags ? guest.tags.join(', ') : '',
+            comments: guest.comments || '',
+        });
+        setIsGuestModalOpen(true);
+    };
 
-    const avgBookings = guestBookingCounts.length > 0 
-      ? (guestBookingCounts.reduce((sum, count) => sum + count, 0) / guestBookingCounts.length).toFixed(1)
-      : '0';
+    const handleDeleteGuest = (id: number) => {
+        setGuestToDelete(id);
+        setDeleteConfirmOpen(true);
+    };
 
-    return {
-      total: safeGuests.length,
-      withBirthday: safeGuests.filter((g: any) => g.birthday).length,
-      withEmail: safeGuests.filter((g: any) => g.email).length,
-      withBookings: guestBookingCounts.filter(count => count > 0).length,
-      avgBookings
+    const confirmDelete = () => {
+        if (guestToDelete) {
+            deleteGuestMutation.mutate(guestToDelete);
+        }
     };
-  };
-
-  const filteredGuests = guests ? guests.filter((guest: any) => {
-    if (searchQuery) {
-      const searchLower = searchQuery.toLowerCase();
-      return (
-        guest.name.toLowerCase().includes(searchLower) ||
-        (guest.phone && guest.phone.toLowerCase().includes(searchLower)) ||
-        (guest.email && guest.email.toLowerCase().includes(searchLower))
-      );
-    }
-    return true;
-  }) : [];
-
-  // Enhanced guest data with booking counts
-  const enhancedGuests = filteredGuests.map((guest: any) => {
-    const guestReservations = reservations ? reservations.filter((r: any) => {
-      const reservation = r.reservation || r;
-      return reservation.guestId === guest.id || r.guestId === guest.id;
-    }) : [];
-    
-    return {
-      ...guest,
-      reservationCount: guestReservations.length
+
+    const exportGuests = () => {
+        if (!guests || guests.length === 0) {
+            toast({
+                title: "Error",
+                description: "No guests to export",
+                variant: "destructive",
+            });
+            return;
+        }
+
+        const headers = ["Name", "Phone", "Email", "Language", "Birthday", "Tags", "Comments", "Booking Count"];
+        const rows = guests.map((guest: any) => [
+            guest.name,
+            guest.phone,
+            guest.email || '',
+            guest.language || 'en',
+            guest.birthday || '',
+            guest.tags ? guest.tags.join(', ') : '',
+            guest.comments || '',
+            guest.reservationCount || 0
+        ]);
+
+        const csvContent = [
+            headers.join(','),
+            ...rows.map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(','))
+        ].join('\n');
+
+        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
+        const url = URL.createObjectURL(blob);
+        const link = document.createElement('a');
+
+        const exportDate = DateTime.now().setZone(restaurantTimezone || 'UTC').toFormat('yyyy-MM-dd');
+        link.setAttribute('href', url);
+        link.setAttribute('download', `guests_${exportDate}_${restaurantTimezone?.replace('/', '_') || 'UTC'}.csv`);
+        link.style.visibility = 'hidden';
+        document.body.appendChild(link);
+        link.click();
+        document.body.removeChild(link);
+
+        toast({
+            title: "Success",
+            description: `Exported ${guests.length} guests to CSV`,
+        });
     };
-  });
 
-  const stats = getGuestStatistics();
+    const getGuestStatistics = () => {
+        if (!guests || !reservations) {
+            return { total: 0, withBirthday: 0, withEmail: 0, withBookings: 0, avgBookings: 0 };
+        }
+
+        const safeGuests = Array.isArray(guests) ? guests : [];
+        const safeReservations = Array.isArray(reservations) ? reservations : [];
+
+        const guestBookingCounts = safeGuests.map(guest => {
+            const guestReservations = safeReservations.filter((r: any) => {
+                const reservation = r.reservation || r;
+                return reservation.guestId === guest.id || r.guestId === guest.id;
+            });
+            return guestReservations.length;
+        });
+
+        const avgBookings = guestBookingCounts.length > 0
+            ? (guestBookingCounts.reduce((sum, count) => sum + count, 0) / guestBookingCounts.length).toFixed(1)
+            : '0';
+
+        return {
+            total: safeGuests.length,
+            withBirthday: safeGuests.filter((g: any) => g.birthday).length,
+            withEmail: safeGuests.filter((g: any) => g.email).length,
+            withBookings: guestBookingCounts.filter(count => count > 0).length,
+            avgBookings
+        };
+    };
 
-  // Loading state
-  if (guestsLoading) {
-    return (
-      <DashboardLayout>
-        <div className="px-4 py-6 lg:px-8">
-          <header className="mb-6">
-            <h2 className="text-2xl font-bold text-gray-800">Guest Database</h2>
-            <p className="text-gray-500 mt-1">Loading guest data...</p>
-          </header>
-          <div className="flex items-center justify-center h-64">
-            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
-          </div>
-        </div>
-      </DashboardLayout>
-    );
-  }
+    const filteredGuests = guests ? guests.filter((guest: any) => {
+        if (searchQuery) {
+            const searchLower = searchQuery.toLowerCase();
+            return (
+                guest.name.toLowerCase().includes(searchLower) ||
+                (guest.phone && guest.phone.toLowerCase().includes(searchLower)) ||
+                (guest.email && guest.email.toLowerCase().includes(searchLower))
+            );
+        }
+        return true;
+    }) : [];
+
+    const enhancedGuests = filteredGuests.map((guest: any) => {
+        const guestReservations = reservations ? reservations.filter((r: any) => {
+            const reservation = r.reservation || r;
+            return reservation.guestId === guest.id || r.guestId === guest.id;
+        }) : [];
+
+        return {
+            ...guest,
+            reservationCount: guestReservations.length
+        };
+    });
+
+    const stats = getGuestStatistics();
+
+    if (guestsLoading) {
+        return (
+            <DashboardLayout>
+                <div className="px-4 py-6 lg:px-8">
+                    <header className="mb-6">
+                        <h2 className="text-2xl font-bold text-gray-800">Guest Database</h2>
+                        <p className="text-gray-500 mt-1">Loading guest data...</p>
+                    </header>
+                    <div className="flex items-center justify-center h-64">
+                        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
+                    </div>
+                </div>
+            </DashboardLayout>
+        );
+    }
+
+    if (guestsError) {
+        console.error('❌ [Guests] Error loading guests:', guestsError);
+
+        return (
+            <DashboardLayout>
+                <div className="px-4 py-6 lg:px-8">
+                    <header className="mb-6">
+                        <h2 className="text-2xl font-bold text-gray-800">Guest Database</h2>
+                        <p className="text-red-500 mt-1">Error loading guest data. Please try refreshing the page.</p>
+                    </header>
+                    <div className="text-center py-12 text-gray-500">
+                        <Users className="h-12 w-12 mx-auto mb-4 text-gray-300" />
+                        <p>Unable to load guest data</p>
+                        <p className="text-sm mt-2">Check your connection and try again</p>
+                    </div>
+                </div>
+            </DashboardLayout>
+        );
+    }
 
-  // Error state
-  if (guestsError) {
-    console.error('❌ [Guests] Error loading guests:', guestsError);
-    
     return (
-      <DashboardLayout>
-        <div className="px-4 py-6 lg:px-8">
-          <header className="mb-6">
-            <h2 className="text-2xl font-bold text-gray-800">Guest Database</h2>
-            <p className="text-red-500 mt-1">Error loading guest data. Please try refreshing the page.</p>
-          </header>
-          <div className="text-center py-12 text-gray-500">
-            <Users className="h-12 w-12 mx-auto mb-4 text-gray-300" />
-            <p>Unable to load guest data</p>
-            <p className="text-sm mt-2">Check your connection and try again</p>
-          </div>
-        </div>
-      </DashboardLayout>
-    );
-  }
-
-  return (
-    <DashboardLayout>
-      <div className="px-4 py-6 lg:px-8">
-        <header className="mb-6 flex flex-col md:flex-row md:items-center md:justify-between">
-          <div>
-            <h2 className="text-2xl font-bold text-gray-800">Guest Database</h2>
-            <p className="text-gray-500 mt-1">
-              Manage your restaurant guests and their preferences
-              {restaurantTimezone && (
-                <span className="ml-2 text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded">
-                  {restaurantTimezone}
-                </span>
-              )}
-            </p>
-          </div>
-          <div className="mt-4 md:mt-0 flex flex-wrap gap-2">
-            <Button onClick={handleAddGuest}>
-              <Plus className="mr-2 h-4 w-4" />
-              Add Guest
-            </Button>
-            <Button variant="outline" onClick={exportGuests} disabled={!guests || guests.length === 0}>
-              <Download className="mr-2 h-4 w-4" />
-              Export
-            </Button>
-          </div>
-        </header>
-
-        <Card className="mb-6">
-          <CardHeader className="pb-3">
-            <div className="flex flex-col sm:flex-row sm:items-center justify-between space-y-2 sm:space-y-0">
-              <CardTitle>All Guests ({filteredGuests.length})</CardTitle>
-              <div className="relative w-full sm:w-[300px]">
-                <Search className="absolute left-2.5 top-2.5 h-4 w-4 text-gray-500" />
-                <Input
-                  type="search"
-                  placeholder="Search by name, phone or email..."
-                  className="pl-8 w-full"
-                  value={searchQuery}
-                  onChange={(e) => setSearchQuery(e.target.value)}
-                />
-              </div>
-            </div>
-          </CardHeader>
-          <CardContent>
-            <div className="rounded-md border">
-              <Table>
-                <TableHeader>
-                  <TableRow>
-                    <TableHead>Guest</TableHead>
-                    <TableHead>Contact</TableHead>
-                    <TableHead>Language</TableHead>
-                    <TableHead>Birthday</TableHead>
-                    <TableHead>Tags</TableHead>
-                    <TableHead>Bookings</TableHead>
-                    <TableHead className="text-right">Actions</TableHead>
-                  </TableRow>
-                </TableHeader>
-                <TableBody>
-                  {enhancedGuests.length > 0 ? (
-                    enhancedGuests.map((guest: any) => (
-                      <TableRow key={guest.id}>
-                        <TableCell>
-                          <div className="flex items-center">
-                            <div className="h-10 w-10 rounded-full bg-gray-200 flex items-center justify-center text-gray-700">
-                              <User className="h-5 w-5" />
-                            </div>
-                            <div className="ml-4">
-                              <div className="font-medium">{guest.name}</div>
-                            </div>
-                          </div>
-                        </TableCell>
-                        <TableCell>
-                          <div className="flex flex-col">
-                            <div className="flex items-center text-sm">
-                              <Phone className="h-4 w-4 mr-1" />
-                              {guest.phone || 'No phone'}
-                            </div>
-                            {guest.email && (
-                              <div className="text-sm text-gray-500 mt-1">
-                                {guest.email}
-                              </div>
+        <DashboardLayout>
+            <div className="px-4 py-6 lg:px-8">
+                <header className="mb-6 flex flex-col md:flex-row md:items-center md:justify-between">
+                    <div>
+                        <h2 className="text-2xl font-bold text-gray-800">Guest Database</h2>
+                        <p className="text-gray-500 mt-1">
+                            Manage your restaurant guests and their preferences
+                            {restaurantTimezone && (
+                                <span className="ml-2 text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded">
+                                    {restaurantTimezone}
+                                </span>
                             )}
-                          </div>
-                        </TableCell>
-                        <TableCell>
-                          <Badge variant="outline" className="uppercase">
-                            {guest.language || 'EN'}
-                          </Badge>
-                        </TableCell>
-                        <TableCell>
-                          {guest.birthday ? (
-                            <div className="flex items-center text-sm">
-                              <CalendarDays className="h-4 w-4 mr-1" />
-                              {(() => {
-                                try {
-                                  return DateTime.fromISO(guest.birthday).toFormat('MMM d');
-                                } catch (error) {
-                                  return guest.birthday;
-                                }
-                              })()}
+                        </p>
+                    </div>
+                    <div className="mt-4 md:mt-0 flex flex-wrap gap-2">
+                        <Button onClick={handleAddGuest}>
+                            <Plus className="mr-2 h-4 w-4" />
+                            Add Guest
+                        </Button>
+                        <Button variant="outline" onClick={exportGuests} disabled={!guests || guests.length === 0}>
+                            <Download className="mr-2 h-4 w-4" />
+                            Export
+                        </Button>
+                    </div>
+                </header>
+
+                <Card className="mb-6">
+                    <CardHeader className="pb-3">
+                        <div className="flex flex-col sm:flex-row sm:items-center justify-between space-y-2 sm:space-y-0">
+                            <CardTitle>All Guests ({filteredGuests.length})</CardTitle>
+                            <div className="relative w-full sm:w-[300px]">
+                                <Search className="absolute left-2.5 top-2.5 h-4 w-4 text-gray-500" />
+                                <Input
+                                    type="search"
+                                    placeholder="Search by name, phone or email..."
+                                    className="pl-8 w-full"
+                                    value={searchQuery}
+                                    onChange={(e) => setSearchQuery(e.target.value)}
+                                />
                             </div>
-                          ) : (
-                            <span className="text-gray-400 text-sm">Not set</span>
-                          )}
-                        </TableCell>
-                        <TableCell>
-                          {guest.tags && guest.tags.length > 0 ? (
-                            <div className="flex flex-wrap gap-1">
-                              {guest.tags.map((tag: string, i: number) => (
-                                <Badge key={i} variant="secondary" className="text-xs">
-                                  {tag}
-                                </Badge>
-                              ))}
+                        </div>
+                    </CardHeader>
+                    <CardContent>
+                        <div className="rounded-md border">
+                            <Table>
+                                <TableHeader>
+                                    <TableRow>
+                                        <TableHead>Guest</TableHead>
+                                        <TableHead>Contact</TableHead>
+                                        <TableHead>Language</TableHead>
+                                        <TableHead>Birthday</TableHead>
+                                        <TableHead>Tags</TableHead>
+                                        <TableHead>Bookings</TableHead>
+                                        <TableHead className="text-right">Actions</TableHead>
+                                    </TableRow>
+                                </TableHeader>
+                                <TableBody>
+                                    {enhancedGuests.length > 0 ? (
+                                        enhancedGuests.map((guest: any) => (
+                                            // ✅ REFACTOR: Make the entire row clickable to open the analytics drawer
+                                            <TableRow
+                                                key={guest.id}
+                                                onClick={() => setSelectedGuestForAnalytics(guest)}
+                                                className="cursor-pointer hover:bg-muted/50"
+                                            >
+                                                <TableCell>
+                                                    <div className="flex items-center">
+                                                        <div className="h-10 w-10 rounded-full bg-gray-200 flex items-center justify-center text-gray-700">
+                                                            <User className="h-5 w-5" />
+                                                        </div>
+                                                        <div className="ml-4">
+                                                            <div className="font-medium">{guest.name}</div>
+                                                        </div>
+                                                    </div>
+                                                </TableCell>
+                                                <TableCell>
+                                                    <div className="flex flex-col">
+                                                        <div className="flex items-center text-sm">
+                                                            <Phone className="h-4 w-4 mr-1" />
+                                                            {guest.phone || 'No phone'}
+                                                        </div>
+                                                        {guest.email && (
+                                                            <div className="text-sm text-muted-foreground mt-1">
+                                                                {guest.email}
+                                                            </div>
+                                                        )}
+                                                    </div>
+                                                </TableCell>
+                                                <TableCell>
+                                                    <Badge variant="outline" className="uppercase">
+                                                        {guest.language || 'EN'}
+                                                    </Badge>
+                                                </TableCell>
+                                                <TableCell>
+                                                    {guest.birthday ? (
+                                                        <div className="flex items-center text-sm">
+                                                            <CalendarDays className="h-4 w-4 mr-1" />
+                                                            {(() => {
+                                                                try {
+                                                                    return DateTime.fromISO(guest.birthday).toFormat('MMM d');
+                                                                } catch (error) {
+                                                                    return guest.birthday;
+                                                                }
+                                                            })()}
+                                                        </div>
+                                                    ) : (
+                                                        <span className="text-gray-400 text-sm">Not set</span>
+                                                    )}
+                                                </TableCell>
+                                                <TableCell>
+                                                    {guest.tags && guest.tags.length > 0 ? (
+                                                        <div className="flex flex-wrap gap-1">
+                                                            {guest.tags.map((tag: string, i: number) => (
+                                                                <Badge key={i} variant="secondary" className="text-xs">
+                                                                    {tag}
+                                                                </Badge>
+                                                            ))}
+                                                        </div>
+                                                    ) : (
+                                                        <span className="text-gray-400 text-sm">No tags</span>
+                                                    )}
+                                                </TableCell>
+                                                <TableCell>
+                                                    <Badge variant={guest.reservationCount > 0 ? "default" : "outline"}>
+                                                        {guest.reservationCount || 0}
+                                                    </Badge>
+                                                </TableCell>
+                                                <TableCell className="text-right">
+                                                    {/* ✅ REFACTOR: Add a dedicated "View" button for clarity */}
+                                                    <div className="flex justify-end space-x-1">
+                                                        <Button
+                                                            variant="ghost"
+                                                            size="icon"
+                                                            onClick={(e) => { e.stopPropagation(); setSelectedGuestForAnalytics(guest); }}
+                                                            className="text-gray-600 hover:text-gray-900"
+                                                        >
+                                                            <Eye size={16} />
+                                                        </Button>
+                                                        <Button
+                                                            variant="ghost"
+                                                            size="icon"
+                                                            onClick={(e) => { e.stopPropagation(); handleEditGuest(guest); }}
+                                                            className="text-blue-600 hover:text-blue-900"
+                                                        >
+                                                            <Edit size={16} />
+                                                        </Button>
+                                                        <Button
+                                                            variant="ghost"
+                                                            size="icon"
+                                                            onClick={(e) => { e.stopPropagation(); handleDeleteGuest(guest.id); }}
+                                                            className="text-red-600 hover:text-red-900"
+                                                        >
+                                                            <Trash2 size={16} />
+                                                        </Button>
+                                                    </div>
+                                                </TableCell>
+                                            </TableRow>
+                                        ))
+                                    ) : (
+                                        <TableRow>
+                                            <TableCell colSpan={7} className="text-center py-6 text-gray-500">
+                                                {searchQuery ? "No guests match your search" : "No guests have been added yet"}
+                                            </TableCell>
+                                        </TableRow>
+                                    )}
+                                </TableBody>
+                            </Table>
+                        </div>
+                    </CardContent>
+                </Card>
+
+                <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
+                    <Card>
+                        <CardHeader>
+                            <CardTitle className="flex items-center">
+                                <Tag className="h-5 w-5 mr-2" />
+                                <span>Guest Tags</span>
+                            </CardTitle>
+                        </CardHeader>
+                        <CardContent>
+                            <p className="text-sm text-gray-500 mb-4">
+                                Common guest tags for preferences and special occasions:
+                            </p>
+                            <div className="flex flex-wrap gap-2">
+                                <Badge variant="secondary">VIP</Badge>
+                                <Badge variant="secondary">Regular</Badge>
+                                <Badge variant="secondary">Vegetarian</Badge>
+                                <Badge variant="secondary">Vegan</Badge>
+                                <Badge variant="secondary">Gluten-Free</Badge>
+                                <Badge variant="secondary">Allergies</Badge>
+                                <Badge variant="secondary">Wine Lover</Badge>
+                                <Badge variant="secondary">Birthday</Badge>
+                                <Badge variant="secondary">Anniversary</Badge>
+                                <Badge variant="secondary">Business</Badge>
+                                <Badge variant="secondary">Family</Badge>
                             </div>
-                          ) : (
-                            <span className="text-gray-400 text-sm">No tags</span>
-                          )}
-                        </TableCell>
-                        <TableCell>
-                          <Badge variant={guest.reservationCount > 0 ? "default" : "outline"}>
-                            {guest.reservationCount || 0}
-                          </Badge>
-                        </TableCell>
-                        <TableCell className="text-right">
-                          <div className="flex justify-end space-x-2">
-                            <Button
-                              variant="ghost"
-                              size="icon"
-                              onClick={() => handleEditGuest(guest)}
-                              className="text-blue-600 hover:text-blue-900"
-                            >
-                              <Edit size={16} />
-                            </Button>
-                            <Button
-                              variant="ghost"
-                              size="icon"
-                              onClick={() => handleDeleteGuest(guest.id)}
-                              className="text-red-600 hover:text-red-900"
-                            >
-                              <Trash2 size={16} />
-                            </Button>
-                          </div>
-                        </TableCell>
-                      </TableRow>
-                    ))
-                  ) : (
-                    <TableRow>
-                      <TableCell colSpan={7} className="text-center py-6 text-gray-500">
-                        {searchQuery ? "No guests match your search" : "No guests have been added yet"}
-                      </TableCell>
-                    </TableRow>
-                  )}
-                </TableBody>
-              </Table>
-            </div>
-          </CardContent>
-        </Card>
-
-        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
-          <Card>
-            <CardHeader>
-              <CardTitle className="flex items-center">
-                <Tag className="h-5 w-5 mr-2" />
-                <span>Guest Tags</span>
-              </CardTitle>
-            </CardHeader>
-            <CardContent>
-              <p className="text-sm text-gray-500 mb-4">
-                Common guest tags for preferences and special occasions:
-              </p>
-              <div className="flex flex-wrap gap-2">
-                <Badge variant="secondary">VIP</Badge>
-                <Badge variant="secondary">Regular</Badge>
-                <Badge variant="secondary">Vegetarian</Badge>
-                <Badge variant="secondary">Vegan</Badge>
-                <Badge variant="secondary">Gluten-Free</Badge>
-                <Badge variant="secondary">Allergies</Badge>
-                <Badge variant="secondary">Wine Lover</Badge>
-                <Badge variant="secondary">Birthday</Badge>
-                <Badge variant="secondary">Anniversary</Badge>
-                <Badge variant="secondary">Business</Badge>
-                <Badge variant="secondary">Family</Badge>
-              </div>
-            </CardContent>
-          </Card>
-
-          <Card>
-            <CardHeader>
-              <CardTitle>Guest Statistics</CardTitle>
-            </CardHeader>
-            <CardContent>
-              <div className="space-y-4">
-                <div>
-                  <div className="text-sm font-medium text-gray-500 mb-1">Total Guests</div>
-                  <div className="text-2xl font-bold">{stats.total}</div>
-                </div>
-                
-                <div>
-                  <div className="text-sm font-medium text-gray-500 mb-1">With Bookings</div>
-                  <div className="text-2xl font-bold">{stats.withBookings}</div>
-                </div>
-                
-                <div>
-                  <div className="text-sm font-medium text-gray-500 mb-1">With Birthday Info</div>
-                  <div className="text-2xl font-bold">{stats.withBirthday}</div>
-                </div>
-                
-                <div>
-                  <div className="text-sm font-medium text-gray-500 mb-1">With Email</div>
-                  <div className="text-2xl font-bold">{stats.withEmail}</div>
+                        </CardContent>
+                    </Card>
+
+                    <Card>
+                        <CardHeader>
+                            <CardTitle>Guest Statistics</CardTitle>
+                        </CardHeader>
+                        <CardContent>
+                            <div className="space-y-4">
+                                <div>
+                                    <div className="text-sm font-medium text-gray-500 mb-1">Total Guests</div>
+                                    <div className="text-2xl font-bold">{stats.total}</div>
+                                </div>
+
+                                <div>
+                                    <div className="text-sm font-medium text-gray-500 mb-1">With Bookings</div>
+                                    <div className="text-2xl font-bold">{stats.withBookings}</div>
+                                </div>
+
+                                <div>
+                                    <div className="text-sm font-medium text-gray-500 mb-1">With Birthday Info</div>
+                                    <div className="text-2xl font-bold">{stats.withBirthday}</div>
+                                </div>
+
+                                <div>
+                                    <div className="text-sm font-medium text-gray-500 mb-1">With Email</div>
+                                    <div className="text-2xl font-bold">{stats.withEmail}</div>
+                                </div>
+
+                                <div>
+                                    <div className="text-sm font-medium text-gray-500 mb-1">Avg Bookings</div>
+                                    <div className="text-2xl font-bold">{stats.avgBookings}</div>
+                                </div>
+                            </div>
+                        </CardContent>
+                    </Card>
+
+                    <Card>
+                        <CardHeader>
+                            <CardTitle>Guest Management Tips</CardTitle>
+                        </CardHeader>
+                        <CardContent>
+                            <ul className="space-y-2 text-sm text-gray-500">
+                                <li className="flex items-start">
+                                    <span className="mr-2">•</span>
+                                    <span>Collect birthdays for special offers</span>
+                                </li>
+                                <li className="flex items-start">
+                                    <span className="mr-2">•</span>
+                                    <span>Add tags to track preferences and allergies</span>
+                                </li>
+                                <li className="flex items-start">
+                                    <span className="mr-2">•</span>
+                                    <span>Use language preferences for international guests</span>
+                                </li>
+                                <li className="flex items-start">
+                                    <span className="mr-2">•</span>
+                                    <span>Export guest lists for marketing campaigns</span>
+                                </li>
+                                <li className="flex items-start">
+                                    <span className="mr-2">•</span>
+                                    <span>Add detailed notes about preferences</span>
+                                </li>
+                            </ul>
+                        </CardContent>
+                    </Card>
                 </div>
+            </div>
 
-                <div>
-                  <div className="text-sm font-medium text-gray-500 mb-1">Avg Bookings</div>
-                  <div className="text-2xl font-bold">{stats.avgBookings}</div>
-                </div>
-              </div>
-            </CardContent>
-          </Card>
-
-          <Card>
-            <CardHeader>
-              <CardTitle>Guest Management Tips</CardTitle>
-            </CardHeader>
-            <CardContent>
-              <ul className="space-y-2 text-sm text-gray-500">
-                <li className="flex items-start">
-                  <span className="mr-2">•</span>
-                  <span>Collect birthdays for special offers</span>
-                </li>
-                <li className="flex items-start">
-                  <span className="mr-2">•</span>
-                  <span>Add tags to track preferences and allergies</span>
-                </li>
-                <li className="flex items-start">
-                  <span className="mr-2">•</span>
-                  <span>Use language preferences for international guests</span>
-                </li>
-                <li className="flex items-start">
-                  <span className="mr-2">•</span>
-                  <span>Export guest lists for marketing campaigns</span>
-                </li>
-                <li className="flex items-start">
-                  <span className="mr-2">•</span>
-                  <span>Add detailed notes about preferences</span>
-                </li>
-              </ul>
-            </CardContent>
-          </Card>
-        </div>
-      </div>
-
-      {/* Guest Form Modal */}
-      <Dialog open={isGuestModalOpen} onOpenChange={setIsGuestModalOpen}>
-        <DialogContent className="sm:max-w-md">
-          <DialogHeader>
-            <DialogTitle>{selectedGuestId ? "Edit Guest" : "Add New Guest"}</DialogTitle>
-          </DialogHeader>
-          
-          <Form {...form}>
-            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
-              <FormField
-                control={form.control}
-                name="name"
-                render={({ field }) => (
-                  <FormItem>
-                    <FormLabel>Guest Name</FormLabel>
-                    <FormControl>
-                      <Input placeholder="Full Name" {...field} />
-                    </FormControl>
-                    <FormMessage />
-                  </FormItem>
-                )}
-              />
-              
-              <FormField
-                control={form.control}
-                name="phone"
-                render={({ field }) => (
-                  <FormItem>
-                    <FormLabel>Phone Number</FormLabel>
-                    <FormControl>
-                      <Input placeholder="+1 (555) 123-4567" {...field} />
-                    </FormControl>
-                    <FormMessage />
-                  </FormItem>
-                )}
-              />
-              
-              <FormField
-                control={form.control}
-                name="email"
-                render={({ field }) => (
-                  <FormItem>
-                    <FormLabel>Email (Optional)</FormLabel>
-                    <FormControl>
-                      <Input placeholder="guest@example.com" {...field} />
-                    </FormControl>
-                    <FormMessage />
-                  </FormItem>
-                )}
-              />
-              
-              <div className="grid grid-cols-2 gap-4">
-                <FormField
-                  control={form.control}
-                  name="language"
-                  render={({ field }) => (
-                    <FormItem>
-                      <FormLabel>Language</FormLabel>
-                      <Select 
-                        onValueChange={field.onChange}
-                        defaultValue={field.value}
-                        value={field.value}
-                      >
-                        <FormControl>
-                          <SelectTrigger>
-                            <SelectValue placeholder="Select language" />
-                          </SelectTrigger>
-                        </FormControl>
-                        <SelectContent>
-                          <SelectItem value="en">English</SelectItem>
-                          <SelectItem value="es">Spanish</SelectItem>
-                          <SelectItem value="fr">French</SelectItem>
-                          <SelectItem value="de">German</SelectItem>
-                          <SelectItem value="it">Italian</SelectItem>
-                          <SelectItem value="ru">Russian</SelectItem>
-                          <SelectItem value="zh">Chinese</SelectItem>
-                          <SelectItem value="ja">Japanese</SelectItem>
-                          <SelectItem value="sr">Serbian</SelectItem>
-                          <SelectItem value="hu">Hungarian</SelectItem>
-                        </SelectContent>
-                      </Select>
-                      <FormMessage />
-                    </FormItem>
-                  )}
-                />
-                
-                <FormField
-                  control={form.control}
-                  name="birthday"
-                  render={({ field }) => (
-                    <FormItem>
-                      <FormLabel>Birthday (Optional)</FormLabel>
-                      <FormControl>
-                        <Input type="date" {...field} />
-                      </FormControl>
-                      <FormMessage />
-                    </FormItem>
-                  )}
-                />
-              </div>
-              
-              <FormField
-                control={form.control}
-                name="tags"
-                render={({ field }) => (
-                  <FormItem>
-                    <FormLabel>Tags (Optional)</FormLabel>
-                    <FormControl>
-                      <Input placeholder="VIP, Vegetarian, Regular (comma separated)" {...field} />
-                    </FormControl>
-                    <FormDescription>
-                      Enter tags separated by commas
-                    </FormDescription>
-                    <FormMessage />
-                  </FormItem>
-                )}
-              />
-              
-              <FormField
-                control={form.control}
-                name="comments"
-                render={({ field }) => (
-                  <FormItem>
-                    <FormLabel>Comments (Optional)</FormLabel>
-                    <FormControl>
-                      <Textarea 
-                        placeholder="Special notes or preferences"
-                        className="resize-none"
-                        {...field}
-                      />
-                    </FormControl>
-                    <FormMessage />
-                  </FormItem>
-                )}
-              />
-              
-              <DialogFooter className="mt-6">
-                <Button type="button" variant="outline" onClick={() => setIsGuestModalOpen(false)}>
-                  Cancel
-                </Button>
-                <Button 
-                  type="submit" 
-                  disabled={createGuestMutation.isPending || updateGuestMutation.isPending}
-                >
-                  {createGuestMutation.isPending || updateGuestMutation.isPending ? 
-                    "Saving..." : 
-                    selectedGuestId ? "Update Guest" : "Add Guest"
-                  }
-                </Button>
-              </DialogFooter>
-            </form>
-          </Form>
-        </DialogContent>
-      </Dialog>
-
-      {/* Delete Confirmation Dialog */}
-      <AlertDialog open={deleteConfirmOpen} onOpenChange={setDeleteConfirmOpen}>
-        <AlertDialogContent>
-          <AlertDialogHeader>
-            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
-            <AlertDialogDescription>
-              This will permanently delete the guest and their data. Reservations associated with this guest will be affected. This action cannot be undone.
-            </AlertDialogDescription>
-          </AlertDialogHeader>
-          <AlertDialogFooter>
-            <AlertDialogCancel>Cancel</AlertDialogCancel>
-            <AlertDialogAction onClick={confirmDelete} className="bg-red-600 hover:bg-red-700">
-              {deleteGuestMutation.isPending ? "Deleting..." : "Delete"}
-            </AlertDialogAction>
-          </AlertDialogFooter>
-        </AlertDialogContent>
-      </AlertDialog>
-    </DashboardLayout>
-  );
-}
\ No newline at end of file
+            <Dialog open={isGuestModalOpen} onOpenChange={setIsGuestModalOpen}>
+                <DialogContent className="sm:max-w-md">
+                    <DialogHeader>
+                        <DialogTitle>{selectedGuestId ? "Edit Guest" : "Add New Guest"}</DialogTitle>
+                    </DialogHeader>
+
+                    <Form {...form}>
+                        <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
+                            <FormField
+                                control={form.control}
+                                name="name"
+                                render={({ field }) => (
+                                    <FormItem>
+                                        <FormLabel>Guest Name</FormLabel>
+                                        <FormControl>
+                                            <Input placeholder="Full Name" {...field} />
+                                        </FormControl>
+                                        <FormMessage />
+                                    </FormItem>
+                                )}
+                            />
+
+                            <FormField
+                                control={form.control}
+                                name="phone"
+                                render={({ field }) => (
+                                    <FormItem>
+                                        <FormLabel>Phone Number</FormLabel>
+                                        <FormControl>
+                                            <Input placeholder="+1 (555) 123-4567" {...field} />
+                                        </FormControl>
+                                        <FormMessage />
+                                    </FormItem>
+                                )}
+                            />
+
+                            <FormField
+                                control={form.control}
+                                name="email"
+                                render={({ field }) => (
+                                    <FormItem>
+                                        <FormLabel>Email (Optional)</FormLabel>
+                                        <FormControl>
+                                            <Input placeholder="guest@example.com" {...field} />
+                                        </FormControl>
+                                        <FormMessage />
+                                    </FormItem>
+                                )}
+                            />
+
+                            <div className="grid grid-cols-2 gap-4">
+                                <FormField
+                                    control={form.control}
+                                    name="language"
+                                    render={({ field }) => (
+                                        <FormItem>
+                                            <FormLabel>Language</FormLabel>
+                                            <Select
+                                                onValueChange={field.onChange}
+                                                defaultValue={field.value}
+                                                value={field.value}
+                                            >
+                                                <FormControl>
+                                                    <SelectTrigger>
+                                                        <SelectValue placeholder="Select language" />
+                                                    </SelectTrigger>
+                                                </FormControl>
+                                                <SelectContent>
+                                                    <SelectItem value="en">English</SelectItem>
+                                                    <SelectItem value="es">Spanish</SelectItem>
+                                                    <SelectItem value="fr">French</SelectItem>
+                                                    <SelectItem value="de">German</SelectItem>
+                                                    <SelectItem value="it">Italian</SelectItem>
+                                                    <SelectItem value="ru">Russian</SelectItem>
+                                                    <SelectItem value="zh">Chinese</SelectItem>
+                                                    <SelectItem value="ja">Japanese</SelectItem>
+                                                    <SelectItem value="sr">Serbian</SelectItem>
+                                                    <SelectItem value="hu">Hungarian</SelectItem>
+                                                </SelectContent>
+                                            </Select>
+                                            <FormMessage />
+                                        </FormItem>
+                                    )}
+                                />
+
+                                <FormField
+                                    control={form.control}
+                                    name="birthday"
+                                    render={({ field }) => (
+                                        <FormItem>
+                                            <FormLabel>Birthday (Optional)</FormLabel>
+                                            <FormControl>
+                                                <Input type="date" {...field} />
+                                            </FormControl>
+                                            <FormMessage />
+                                        </FormItem>
+                                    )}
+                                />
+                            </div>
+
+                            <FormField
+                                control={form.control}
+                                name="tags"
+                                render={({ field }) => (
+                                    <FormItem>
+                                        <FormLabel>Tags (Optional)</FormLabel>
+                                        <FormControl>
+                                            <Input placeholder="VIP, Vegetarian, Regular (comma separated)" {...field} />
+                                        </FormControl>
+                                        <FormDescription>
+                                            Enter tags separated by commas
+                                        </FormDescription>
+                                        <FormMessage />
+                                    </FormItem>
+                                )}
+                            />
+
+                            <FormField
+                                control={form.control}
+                                name="comments"
+                                render={({ field }) => (
+                                    <FormItem>
+                                        <FormLabel>Comments (Optional)</FormLabel>
+                                        <FormControl>
+                                            <Textarea
+                                                placeholder="Special notes or preferences"
+                                                className="resize-none"
+                                                {...field}
+                                            />
+                                        </FormControl>
+                                        <FormMessage />
+                                    </FormItem>
+                                )}
+                            />
+
+                            <DialogFooter className="mt-6">
+                                <Button type="button" variant="outline" onClick={() => setIsGuestModalOpen(false)}>
+                                    Cancel
+                                </Button>
+                                <Button
+                                    type="submit"
+                                    disabled={createGuestMutation.isPending || updateGuestMutation.isPending}
+                                >
+                                    {createGuestMutation.isPending || updateGuestMutation.isPending ?
+                                        "Saving..." :
+                                        selectedGuestId ? "Update Guest" : "Add Guest"
+                                    }
+                                </Button>
+                            </DialogFooter>
+                        </form>
+                    </Form>
+                </DialogContent>
+            </Dialog>
+
+            <AlertDialog open={deleteConfirmOpen} onOpenChange={setDeleteConfirmOpen}>
+                <AlertDialogContent>
+                    <AlertDialogHeader>
+                        <AlertDialogTitle>Are you sure?</AlertDialogTitle>
+                        <AlertDialogDescription>
+                            This will permanently delete the guest and their data. Reservations associated with this guest will be affected. This action cannot be undone.
+                        </AlertDialogDescription>
+                    </AlertDialogHeader>
+                    <AlertDialogFooter>
+                        <AlertDialogCancel>Cancel</AlertDialogCancel>
+                        <AlertDialogAction onClick={confirmDelete} className="bg-red-600 hover:bg-red-700">
+                            {deleteGuestMutation.isPending ? "Deleting..." : "Delete"}
+                        </AlertDialogAction>
+                    </AlertDialogFooter>
+                </AlertDialogContent>
+            </AlertDialog>
+
+            {/* ✅ NEW: Render the analytics drawer component */}
+            <GuestAnalyticsDrawer
+                guest={selectedGuestForAnalytics}
+                isOpen={!!selectedGuestForAnalytics}
+                onClose={() => setSelectedGuestForAnalytics(null)}
+            />
+        </DashboardLayout>
+    );
+}
diff --git a/client/src/pages/modern-tables.tsx b/client/src/pages/modern-tables.tsx
index 72cfc44..6e8d788 100644
--- a/client/src/pages/modern-tables.tsx
+++ b/client/src/pages/modern-tables.tsx
@@ -1,15 +1,16 @@
-import React, { useState, useRef } from "react";
+import React, { useState, useRef, Suspense, lazy, useEffect, useMemo, useCallback } from "react";
 import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
 import { DateTime } from "luxon";
 import { Badge } from "@/components/ui/badge";
 import { Button } from "@/components/ui/button";
 import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
 import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger, DropdownMenuSeparator } from "@/components/ui/dropdown-menu";
-import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog";
+import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from "@/components/ui/dialog";
 import { Input } from "@/components/ui/input";
 import { Label } from "@/components/ui/label";
 import { Textarea } from "@/components/ui/textarea";
 import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
+import { Checkbox } from "@/components/ui/checkbox";
 import { Clock, Users, Settings, MousePointer2, Edit2, RefreshCw, Move, Calendar, Plus, MoreHorizontal, Trash2, ArrowUp, ArrowDown, UserPlus, Save, X } from "lucide-react";
 import { useToast } from "@/hooks/use-toast";
 import { cn } from "@/lib/utils";
@@ -17,1471 +18,1802 @@ import { apiRequest } from "@/lib/queryClient";
 import { DashboardLayout } from "@/components/layout/DashboardLayout";
 import { getRestaurantDateTime, getRestaurantDateString, getTomorrowDateString } from "@/lib/utils";
 
-// ✅ NEW: Import WebSocket context and dnd-kit
+// ✅ FIXED: Direct WebSocket context usage - no dynamic imports
 import { useWebSocketContext } from "@/components/websocket/WebSocketContext";
-import { DndContext, DragEndEvent } from '@dnd-kit/core';
-import { DraggableReservation } from '@/components/reservations/DraggableReservation';
-import { DroppableSlot } from '@/components/reservations/DroppableSlot';
 
+// ✅ FIXED: Stable DnD components loader with better error handling
+const useDndComponents = () => {
+    const [dndComponents, setDndComponents] = useState<any>({
+        DndContext: ({ children, onDragEnd }: any) => <div>{children}</div>,
+        DraggableReservation: ({ children }: any) => <div>{children}</div>,
+        DroppableSlot: ({ children }: any) => <div>{children}</div>,
+    });
+    
+    const [isLoaded, setIsLoaded] = useState(false);
+    
+    useEffect(() => {
+        let mounted = true;
+        let loadTimeout: NodeJS.Timeout;
+        
+        const loadDndComponents = async () => {
+            try {
+                // Wait longer to ensure WebSocket is completely stable
+                await new Promise(resolve => setTimeout(resolve, 2000));
+                
+                if (!mounted) return;
+
+                console.log('[ModernTables] Loading DnD components...');
+                
+                const [dndModule, draggableModule, droppableModule] = await Promise.all([
+                    import('@dnd-kit/core').catch(() => {
+                        console.log('[ModernTables] @dnd-kit/core not available');
+                        return null;
+                    }),
+                    import('@/components/reservations/DraggableReservation').catch(() => {
+                        console.log('[ModernTables] DraggableReservation not available');
+                        return null;
+                    }),
+                    import('@/components/reservations/DroppableSlot').catch(() => {
+                        console.log('[ModernTables] DroppableSlot not available');
+                        return null;
+                    })
+                ]);
+                
+                if (mounted) {
+                    console.log('[ModernTables] DnD components loaded successfully');
+                    setDndComponents({
+                        DndContext: dndModule?.DndContext || (({ children }: any) => <div>{children}</div>),
+                        DraggableReservation: draggableModule?.DraggableReservation || (({ children }: any) => <div>{children}</div>),
+                        DroppableSlot: droppableModule?.DroppableSlot || (({ children }: any) => <div>{children}</div>),
+                    });
+                    setIsLoaded(true);
+                }
+            } catch (error) {
+                console.log('[ModernTables] DnD components loading failed, using fallbacks');
+                if (mounted) {
+                    setIsLoaded(true);
+                }
+            }
+        };
+        
+        // Delay the loading longer to prevent any interference with WebSocket
+        loadTimeout = setTimeout(loadDndComponents, 3000);
+        
+        return () => {
+            mounted = false;
+            if (loadTimeout) {
+                clearTimeout(loadTimeout);
+            }
+        };
+    }, []);
+    
+    return { ...dndComponents, isLoaded };
+};
+
+// ✅ FIXED: Simplified FloorPlanView fallback that doesn't cause re-renders
+const FloorPlanViewFallback = React.memo(({ floors, isLoading, isManageFloorsOpen, setIsManageFloorsOpen }: any) => {
+    const [newFloorName, setNewFloorName] = useState("");
+    const queryClient = useQueryClient();
+    const { toast } = useToast();
+
+    const createFloorMutation = useMutation({
+        mutationFn: async (name: string) => {
+            const response = await fetch('/api/floors', {
+                method: 'POST',
+                headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
+                credentials: 'include',
+                body: JSON.stringify({ name })
+            });
+
+            if (!response.ok) {
+                const errorData = await response.json().catch(() => ({}));
+                throw new Error(errorData.message || 'Failed to create floor');
+            }
+            return response.json();
+        },
+        onSuccess: (newFloor) => {
+            toast({
+                title: "Floor Created",
+                description: `Successfully created '${newFloor.name}' (Fallback Mode).`
+            });
+            setNewFloorName("");
+            queryClient.invalidateQueries({ queryKey: ["/api/floors"] });
+        },
+        onError: (error: any) => {
+            toast({
+                title: "Failed to Create Floor",
+                description: error.message || "An unexpected error occurred",
+                variant: "destructive"
+            });
+        }
+    });
+
+    const handleCreateFloor = useCallback(() => {
+        const trimmedName = newFloorName.trim();
+        if (!trimmedName) {
+            toast({
+                title: "Invalid Floor Name",
+                description: "Please enter a valid floor name",
+                variant: "destructive"
+            });
+            return;
+        }
+        createFloorMutation.mutate(trimmedName);
+    }, [newFloorName, createFloorMutation, toast]);
+
+    return (
+        <div className="p-6 text-center">
+            <h3 className="text-lg font-semibold mb-4">Floor Plan View (Loading...)</h3>
+            <p className="text-gray-500 mb-4">FloorPlanView component is loading</p>
+            <p className="text-sm text-gray-400 mb-4">Floors available: {floors?.length || 0}</p>
+
+            <Button onClick={() => setIsManageFloorsOpen(true)} className="mt-4">
+                <Settings className="h-4 w-4 mr-2" />
+                {(!floors || floors.length === 0) ? "Create First Floor" : "Manage Floors"}
+            </Button>
+
+            <Dialog open={isManageFloorsOpen} onOpenChange={setIsManageFloorsOpen}>
+                <DialogContent className="max-w-md">
+                    <DialogHeader>
+                        <DialogTitle>Manage Floors (Loading Mode)</DialogTitle>
+                        <DialogDescription>Floor plan is loading. Basic management available.</DialogDescription>
+                    </DialogHeader>
+                    <div className="space-y-4 py-4">
+                        <div className="p-2 bg-blue-100 rounded text-xs">
+                            <strong>Loading:</strong> FloorPlanView component is loading. Basic floor management available.
+                        </div>
+
+                        <div className="space-y-2">
+                            <Label htmlFor="new-floor-input-loading">Create New Floor</Label>
+                            <div className="flex items-center gap-2">
+                                <Input
+                                    id="new-floor-input-loading"
+                                    placeholder="New floor name (e.g., Main Hall)"
+                                    value={newFloorName}
+                                    onChange={(e) => setNewFloorName(e.target.value)}
+                                    onKeyPress={(e) => {
+                                        if (e.key === 'Enter') {
+                                            e.preventDefault();
+                                            handleCreateFloor();
+                                        }
+                                    }}
+                                    disabled={createFloorMutation.isPending}
+                                />
+                                <Button
+                                    onClick={handleCreateFloor}
+                                    disabled={createFloorMutation.isPending || !newFloorName.trim()}
+                                    className="flex-shrink-0"
+                                >
+                                    {createFloorMutation.isPending ? (
+                                        <RefreshCw className="h-4 w-4 animate-spin" />
+                                    ) : (
+                                        <Plus className="h-4 w-4" />
+                                    )}
+                                </Button>
+                            </div>
+                        </div>
+
+                        {floors && floors.length > 0 && (
+                            <div className="space-y-2">
+                                <Label>Existing Floors ({floors.length})</Label>
+                                <div className="max-h-32 overflow-y-auto space-y-2">
+                                    {floors.map((floor: any) => (
+                                        <div key={floor.id} className="flex items-center justify-between p-2 bg-gray-100 dark:bg-gray-700 rounded-md">
+                                            <span>{floor.name}</span>
+                                        </div>
+                                    ))}
+                                </div>
+                            </div>
+                        )}
+                    </div>
+                    <DialogFooter>
+                        <Button variant="outline" onClick={() => setIsManageFloorsOpen(false)}>
+                            Close
+                        </Button>
+                    </DialogFooter>
+                </DialogContent>
+            </Dialog>
+        </div>
+    );
+});
+
+FloorPlanViewFallback.displayName = 'FloorPlanViewFallback';
+
+// ✅ FIXED: Stable lazy loading that doesn't cause WebSocket issues
+const FloorPlanView = lazy(() =>
+    import("./FloorPlanView")
+        .then(module => ({ default: module.FloorPlanView }))
+        .catch(error => {
+            console.log('[ModernTables] FloorPlanView not available, using fallback:', error);
+            return { default: FloorPlanViewFallback };
+        })
+);
+
+// Interfaces
 interface TableData {
-  id: number;
-  name: string;
-  minGuests: number;
-  maxGuests: number;
-  status: string;
-  reservation?: {
     id: number;
-    guestName: string;
-    guestCount: number;
-    timeSlot: string;
-    phone: string;
+    name: string;
+    minGuests: number;
+    maxGuests: number;
     status: string;
-  };
+    features: string[];
+    comments?: string;
+    floorId: number | null;
+    posX: number;
+    posY: number;
+    shape: 'square' | 'round';
+    rotation: number;
+    floor?: {
+        name: string;
+    };
+    reservation?: {
+        id: number;
+        guestName: string;
+        guestCount: number;
+        timeSlot: string;
+        phone: string;
+        status: string;
+    };
 }
 
 interface ScheduleSlot {
-  time: string;
-  tables: TableData[];
+    time: string;
+    tables: TableData[];
 }
 
 interface AddTableForm {
-  name: string;
-  minGuests: number;
-  maxGuests: number;
-  features: string;
-  comments: string;
+    name: string;
+    minGuests: number;
+    maxGuests: number;
+    features: string;
+    isNonCombinable: boolean;
+    comments: string;
+    floorId: number | null;
+    shape: 'square' | 'round';
 }
 
 interface Restaurant {
-  id: number;
-  openingTime: string;
-  closingTime: string;
-  avgReservationDuration: number;
-  timezone: string;
-  [key: string]: any;
+    id: number;
+    openingTime: string;
+    closingTime: string;
+    avgReservationDuration: number;
+    timezone: string;
+    [key: string]: any;
+}
+
+interface Floor {
+    id: number;
+    name: string;
 }
 
 interface MutationContext {
-  previousData?: any;
+    previousData?: any;
 }
 
-export default function ModernTables() {
-  const [selectedDate, setSelectedDate] = useState('');
-  const [selectedTime, setSelectedTime] = useState("19:00");
-  const [activeView, setActiveView] = useState<"schedule" | "floorplan" | "grid" | "list">("schedule");
-  
-  // Add Table Modal State
-  const [showAddTableModal, setShowAddTableModal] = useState(false);
-  const [editingTable, setEditingTable] = useState<TableData | null>(null);
-  const [addTableForm, setAddTableForm] = useState<AddTableForm>({
-    name: "",
-    minGuests: 1,
-    maxGuests: 4,
-    features: "",
-    comments: ""
-  });
-  
-  // Context menu state
-  const [contextMenu, setContextMenu] = useState<{
-    x: number;
-    y: number;
-    reservationId?: number;
-    tableId?: number;
-    timeSlot?: string;
-    guestName?: string;
-  } | null>(null);
-
-  // ✅ REMOVED: All manual drag-and-drop state variables
-  // - draggedReservation
-  // - dragPosition
-  // - dragOverSlot
-  // - isValidDropZone
-  
-  const queryClient = useQueryClient();
-  const { toast } = useToast();
-
-  // ✅ NEW: WebSocket context for real-time updates
-  const { isConnected } = useWebSocketContext();
-
-  // Get restaurant profile first
-  const { data: restaurant, isLoading: restaurantLoading, error: restaurantError } = useQuery<Restaurant>({
-    queryKey: ["/api/restaurants/profile"],
-    retry: 3,
-    staleTime: 30000,
-  });
-
-  const restaurantTimezone = restaurant?.timezone || 'Europe/Belgrade';
-
-  // Set selectedDate after restaurant loads
-  React.useEffect(() => {
-    if (restaurant && !selectedDate) {
-      setSelectedDate(getRestaurantDateString(restaurantTimezone));
+// ✅ FIXED: Simple error boundary that doesn't interfere with WebSocket
+class ErrorBoundary extends React.Component<
+    { children: React.ReactNode; fallback: React.ReactNode },
+    { hasError: boolean; error?: Error }
+> {
+    constructor(props: any) {
+        super(props);
+        this.state = { hasError: false };
     }
-  }, [restaurant, restaurantTimezone, selectedDate]);
 
-  // Enhanced overnight-aware time slot generation
-  const timeSlots: string[] = React.useMemo(() => {
-    if (!restaurant?.openingTime || !restaurant?.closingTime) {
-      return [];
+    static getDerivedStateFromError(error: Error) {
+        return { hasError: true, error };
     }
 
-    const slots: string[] = [];
-    try {
-      const [openHour, openMin] = restaurant.openingTime.split(':').map(Number);
-      const [closeHour, closeMin] = restaurant.closingTime.split(':').map(Number);
-      
-      const openingMinutes = openHour * 60 + (openMin || 0);
-      const closingMinutes = closeHour * 60 + (closeMin || 0);
-      
-      const isOvernightOperation = closingMinutes < openingMinutes;
-      
-      if (isOvernightOperation) {
-        console.log(`[ModernTables] 🌙 Overnight operation detected: ${restaurant.openingTime}-${restaurant.closingTime}`);
-        
-        for (let minutes = openingMinutes; minutes < 24 * 60; minutes += 60) {
-          const hour = Math.floor(minutes / 60);
-          const minute = minutes % 60;
-          slots.push(`${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`);
-        }
-        
-        for (let minutes = 0; minutes < closingMinutes; minutes += 60) {
-          const hour = Math.floor(minutes / 60);
-          const minute = minutes % 60;
-          slots.push(`${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`);
-        }
-        
-        console.log(`[ModernTables] 🌙 Generated ${slots.length} overnight slots:`, slots.slice(0, 5), '...', slots.slice(-3));
-      } else {
-        console.log(`[ModernTables] 📅 Standard operation: ${restaurant.openingTime}-${restaurant.closingTime}`);
-        
-        const avgDuration = restaurant.avgReservationDuration || 120;
-        const lastBookingTime = closingMinutes - avgDuration;
-        
-        for (let minutes = openingMinutes; minutes <= lastBookingTime; minutes += 60) {
-          const hour = Math.floor(minutes / 60);
-          const minute = minutes % 60;
-          slots.push(`${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`);
-        }
-        
-        console.log(`[ModernTables] 📅 Generated ${slots.length} standard slots`);
-      }
-    } catch (error) {
-      console.error('Error generating time slots:', error);
+    componentDidCatch(error: Error, errorInfo: any) {
+        console.error('[ModernTables] Error boundary caught:', error, errorInfo);
     }
-    
-    return slots;
-  }, [restaurant]);
-
-  // Get tables with proper timezone context
-  const { data: tables, isLoading: tablesLoading, error: tablesError } = useQuery({
-    queryKey: ["/api/tables", restaurantTimezone],
-    enabled: !!restaurant,
-    retry: 3,
-  });
-
-  // ✅ UPDATED: Removed refetchInterval for real-time WebSocket updates
-  const { data: scheduleData, isLoading, error: scheduleError } = useQuery({
-    queryKey: ["/api/tables/availability/schedule", selectedDate, restaurantTimezone],
-    queryFn: async () => {
-      if (!selectedDate || timeSlots.length === 0) {
-        throw new Error('Missing date or time slots');
-      }
-
-      console.log(`🔍 [ModernTables] Fetching schedule for ${selectedDate} with timezone ${restaurantTimezone}`);
-      console.log(`🔍 [ModernTables] Time slots to check: ${timeSlots.length} slots`);
-
-      const isOvernight = restaurant?.openingTime && restaurant?.closingTime && 
-        (parseInt(restaurant.closingTime.split(':')[0]) < parseInt(restaurant.openingTime.split(':')[0]));
 
-      const promises = timeSlots.map(async (time) => {
-        const url = `/api/tables/availability?date=${selectedDate}&time=${time}&timezone=${encodeURIComponent(restaurantTimezone)}`;
-        
-        try {
-          const response = await fetch(url, {
-            credentials: 'include',
-            headers: {
-              'Accept': 'application/json',
-              'Content-Type': 'application/json'
-            }
-          });
-          
-          if (!response.ok) {
-            console.error(`❌ Failed to fetch availability for ${time}:`, response.status, response.statusText);
-            
-            if (isOvernight) {
-              console.error(`❌ [ModernTables] Overnight operation error at ${time} - this might be due to timezone handling`);
-            }
-            
-            throw new Error(`Failed to fetch availability for ${time}: ${response.status}`);
-          }
-          
-          const data = await response.json();
-          const sortedTables = Array.isArray(data) ? data.sort((a: any, b: any) => a.id - b.id) : [];
-          
-          if (isOvernight && (time === timeSlots[0] || time === timeSlots[Math.floor(timeSlots.length/2)] || time === timeSlots[timeSlots.length-1])) {
-            console.log(`✅ [ModernTables] 🌙 Overnight slot ${time}: ${sortedTables.length} tables`);
-          } else if (!isOvernight && sortedTables.length > 0) {
-            console.log(`✅ [ModernTables] 📅 Standard slot ${time}: ${sortedTables.length} tables`);
-          }
-          
-          return { time, tables: sortedTables };
-          
-        } catch (error) {
-          console.error(`❌ Error fetching ${time}:`, error);
-          
-          if (isOvernight) {
-            console.warn(`⚠️ [ModernTables] 🌙 Overnight slot ${time} failed, providing empty data`);
-            return { time, tables: [] };
-          }
-          
-          throw error;
+    render() {
+        if (this.state.hasError) {
+            return this.props.fallback;
         }
-      });
-      
-      const results = await Promise.allSettled(promises);
-      
-      const successfulResults = results
-        .filter((result): result is PromiseFulfilledResult<any> => result.status === 'fulfilled')
-        .map(result => result.value);
-      
-      const failedResults = results.filter(result => result.status === 'rejected');
-      
-      if (failedResults.length > 0) {
-        console.warn(`⚠️ [ModernTables] ${failedResults.length}/${timeSlots.length} time slots failed to load`);
-        
-        if (isOvernight && successfulResults.length > 0) {
-          console.log(`✅ [ModernTables] 🌙 Overnight operation: Using ${successfulResults.length} successful slots out of ${timeSlots.length} total`);
-        } else if (failedResults.length === timeSlots.length) {
-          throw new Error('All time slots failed to load');
-        }
-      }
-      
-      console.log(`✅ [ModernTables] Schedule loaded: ${successfulResults.length} time slots${isOvernight ? ' (overnight operation)' : ''}`);
-      return successfulResults;
-    },
-    enabled: !!restaurant && !!selectedDate && timeSlots.length > 0,
-    // ✅ REMOVED: refetchInterval (now using WebSocket for real-time updates)
-    refetchOnWindowFocus: true,
-    refetchOnMount: true,
-    retry: (failureCount, error) => {
-      const isOvernight = restaurant?.openingTime && restaurant?.closingTime && 
-        (parseInt(restaurant.closingTime.split(':')[0]) < parseInt(restaurant.openingTime.split(':')[0]));
-      
-      if (isOvernight) {
-        return failureCount < 1;
-      }
-      return failureCount < 2;
-    },
-  });
-
-  // ✅ NEW: dnd-kit drag end handler (replaces all manual drag-and-drop handlers)
-  const handleDragEnd = (event: DragEndEvent) => {
-    const { active, over } = event;
-
-    // Exit if the item was dropped in a non-droppable area
-    if (!over) {
-      return;
-    }
 
-    // Exit if the item was dropped back into its original spot
-    if (active.id === over.id) {
-      return;
+        return this.props.children;
     }
+}
 
-    const reservationId = active.id as number;
-    const { tableId: newTableId, time: newTime } = over.data.current as { tableId: number, time: string };
-
-    // Check for capacity constraints
-    const draggedGuestCount = active.data.current?.guestCount;
-    const targetTable = over.data.current?.table;
-    
-    if (draggedGuestCount && targetTable && (draggedGuestCount < targetTable.minGuests || draggedGuestCount > targetTable.maxGuests)) {
-      toast({
-        title: "Move Failed",
-        description: `Table ${targetTable.name} cannot accommodate ${draggedGuestCount} guests.`,
-        variant: "destructive",
-      });
-      return;
-    }
+export default function ModernTables() {
+    console.log('[ModernTables] Component mounting...');
     
-    // Call the existing mutation to move the reservation
-    moveReservationMutation.mutate({
-      reservationId,
-      newTableId,
-      newTime,
-    });
-  };
-
-  // Enhanced table creation with timezone context
-  const addTableMutation = useMutation({
-    mutationFn: async (tableData: AddTableForm) => {
-      const payload = {
-        name: tableData.name,
-        minGuests: tableData.minGuests,
-        maxGuests: tableData.maxGuests,
-        features: tableData.features ? tableData.features.split(',').map(f => f.trim()) : [],
-        comments: tableData.comments,
-        status: 'free',
-        restaurantTimezone: restaurantTimezone
-      };
-      
-      console.log(`🏗️ [ModernTables] Creating table:`, payload);
-      
-      const response = await fetch('/api/tables', {
-        method: 'POST',
-        headers: { 'Content-Type': 'application/json' },
-        credentials: 'include',
-        body: JSON.stringify(payload)
-      });
-      
-      if (!response.ok) {
-        const errorData = await response.json();
-        throw new Error(errorData.message || 'Failed to create table');
-      }
-      
-      return response.json();
-    },
-    onSuccess: (newTable) => {
-      toast({
-        title: "Table Added Successfully! 🎉",
-        description: `Table ${newTable.name} (${newTable.minGuests}-${newTable.maxGuests} guests) is now available for reservations`,
-      });
-      
-      console.log(`✅ [ModernTables] Table created:`, newTable);
-      
-      queryClient.invalidateQueries({ queryKey: ["/api/tables"] });
-      queryClient.invalidateQueries({ queryKey: ["/api/tables/availability/schedule"] });
-      queryClient.invalidateQueries({ queryKey: ["/api/restaurants/profile"] });
-      
-      queryClient.refetchQueries({ 
-        queryKey: ["/api/tables/availability/schedule", selectedDate, restaurantTimezone] 
-      });
-      
-      setAddTableForm({
+    const [selectedDate, setSelectedDate] = useState('');
+    const [selectedTime, setSelectedTime] = useState("19:00");
+    const [activeView, setActiveView] = useState<"schedule" | "floorplan" | "grid" | "list">("schedule");
+
+    const [showTableModal, setShowTableModal] = useState(false);
+    const [editingTable, setEditingTable] = useState<TableData | null>(null);
+
+    const [tableForm, setTableForm] = useState<AddTableForm>({
         name: "",
         minGuests: 1,
         maxGuests: 4,
         features: "",
-        comments: ""
-      });
-      setShowAddTableModal(false);
-    },
-    onError: (error: any) => {
-      console.error('❌ [ModernTables] Table creation failed:', error);
-      toast({
-        title: "Failed to Add Table",
-        description: error.message || "Please check your inputs and try again",
-        variant: "destructive",
-      });
-    }
-  });
-
-  // Enhanced table deletion with timezone context
-  const deleteTableMutation = useMutation({
-    mutationFn: async (tableId: number) => {
-      console.log(`🗑️ [ModernTables] Deleting table ${tableId}`);
-      
-      const response = await fetch(`/api/tables/${tableId}`, {
-        method: 'DELETE',
-        credentials: 'include'
-      });
-      
-      if (!response.ok) {
-        const errorData = await response.json();
-        throw new Error(errorData.message || 'Failed to delete table');
-      }
-      
-      return response.json();
-    },
-    onSuccess: () => {
-      toast({
-        title: "Table Deleted",
-        description: "Table removed successfully",
-      });
-      
-      console.log(`✅ [ModernTables] Table deleted successfully`);
-      
-      queryClient.invalidateQueries({ queryKey: ["/api/tables"] });
-      queryClient.invalidateQueries({ queryKey: ["/api/tables/availability/schedule"] });
-      
-      queryClient.refetchQueries({ 
-        queryKey: ["/api/tables/availability/schedule", selectedDate, restaurantTimezone] 
-      });
-    },
-    onError: (error: any) => {
-      console.error('❌ [ModernTables] Table deletion failed:', error);
-      toast({
-        title: "Failed to Delete Table",
-        description: error.message || "Please try again",
-        variant: "destructive",
-      });
-    }
-  });
-
-  // Enhanced reservation movement with proper mutation types
-  const moveReservationMutation = useMutation<any, Error, { 
-    reservationId: number; 
-    newTableId: number; 
-    newTime: string; 
-  }, MutationContext>({
-    mutationFn: async (variables) => {
-      const { reservationId, newTableId, newTime } = variables;
-      console.log(`🔄 [ModernTables] Moving reservation ${reservationId} to table ${newTableId} at ${newTime}`);
-      
-      const response = await fetch(`/api/reservations/${reservationId}`, {
-        method: 'PATCH',
-        headers: { 'Content-Type': 'application/json' },
-        credentials: 'include',
-        body: JSON.stringify({
-          tableId: newTableId,
-          time: newTime,
-          date: selectedDate,
-          timezone: restaurantTimezone
-        })
-      });
-      
-      if (!response.ok) throw new Error('Failed to move reservation');
-      return response.json();
-    },
-    
-    onMutate: async (variables) => {
-      const { reservationId, newTableId, newTime } = variables;
-      await queryClient.cancelQueries({ 
-        queryKey: ["/api/tables/availability/schedule", selectedDate, restaurantTimezone] 
-      });
-
-      const previousData = queryClient.getQueryData(["/api/tables/availability/schedule", selectedDate, restaurantTimezone]);
-      // Calculate duration in hour slots based on restaurant's average reservation duration
-      const durationInSlots = Math.ceil((restaurant?.avgReservationDuration || 120) / 60);
-
-      queryClient.setQueryData(["/api/tables/availability/schedule", selectedDate, restaurantTimezone], (old: any) => {
-        if (!old) return old;
-        
-        // Find the current reservation to move
-        let currentReservation: any = null;
-        let currentTableId: number = 0;
-        let currentTime: string = '';
+        isNonCombinable: false,
+        comments: "",
+        floorId: null,
+        shape: "square",
+    });
+
+    const [contextMenu, setContextMenu] = useState<{
+        x: number;
+        y: number;
+        reservationId?: number;
+        tableId?: number;
+        timeSlot?: string;
+        guestName?: string;
+    } | null>(null);
+
+    const [isManageFloorsOpen, setIsManageFloorsOpen] = useState(false);
+
+    const queryClient = useQueryClient();
+    const { toast } = useToast();
+
+    // ✅ FIXED: Add component lifecycle tracking
+    useEffect(() => {
+        console.log('[ModernTables] Component mounted');
         
-        // Find the reservation in the current data
-        for (const slot of old) {
-          for (const table of slot.tables) {
-            if (table.reservation?.id === reservationId) {
-              currentReservation = table.reservation;
-              currentTableId = table.id;
-              currentTime = slot.time;
-              break;
+        return () => {
+            console.log('[ModernTables] Component unmounting...');
+        };
+    }, []);
+
+    // ✅ FIXED: Use WebSocket context normally - let React handle it
+    const webSocketContext = useWebSocketContext();
+    const isConnected = webSocketContext?.isConnected || false;
+    
+    // ✅ FIXED: Track WebSocket connection changes
+    useEffect(() => {
+        console.log('[ModernTables] WebSocket connection status:', isConnected);
+    }, [isConnected]);
+
+    // ✅ FIXED: Use stable DnD components with loading state
+    const { DndContext: StableDndContext, DraggableReservation: StableDraggableReservation, DroppableSlot: StableDroppableSlot, isLoaded: dndLoaded } = useDndComponents();
+
+    // Get restaurant profile first
+    const { data: restaurant, isLoading: restaurantLoading, error: restaurantError } = useQuery<Restaurant>({
+        queryKey: ["/api/restaurants/profile"],
+        retry: 3,
+        staleTime: 60000, // Cache for 1 minute
+        gcTime: 300000, // Keep in cache for 5 minutes
+    });
+
+    const restaurantTimezone = restaurant?.timezone || 'Europe/Belgrade';
+
+    // Set selectedDate after restaurant loads - memoized to prevent excessive updates
+    const selectedDateEffect = useCallback(() => {
+        if (restaurant && !selectedDate) {
+            setSelectedDate(getRestaurantDateString(restaurantTimezone));
+        }
+    }, [restaurant, selectedDate, restaurantTimezone]);
+
+    useEffect(() => {
+        selectedDateEffect();
+    }, [selectedDateEffect]);
+
+    // ✅ FIXED: Memoize floors query with longer cache
+    const { data: floors, isLoading: floorsLoading, error: floorsError } = useQuery<Floor[]>({
+        queryKey: ["/api/floors"],
+        queryFn: async () => {
+            try {
+                const response = await fetch('/api/floors', { credentials: 'include' });
+                if (!response.ok) {
+                    throw new Error(`Failed to fetch floors: ${response.status}`);
+                }
+                return response.json();
+            } catch (error) {
+                console.error('[ModernTables] Error fetching floors:', error);
+                throw error;
             }
-          }
-          if (currentReservation) break;
+        },
+        enabled: !!restaurant,
+        staleTime: 120000, // Cache for 2 minutes
+        gcTime: 600000, // Keep in cache for 10 minutes
+    });
+
+    // ✅ FIXED: Stable time slots calculation
+    const timeSlots: string[] = useMemo(() => {
+        if (!restaurant?.openingTime || !restaurant?.closingTime) {
+            return [];
         }
-        
-        if (!currentReservation) return old;
-        
-        const sourceHour = parseInt(currentTime.split(':')[0]);
-        const targetHour = parseInt(newTime.split(':')[0]);
-        
-        const sourceSlots: string[] = [];
-        const targetSlots: string[] = [];
-        
-        for (let i = 0; i < durationInSlots; i++) {
-          sourceSlots.push(`${(sourceHour + i).toString().padStart(2, '0')}:00`);
-          targetSlots.push(`${(targetHour + i).toString().padStart(2, '0')}:00`);
+
+        const slots: string[] = [];
+        try {
+            const [openHour, openMin] = restaurant.openingTime.split(':').map(Number);
+            const [closeHour, closeMin] = restaurant.closingTime.split(':').map(Number);
+
+            if (isNaN(openHour) || isNaN(closeHour)) {
+                console.error('[ModernTables] Invalid time format:', { openingTime: restaurant.openingTime, closingTime: restaurant.closingTime });
+                return [];
+            }
+
+            const openingMinutes = openHour * 60 + (openMin || 0);
+            const closingMinutes = closeHour * 60 + (closeMin || 0);
+            const isOvernightOperation = closingMinutes < openingMinutes;
+
+            if (isOvernightOperation) {
+                for (let minutes = openingMinutes; minutes < 24 * 60; minutes += 60) {
+                    const hour = Math.floor(minutes / 60);
+                    const minute = minutes % 60;
+                    slots.push(`${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`);
+                }
+
+                for (let minutes = 0; minutes < closingMinutes; minutes += 60) {
+                    const hour = Math.floor(minutes / 60);
+                    const minute = minutes % 60;
+                    slots.push(`${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`);
+                }
+            } else {
+                const avgDuration = restaurant.avgReservationDuration || 120;
+                const lastBookingTime = closingMinutes - avgDuration;
+
+                for (let minutes = openingMinutes; minutes <= lastBookingTime; minutes += 60) {
+                    const hour = Math.floor(minutes / 60);
+                    const minute = minutes % 60;
+                    slots.push(`${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`);
+                }
+            }
+        } catch (error) {
+            console.error('[ModernTables] Error generating time slots:', error);
+            return [];
         }
-        
-        return old.map((slot: any) => ({
-          ...slot,
-          tables: slot.tables.map((table: any) => {
-            if (table.id === currentTableId && 
-                sourceSlots.includes(slot.time) &&
-                table.reservation?.id === reservationId) {
-              return { 
-                ...table, 
-                reservation: null, 
-                status: 'available' 
-              };
+
+        return slots;
+    }, [restaurant?.openingTime, restaurant?.closingTime, restaurant?.avgReservationDuration]);
+
+    // Get tables with proper timezone context
+    const { data: tables, isLoading: tablesLoading, error: tablesError } = useQuery<TableData[]>({
+        queryKey: ["/api/tables", restaurantTimezone],
+        queryFn: async () => {
+            const res = await fetch(`/api/tables?timezone=${encodeURIComponent(restaurantTimezone)}`, { credentials: 'include' });
+            if (!res.ok) throw new Error('Failed to fetch tables');
+            return res.json();
+        },
+        enabled: !!restaurant,
+        retry: 3,
+        staleTime: 60000, // Cache for 1 minute
+        gcTime: 300000, // Keep in cache for 5 minutes
+    });
+
+    // ✅ FIXED: Optimized schedule data query
+    const { data: scheduleData, isLoading, error: scheduleError } = useQuery({
+        queryKey: ["/api/tables/availability/schedule", selectedDate, restaurantTimezone],
+        queryFn: async () => {
+            if (!selectedDate || timeSlots.length === 0) {
+                throw new Error('Missing date or time slots');
             }
-            
-            if (table.id === newTableId && targetSlots.includes(slot.time)) {
-              return { 
-                ...table, 
-                status: 'reserved',
-                reservation: {
-                  ...currentReservation,
-                  timeSlot: `${slot.time}-${targetSlots[targetSlots.length - 1]}`
+
+            const isOvernight = restaurant?.openingTime && restaurant?.closingTime &&
+                (parseInt(restaurant.closingTime.split(':')[0]) < parseInt(restaurant.openingTime.split(':')[0]));
+
+            const promises = timeSlots.map(async (time) => {
+                const url = `/api/tables/availability?date=${selectedDate}&time=${time}&timezone=${encodeURIComponent(restaurantTimezone)}`;
+
+                try {
+                    const response = await fetch(url, {
+                        credentials: 'include',
+                        headers: {
+                            'Accept': 'application/json',
+                            'Content-Type': 'application/json'
+                        }
+                    });
+
+                    if (!response.ok) {
+                        throw new Error(`Failed to fetch availability for ${time}: ${response.status}`);
+                    }
+
+                    const data = await response.json();
+                    const sortedTables = Array.isArray(data) ? data.sort((a: any, b: any) => a.id - b.id) : [];
+                    return { time, tables: sortedTables };
+
+                } catch (error) {
+                    if (isOvernight) {
+                        return { time, tables: [] };
+                    }
+                    throw error;
                 }
-              };
+            });
+
+            const results = await Promise.allSettled(promises);
+
+            const successfulResults = results
+                .filter((result): result is PromiseFulfilledResult<any> => result.status === 'fulfilled')
+                .map(result => result.value);
+
+            const failedResults = results.filter(result => result.status === 'rejected');
+
+            if (failedResults.length > 0 && failedResults.length === timeSlots.length) {
+                throw new Error('All time slots failed to load');
             }
-            
-            return table;
-          })
-        }));
-      });
-
-      return { previousData };
-    },
-
-    onSuccess: (data: any, variables) => {
-      const { newTableId, newTime } = variables;
-      
-      // Find table names for the toast message
-      const newTableName = scheduleData?.find(slot => slot.time === newTime)
-        ?.tables?.find((t: any) => t.id === newTableId)?.name || `Table ${newTableId}`;
-
-      toast({
-        title: "Reservation Updated",
-        description: `Reservation moved to ${newTime} (${newTableName})`,
-      });
-      
-      queryClient.invalidateQueries({ 
-        queryKey: ["/api/reservations", restaurantTimezone] 
-      });
-    },
-
-    onError: (error: any, variables, context) => {
-      if (context?.previousData) {
-        queryClient.setQueryData(
-          ["/api/tables/availability/schedule", selectedDate, restaurantTimezone], 
-          context.previousData
-        );
-      }
 
-      toast({
-        title: "Failed to move reservation",
-        description: error.message || "Please try again",
-        variant: "destructive",
-      });
-    }
-  });
-
-  // Enhanced reservation cancellation with proper typing
-  const cancelReservationMutation = useMutation<any, Error, number, MutationContext>({
-    mutationFn: async (reservationId: number) => {
-      const response = await fetch(`/api/reservations/${reservationId}`, {
-        method: 'PATCH',
-        headers: { 'Content-Type': 'application/json' },
-        credentials: 'include',
-        body: JSON.stringify({ 
-          status: 'canceled',
-          timezone: restaurantTimezone
-        })
-      });
-      if (!response.ok) throw new Error('Failed to cancel reservation');
-      return response.json();
-    },
-    
-    onMutate: async (reservationId: number) => {
-      await queryClient.cancelQueries({ queryKey: ["/api/tables/availability/schedule", selectedDate, restaurantTimezone] });
-      
-      const previousData = queryClient.getQueryData(["/api/tables/availability/schedule", selectedDate, restaurantTimezone]);
-      
-      queryClient.setQueryData(["/api/tables/availability/schedule", selectedDate, restaurantTimezone], (old: any) => {
-        if (!old) return old;
-        
-        return old.map((slot: any) => ({
-          ...slot,
-          tables: slot.tables.map((table: any) => {
-            if (table.reservation?.id === reservationId) {
-              return {
-                ...table,
-                reservation: null,
-                status: 'available'
-              };
+            return successfulResults;
+        },
+        enabled: !!restaurant && !!selectedDate && timeSlots.length > 0,
+        refetchOnWindowFocus: true,
+        refetchOnMount: true,
+        staleTime: 30000, // Cache for 30 seconds
+        gcTime: 120000, // Keep in cache for 2 minutes
+        retry: (failureCount, error) => {
+            const isOvernight = restaurant?.openingTime && restaurant?.closingTime &&
+                (parseInt(restaurant.closingTime.split(':')[0]) < parseInt(restaurant.openingTime.split(':')[0]));
+
+            if (isOvernight) {
+                return failureCount < 1;
             }
-            return table;
-          })
-        }));
-      });
-      
-      return { previousData };
-    },
-    
-    onSuccess: () => {
-      setContextMenu(null);
-      toast({
-        title: "Reservation Cancelled",
-        description: "Successfully cancelled reservation.",
-      });
-    },
-    
-    onError: (error, variables, context) => {
-      if (context?.previousData) {
-        queryClient.setQueryData(["/api/tables/availability/schedule", selectedDate, restaurantTimezone], context.previousData);
-      }
-      toast({
-        title: "Cancellation Failed", 
-        description: "Could not cancel reservation. Please try again.",
-        variant: "destructive",
-      });
-    },
-  });
-
-  // Enhanced quick move with proper typing
-  const quickMoveMutation = useMutation<any, Error, { reservationId: number; direction: 'up' | 'down' }, MutationContext>({
-    mutationFn: async ({ reservationId, direction }) => {
-      const currentSlot = scheduleData?.find(slot => 
-        slot.tables.some((t: any) => t.reservation?.id === reservationId)
-      );
-      const currentTable = currentSlot?.tables.find((t: any) => t.reservation?.id === reservationId);
-      
-      if (!currentSlot || !currentTable) throw new Error('Reservation not found');
-      
-      const currentHour = parseInt(currentSlot.time.split(':')[0]);
-      const newHour = direction === 'up' ? currentHour - 1 : currentHour + 1;
-      
-      const isOvernight = restaurant?.openingTime && restaurant?.closingTime && 
-        (parseInt(restaurant.closingTime.split(':')[0]) < parseInt(restaurant.openingTime.split(':')[0]));
-      
-      if (isOvernight) {
-        const openingHour = parseInt(restaurant.openingTime.split(':')[0]);
-        const closingHour = parseInt(restaurant.closingTime.split(':')[0]);
-        
-        if (direction === 'up' && newHour < 0) {
-          throw new Error('Cannot move before midnight');
+            return failureCount < 2;
+        },
+    });
+
+    // ✅ FIXED: Memoized drag end handler to prevent re-renders
+    const handleDragEnd = useCallback((event: any) => {
+        const { active, over } = event;
+
+        if (!over || active.id === over.id) {
+            return;
         }
-        if (direction === 'down' && newHour >= 24) {
-          throw new Error('Cannot move past 24:00');
+
+        const reservationId = active.id as number;
+        const { tableId: newTableId, time: newTime } = over.data.current as { tableId: number, time: string };
+
+        const draggedGuestCount = active.data.current?.guestCount;
+        const targetTable = over.data.current?.table;
+
+        if (draggedGuestCount && targetTable && (draggedGuestCount < targetTable.minGuests || draggedGuestCount > targetTable.maxGuests)) {
+            toast({
+                title: "Move Failed",
+                description: `Table ${targetTable.name} cannot accommodate ${draggedGuestCount} guests.`,
+                variant: "destructive",
+            });
+            return;
         }
-        
-        const isValidHour = (newHour >= openingHour || newHour < closingHour);
-        if (!isValidHour) {
-          throw new Error(`Cannot move outside operating hours (${restaurant.openingTime} - ${restaurant.closingTime})`);
+
+        moveReservationMutation.mutate({
+            reservationId,
+            newTableId,
+            newTime,
+        });
+    }, [toast]);
+
+    // Function to prepare and open the modal for editing
+    const handleOpenEditModal = useCallback((table: TableData) => {
+        setEditingTable(table);
+        setTableForm({
+            name: table.name,
+            minGuests: table.minGuests,
+            maxGuests: table.maxGuests,
+            features: table.features.filter(f => f.toLowerCase() !== 'non-combinable').join(', '),
+            isNonCombinable: table.features.some(f => f.toLowerCase() === 'non-combinable'),
+            comments: table.comments || "",
+            floorId: table.floorId,
+            shape: table.shape,
+        });
+        setShowTableModal(true);
+    }, []);
+
+    // Function to open the modal for adding a new table
+    const handleOpenAddModal = useCallback(() => {
+        setEditingTable(null);
+        setTableForm({
+            name: "",
+            minGuests: 1,
+            maxGuests: 4,
+            features: "",
+            isNonCombinable: false,
+            comments: "",
+            floorId: floors && floors.length > 0 ? floors[0].id : null,
+            shape: "square",
+        });
+        setShowTableModal(true);
+    }, [floors]);
+
+    const commonMutationOptions = {
+        onSuccess: () => {
+            queryClient.invalidateQueries({ queryKey: ["/api/tables"] });
+            queryClient.invalidateQueries({ queryKey: ["/api/tables/availability/schedule"] });
+            queryClient.invalidateQueries({ queryKey: ["/api/floors"] });
+            queryClient.invalidateQueries({ queryKey: ["/api/restaurants/profile"] });
+
+            setShowTableModal(false);
+            setEditingTable(null);
+        },
+        onError: (error: any) => {
+            toast({
+                title: "Operation Failed",
+                description: error.message || "An unexpected error occurred. Please try again.",
+                variant: "destructive",
+            });
         }
-      } else {
-        const openingHour = parseInt(restaurant?.openingTime?.split(':')[0] || '10');
-        const closingHour = parseInt(restaurant?.closingTime?.split(':')[0] || '22');
-        
-        if (newHour < openingHour || newHour > closingHour - 2) {
-          throw new Error(`Cannot move outside business hours (${openingHour}:00 - ${closingHour - 2}:00)`);
+    };
+
+    // Add/Edit table mutations
+    const addTableMutation = useMutation({
+        mutationFn: async (tableData: AddTableForm) => {
+            const baseFeatures = tableData.features ? tableData.features.split(',').map(f => f.trim()) : [];
+            const cleanedFeatures = baseFeatures.filter(f => f.toLowerCase() !== 'non-combinable' && f);
+            if (tableData.isNonCombinable) {
+                cleanedFeatures.push('non-combinable');
+            }
+
+            const payload = {
+                ...tableData,
+                features: cleanedFeatures,
+                posX: 50,
+                posY: 50,
+            };
+
+            const response = await fetch('/api/tables', {
+                method: 'POST',
+                headers: { 'Content-Type': 'application/json' },
+                credentials: 'include',
+                body: JSON.stringify(payload)
+            });
+
+            if (!response.ok) {
+                const errorData = await response.json();
+                throw new Error(errorData.message || 'Failed to create table');
+            }
+            return response.json();
+        },
+        ...commonMutationOptions,
+        onSuccess: (newTable) => {
+            toast({
+                title: "Table Added Successfully! 🎉",
+                description: `Table ${newTable.name} is now available.`,
+            });
+            commonMutationOptions.onSuccess();
         }
-      }
-      
-      const newTime = `${newHour.toString().padStart(2, '0')}:00`;
-      
-      const targetSlots = [
-        newTime,
-        `${(newHour + 1).toString().padStart(2, '0')}:00`
-      ];
-      
-      for (const targetTime of targetSlots) {
-        const targetSlot = scheduleData?.find(s => s.time === targetTime);
-        const targetTable = targetSlot?.tables?.find((t: any) => t.id === currentTable.id);
-        
-        if (targetTable?.reservation && targetTable.reservation.id !== reservationId) {
-          throw new Error(`Cannot move: ${targetTable.reservation.guestName} already has ${targetTime} reserved`);
+    });
+
+    const editTableMutation = useMutation({
+        mutationFn: async (tableData: AddTableForm) => {
+            if (!editingTable) throw new Error("No table selected for editing.");
+
+            const baseFeatures = tableData.features ? tableData.features.split(',').map(f => f.trim()) : [];
+            const cleanedFeatures = baseFeatures.filter(f => f.toLowerCase() !== 'non-combinable' && f);
+            if (tableData.isNonCombinable) {
+                cleanedFeatures.push('non-combinable');
+            }
+
+            const payload = { ...tableData, features: cleanedFeatures };
+
+            const response = await fetch(`/api/tables/${editingTable.id}`, {
+                method: 'PATCH',
+                headers: { 'Content-Type': 'application/json' },
+                credentials: 'include',
+                body: JSON.stringify(payload)
+            });
+
+            if (!response.ok) {
+                const errorData = await response.json();
+                throw new Error(errorData.message || 'Failed to update table');
+            }
+            return response.json();
+        },
+        ...commonMutationOptions,
+        onSuccess: (updatedTable) => {
+            toast({
+                title: "Table Updated Successfully!",
+                description: `Changes to table ${updatedTable.name} have been saved.`,
+            });
+            commonMutationOptions.onSuccess();
         }
-      }
-      
-      const response = await fetch(`/api/reservations/${reservationId}`, {
-        method: 'PATCH',
-        headers: { 'Content-Type': 'application/json' },
-        credentials: 'include',
-        body: JSON.stringify({
-          tableId: currentTable.id,
-          time: newTime,
-          date: selectedDate,
-          timezone: restaurantTimezone
-        }),
-      });
-      if (!response.ok) throw new Error('Failed to move reservation');
-      return { response: response.json(), newTime, currentTable };
-    },
-    
-    onMutate: async ({ reservationId, direction }) => {
-      await queryClient.cancelQueries({ queryKey: ["/api/tables/availability/schedule", selectedDate, restaurantTimezone] });
-      
-      const previousData = queryClient.getQueryData(["/api/tables/availability/schedule", selectedDate, restaurantTimezone]);
-      
-      const currentSlot = scheduleData?.find(slot => 
-        slot.tables.some((t: any) => t.reservation?.id === reservationId)
-      );
-      const currentTable = currentSlot?.tables.find((t: any) => t.reservation?.id === reservationId);
-      
-      if (!currentSlot || !currentTable || !currentTable.reservation) return { previousData };
-      
-      const currentHour = parseInt(currentSlot.time.split(':')[0]);
-      const targetHour = direction === 'up' ? currentHour - 1 : currentHour + 1;
-      const targetTime = `${targetHour.toString().padStart(2, '0')}:00`;
-      
-      // Calculate duration in hour slots based on restaurant's average reservation duration
-      const durationInSlots = Math.ceil((restaurant?.avgReservationDuration || 120) / 60);
-      
-      queryClient.setQueryData(["/api/tables/availability/schedule", selectedDate, restaurantTimezone], (old: any) => {
-        if (!old) return old;
-        
-        const sourceSlots: string[] = [];
-        const targetSlots: string[] = [];
-        
-        for (let i = 0; i < durationInSlots; i++) {
-          sourceSlots.push(`${(currentHour + i).toString().padStart(2, '0')}:00`);
-          targetSlots.push(`${(targetHour + i).toString().padStart(2, '0')}:00`);
+    });
+
+    // Enhanced table deletion with timezone context
+    const deleteTableMutation = useMutation({
+        mutationFn: async (tableId: number) => {
+            const response = await fetch(`/api/tables/${tableId}`, {
+                method: 'DELETE',
+                credentials: 'include'
+            });
+
+            if (!response.ok) {
+                const errorData = await response.json();
+                throw new Error(errorData.message || 'Failed to delete table');
+            }
+
+            return response.json();
+        },
+        onSuccess: () => {
+            toast({
+                title: "Table Deleted",
+                description: "Table removed successfully",
+            });
+            queryClient.invalidateQueries({ queryKey: ["/api/tables"] });
+            queryClient.invalidateQueries({ queryKey: ["/api/tables/availability/schedule"] });
+        },
+        onError: (error: any) => {
+            toast({
+                title: "Failed to Delete Table",
+                description: error.message || "Please try again",
+                variant: "destructive",
+            });
         }
-        
-        return old.map((slot: any) => ({
-          ...slot,
-          tables: slot.tables.map((table: any) => {
-            if (table.id === currentTable.id && 
-                sourceSlots.includes(slot.time) &&
-                table.reservation?.id === reservationId) {
-              return {
-                ...table,
-                reservation: null,
-                status: 'available'
-              };
+    });
+
+    // Enhanced reservation movement with proper mutation types
+    const moveReservationMutation = useMutation<any, Error, {
+        reservationId: number;
+        newTableId: number;
+        newTime: string;
+    }, MutationContext>({
+        mutationFn: async (variables) => {
+            const { reservationId, newTableId, newTime } = variables;
+            const response = await fetch(`/api/reservations/${reservationId}`, {
+                method: 'PATCH',
+                headers: { 'Content-Type': 'application/json' },
+                credentials: 'include',
+                body: JSON.stringify({
+                    tableId: newTableId,
+                    time: newTime,
+                    date: selectedDate,
+                    timezone: restaurantTimezone
+                })
+            });
+
+            if (!response.ok) throw new Error('Failed to move reservation');
+            return response.json();
+        },
+
+        onMutate: async (variables) => {
+            const { reservationId, newTableId, newTime } = variables;
+            await queryClient.cancelQueries({
+                queryKey: ["/api/tables/availability/schedule", selectedDate, restaurantTimezone]
+            });
+
+            const previousData = queryClient.getQueryData(["/api/tables/availability/schedule", selectedDate, restaurantTimezone]);
+            const durationInSlots = Math.ceil((restaurant?.avgReservationDuration || 120) / 60);
+
+            queryClient.setQueryData(["/api/tables/availability/schedule", selectedDate, restaurantTimezone], (old: any) => {
+                if (!old) return old;
+
+                let currentReservation: any = null;
+                let currentTableId: number = 0;
+                let currentTime: string = '';
+
+                for (const slot of old) {
+                    for (const table of slot.tables) {
+                        if (table.reservation?.id === reservationId) {
+                            currentReservation = table.reservation;
+                            currentTableId = table.id;
+                            currentTime = slot.time;
+                            break;
+                        }
+                    }
+                    if (currentReservation) break;
+                }
+
+                if (!currentReservation) return old;
+
+                const sourceHour = parseInt(currentTime.split(':')[0]);
+                const targetHour = parseInt(newTime.split(':')[0]);
+
+                const sourceSlots: string[] = [];
+                const targetSlots: string[] = [];
+
+                for (let i = 0; i < durationInSlots; i++) {
+                    sourceSlots.push(`${(sourceHour + i).toString().padStart(2, '0')}:00`);
+                    targetSlots.push(`${(targetHour + i).toString().padStart(2, '0')}:00`);
+                }
+
+                return old.map((slot: any) => ({
+                    ...slot,
+                    tables: slot.tables.map((table: any) => {
+                        if (table.id === currentTableId &&
+                            sourceSlots.includes(slot.time) &&
+                            table.reservation?.id === reservationId) {
+                            return {
+                                ...table,
+                                reservation: null,
+                                status: 'available'
+                            };
+                        }
+
+                        if (table.id === newTableId && targetSlots.includes(slot.time)) {
+                            return {
+                                ...table,
+                                status: 'reserved',
+                                reservation: {
+                                    ...currentReservation,
+                                    timeSlot: `${slot.time}-${targetSlots[targetSlots.length - 1]}`
+                                }
+                            };
+                        }
+
+                        return table;
+                    })
+                }));
+            });
+
+            return { previousData };
+        },
+
+        onSuccess: (data: any, variables) => {
+            const { newTableId, newTime } = variables;
+
+            const newTableName = scheduleData?.find(slot => slot.time === newTime)
+                ?.tables?.find((t: any) => t.id === newTableId)?.name || `Table ${newTableId}`;
+
+            toast({
+                title: "Reservation Updated",
+                description: `Reservation moved to ${newTime} (${newTableName})`,
+            });
+
+            queryClient.invalidateQueries({
+                queryKey: ["/api/reservations", restaurantTimezone]
+            });
+        },
+
+        onError: (error: any, variables, context) => {
+            if (context?.previousData) {
+                queryClient.setQueryData(
+                    ["/api/tables/availability/schedule", selectedDate, restaurantTimezone],
+                    context.previousData
+                );
+            }
+
+            toast({
+                title: "Failed to move reservation",
+                description: error.message || "Please try again",
+                variant: "destructive",
+            });
+        }
+    });
+
+    // Enhanced reservation cancellation with proper typing
+    const cancelReservationMutation = useMutation<any, Error, number, MutationContext>({
+        mutationFn: async (reservationId: number) => {
+            const response = await fetch(`/api/reservations/${reservationId}`, {
+                method: 'PATCH',
+                headers: { 'Content-Type': 'application/json' },
+                credentials: 'include',
+                body: JSON.stringify({
+                    status: 'canceled',
+                    timezone: restaurantTimezone
+                })
+            });
+            if (!response.ok) throw new Error('Failed to cancel reservation');
+            return response.json();
+        },
+
+        onMutate: async (reservationId: number) => {
+            await queryClient.cancelQueries({ queryKey: ["/api/tables/availability/schedule", selectedDate, restaurantTimezone] });
+
+            const previousData = queryClient.getQueryData(["/api/tables/availability/schedule", selectedDate, restaurantTimezone]);
+
+            queryClient.setQueryData(["/api/tables/availability/schedule", selectedDate, restaurantTimezone], (old: any) => {
+                if (!old) return old;
+
+                return old.map((slot: any) => ({
+                    ...slot,
+                    tables: slot.tables.map((table: any) => {
+                        if (table.reservation?.id === reservationId) {
+                            return {
+                                ...table,
+                                reservation: null,
+                                status: 'available'
+                            };
+                        }
+                        return table;
+                    })
+                }));
+            });
+
+            return { previousData };
+        },
+
+        onSuccess: () => {
+            setContextMenu(null);
+            toast({
+                title: "Reservation Cancelled",
+                description: "Successfully cancelled reservation.",
+            });
+        },
+
+        onError: (error, variables, context) => {
+            if (context?.previousData) {
+                queryClient.setQueryData(["/api/tables/availability/schedule", selectedDate, restaurantTimezone], context.previousData);
             }
-            
-            if (table.id === currentTable.id && targetSlots.includes(slot.time)) {
-              return {
-                ...table,
-                status: 'reserved',
-                reservation: {
-                  ...currentTable.reservation,
-                  timeSlot: `${targetSlots[0]}-${targetSlots[targetSlots.length - 1]}`
+            toast({
+                title: "Cancellation Failed",
+                description: "Could not cancel reservation. Please try again.",
+                variant: "destructive",
+            });
+        },
+    });
+
+    // Enhanced quick move with proper typing
+    const quickMoveMutation = useMutation<any, Error, { reservationId: number; direction: 'up' | 'down' }, MutationContext>({
+        mutationFn: async ({ reservationId, direction }) => {
+            const currentSlot = scheduleData?.find(slot =>
+                slot.tables.some((t: any) => t.reservation?.id === reservationId)
+            );
+            const currentTable = currentSlot?.tables.find((t: any) => t.reservation?.id === reservationId);
+
+            if (!currentSlot || !currentTable) throw new Error('Reservation not found');
+
+            const currentHour = parseInt(currentSlot.time.split(':')[0]);
+            const newHour = direction === 'up' ? currentHour - 1 : currentHour + 1;
+
+            const isOvernight = restaurant?.openingTime && restaurant?.closingTime &&
+                (parseInt(restaurant.closingTime.split(':')[0]) < parseInt(restaurant.openingTime.split(':')[0]));
+
+            if (isOvernight) {
+                const openingHour = parseInt(restaurant.openingTime.split(':')[0]);
+                const closingHour = parseInt(restaurant.closingTime.split(':')[0]);
+
+                if (direction === 'up' && newHour < 0) {
+                    throw new Error('Cannot move before midnight');
+                }
+                if (direction === 'down' && newHour >= 24) {
+                    throw new Error('Cannot move past 24:00');
+                }
+
+                const isValidHour = (newHour >= openingHour || newHour < closingHour);
+                if (!isValidHour) {
+                    throw new Error(`Cannot move outside operating hours (${restaurant.openingTime} - ${restaurant.closingTime})`);
+                }
+            } else {
+                const openingHour = parseInt(restaurant?.openingTime?.split(':')[0] || '10');
+                const closingHour = parseInt(restaurant?.closingTime?.split(':')[0] || '22');
+
+                if (newHour < openingHour || newHour > closingHour - 2) {
+                    throw new Error(`Cannot move outside business hours (${openingHour}:00 - ${closingHour - 2}:00)`);
                 }
-              };
             }
-            
-            return table;
-          })
-        }));
-      });
-      
-      return { previousData };
-    },
-    
-    onSuccess: (data, { direction }) => {
-      setContextMenu(null);
-      toast({
-        title: "Reservation Moved",
-        description: `Moved reservation ${direction === 'up' ? 'earlier' : 'later'} by 1 hour.`,
-      });
-    },
-    
-    onError: (error, variables, context) => {
-      if (context?.previousData) {
-        queryClient.setQueryData(["/api/tables/availability/schedule", selectedDate, restaurantTimezone], context.previousData);
-      }
-      toast({
-        title: "Move Failed",
-        description: error.message || "Could not move reservation. Check for conflicts.",
-        variant: "destructive",
-      });
-    },
-  });
-
-  // ✅ REMOVED: All manual drag-and-drop handlers
-  // - handleDragStart
-  // - handleDragOver
-  // - handleDragLeave
-  // - handleDrop
-  // - checkReservationConflict
-  // - isMovingWithinSameReservation
-
-  // Status colors for modern design with proper typing
-  const getStatusStyle = (status: string, hasReservation: boolean | undefined, isDragTarget = false) => {
-    if (isDragTarget) {
-      return "bg-gradient-to-br from-green-400 to-green-500 text-white shadow-lg shadow-green-400/50 ring-2 ring-green-300 scale-105";
-    }
-    
-    if (hasReservation) {
-      return "bg-gradient-to-br from-red-500 to-red-600 text-white shadow-lg shadow-red-500/25 cursor-grab active:cursor-grabbing";
-    }
-    
-    switch (status) {
-      case 'available':
-        return "bg-gradient-to-br from-green-500 to-green-600 text-white shadow-lg shadow-green-500/25 hover:shadow-green-500/40 transition-all duration-200";
-      case 'occupied':
-        return "bg-gradient-to-br from-orange-500 to-orange-600 text-white shadow-lg shadow-orange-500/25";
-      case 'reserved':
-        return "bg-gradient-to-br from-blue-500 to-blue-600 text-white shadow-lg shadow-blue-500/25";
-      case 'unavailable':
-        return "bg-gradient-to-br from-gray-400 to-gray-500 text-white shadow-lg shadow-gray-500/25";
-      default:
-        return "bg-gradient-to-br from-gray-300 to-gray-400 text-gray-800 shadow-lg shadow-gray-400/25";
-    }
-  };
 
-  // Enhanced form submission with validation
-  const handleAddTable = (e: React.FormEvent) => {
-    e.preventDefault();
-    
-    if (!addTableForm.name.trim()) {
-      toast({
-        title: "Table Name Required",
-        description: "Please enter a name for the table",
-        variant: "destructive",
-      });
-      return;
-    }
-    
-    if (addTableForm.minGuests < 1 || addTableForm.maxGuests < addTableForm.minGuests) {
-      toast({
-        title: "Invalid Capacity",
-        description: "Please ensure max guests is greater than or equal to min guests",
-        variant: "destructive",
-      });
-      return;
-    }
-    
-    if (addTableForm.maxGuests > 50) {
-      toast({
-        title: "Capacity Too Large",
-        description: "Maximum table capacity is 50 guests",
-        variant: "destructive",
-      });
-      return;
-    }
-    
-    console.log(`🏗️ [ModernTables] Submitting table creation form:`, addTableForm);
-    addTableMutation.mutate(addTableForm);
-  };
-
-  // Enhanced date formatting with timezone
-  const formatCurrentDate = () => {
-    try {
-      if (!restaurantTimezone || !selectedDate) {
-        return new Date().toLocaleDateString('en-US', { 
-          weekday: 'long', 
-          year: 'numeric', 
-          month: 'long', 
-          day: 'numeric' 
-        });
-      }
-      
-      const restaurantDateTime = DateTime.fromISO(selectedDate, { zone: restaurantTimezone });
-      return restaurantDateTime.toFormat('EEEE, MMMM d, yyyy');
-    } catch (error) {
-      console.error('Error formatting date:', error);
-      return new Date(selectedDate).toLocaleDateString('en-US', { 
-        weekday: 'long', 
-        year: 'numeric', 
-        month: 'long', 
-        day: 'numeric' 
-      });
-    }
-  };
+            const newTime = `${newHour.toString().padStart(2, '0')}:00`;
 
-  // Enhanced date navigation with timezone
-  const getTodayDateStr = () => {
-    return getRestaurantDateString(restaurantTimezone);
-  };
+            const targetSlots = [
+                newTime,
+                `${(newHour + 1).toString().padStart(2, '0')}:00`
+            ];
 
-  const getTomorrowDateStr = () => {
-    return getTomorrowDateString(restaurantTimezone);
-  };
+            for (const targetTime of targetSlots) {
+                const targetSlot = scheduleData?.find(s => s.time === targetTime);
+                const targetTable = targetSlot?.tables?.find((t: any) => t.id === currentTable.id);
 
-  // Show loading state while restaurant loads
-  if (restaurantLoading) {
-    return (
-      <DashboardLayout>
-        <div className="container mx-auto px-4 py-8">
-          <div className="flex items-center justify-center h-64">
-            <div className="flex items-center gap-3">
-              <RefreshCw className="h-6 w-6 animate-spin text-blue-600" />
-              <span className="text-lg text-gray-600">Loading restaurant profile...</span>
-            </div>
-          </div>
-        </div>
-      </DashboardLayout>
-    );
-  }
+                if (targetTable?.reservation && targetTable.reservation.id !== reservationId) {
+                    throw new Error(`Cannot move: ${targetTable.reservation.guestName} already has ${targetTime} reserved`);
+                }
+            }
 
-  // Show error state if restaurant fails to load
-  if (restaurantError || !restaurant) {
-    return (
-      <DashboardLayout>
-        <div className="container mx-auto px-4 py-8">
-          <div className="text-center py-12">
-            <h2 className="text-xl font-semibold text-red-600 mb-4">Unable to Load Restaurant</h2>
-            <p className="text-gray-600 mb-4">
-              {restaurantError ? (restaurantError as any).message : 'Restaurant profile not found'}
-            </p>
-            <Button onClick={() => window.location.reload()}>
-              <RefreshCw className="h-4 w-4 mr-2" />
-              Reload Page
-            </Button>
-          </div>
-        </div>
-      </DashboardLayout>
-    );
-  }
-
-  // Check if this is an overnight operation
-  const isOvernightOperation = restaurant?.openingTime && restaurant?.closingTime && 
-    (parseInt(restaurant.closingTime.split(':')[0]) < parseInt(restaurant.openingTime.split(':')[0]));
-
-  return (
-    <DashboardLayout>
-      <div className="container mx-auto px-4 py-8 space-y-8">
-        {/* Date Selection Panel */}
-        <Card className="border border-gray-200/50 dark:border-gray-700/50">
-          <CardHeader className="pb-4">
-            <div className="flex items-center justify-between">
-              <div className="flex items-center gap-2">
-                <Calendar className="h-5 w-5 text-blue-600" />
-                <CardTitle className="text-lg">Table Management</CardTitle>
-                <Badge variant="outline" className="text-xs">
-                  {restaurantTimezone}
-                </Badge>
-                {isOvernightOperation && (
-                  <Badge variant="outline" className="text-xs bg-blue-50 text-blue-700">
-                    <Clock className="h-3 w-3 mr-1" />
-                    24-Hour Operation
-                  </Badge>
-                )}
-              </div>
-              <div className="flex items-center gap-2">
-                {/* ✅ NEW: Live Status Indicator */}
-                {isConnected ? (
-                    <Badge variant="outline" className="border-green-500 text-green-700 bg-green-50">
-                        ● Live
-                    </Badge>
-                ) : (
-                    <Badge variant="destructive">● Disconnected</Badge>
-                )}
-                <Button 
-                  onClick={() => setShowAddTableModal(true)}
-                  className="bg-green-600 hover:bg-green-700 text-white"
-                  size="sm"
-                >
-                  <Plus className="h-4 w-4 mr-1" />
-                  Add Table
-                </Button>
-                <Button 
-                  variant="outline" 
-                  size="sm"
-                  onClick={() => setSelectedDate(getTodayDateStr())}
-                  className="text-xs"
-                  disabled={!restaurantTimezone}
-                >
-                  Today
-                </Button>
-                <Button 
-                  variant="outline" 
-                  size="sm"
-                  onClick={() => setSelectedDate(getTomorrowDateStr())}
-                  className="text-xs"
-                  disabled={!restaurantTimezone}
-                >
-                  Tomorrow
-                </Button>
-                <input
-                  type="date"
-                  value={selectedDate}
-                  onChange={(e) => setSelectedDate(e.target.value)}
-                  className="px-3 py-1 text-xs border border-gray-300 dark:border-gray-600 rounded-md dark:bg-gray-700 dark:text-white"
-                />
-              </div>
-            </div>
-          </CardHeader>
-        </Card>
-
-        {/* Table Statistics */}
-        {tablesLoading ? (
-          <Card className="bg-blue-50 border-blue-200">
-            <CardContent className="pt-4">
-              <div className="flex items-center justify-center h-16">
-                <RefreshCw className="h-5 w-5 animate-spin text-blue-600 mr-2" />
-                <span className="text-blue-700">Loading tables...</span>
-              </div>
-            </CardContent>
-          </Card>
-        ) : tables && Array.isArray(tables) && tables.length > 0 ? (
-          <Card className="bg-blue-50 border-blue-200">
-            <CardContent className="pt-4">
-              <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
-                <div className="text-center">
-                  <div className="text-2xl font-bold text-blue-600">{tables.length}</div>
-                  <div className="text-blue-700">Total Tables</div>
-                </div>
-                <div className="text-center">
-                  <div className="text-2xl font-bold text-blue-600">
-                    {tables.reduce((sum: number, table: any) => sum + table.maxGuests, 0)}
-                  </div>
-                  <div className="text-blue-700">Total Capacity</div>
-                </div>
-                <div className="text-center">
-                  <div className="text-2xl font-bold text-blue-600">
-                    {Math.round(tables.reduce((sum: number, table: any) => sum + table.maxGuests, 0) / tables.length)}
-                  </div>
-                  <div className="text-blue-700">Avg Table Size</div>
-                </div>
-                <div className="text-center">
-                  <div className="text-2xl font-bold text-blue-600">
-                    {Math.max(...tables.map((t: any) => t.maxGuests))}
-                  </div>
-                  <div className="text-blue-700">Largest Table</div>
-                </div>
-              </div>
-            </CardContent>
-          </Card>
-        ) : (
-          <Card className="bg-yellow-50 border-yellow-200">
-            <CardContent className="pt-4">
-              <div className="text-center py-8">
-                <Users className="h-12 w-12 text-yellow-600 mx-auto mb-4" />
-                <h3 className="text-lg font-semibold text-yellow-800 mb-2">No Tables Found</h3>
-                <p className="text-yellow-700 mb-4">
-                  Add tables to start managing reservations and table availability.
-                </p>
-                <Button 
-                  onClick={() => setShowAddTableModal(true)}
-                  className="bg-green-600 hover:bg-green-700 text-white"
-                >
-                  <Plus className="h-4 w-4 mr-2" />
-                  Add Your First Table
-                </Button>
-              </div>
-            </CardContent>
-          </Card>
-        )}
-
-        {/* Beautiful Schedule Grid */}
-        <div className="bg-gradient-to-br from-white to-gray-50 dark:from-gray-900 dark:to-gray-800 rounded-3xl shadow-2xl border border-gray-200/50 dark:border-gray-700/50 overflow-hidden">
-          <div className="p-6 border-b border-gray-200/50 dark:border-gray-700/50">
-            <div className="flex items-center justify-between">
-              <div>
-                <h3 className="text-xl font-bold text-gray-900 dark:text-white">
-                  Restaurant Management - {formatCurrentDate()}
-                </h3>
-                <p className="text-gray-500 dark:text-gray-400 mt-1">
-                  Real-time availability across all tables • Live updates via WebSocket
-                  <span className="ml-2 text-blue-600">
-                    • {restaurantTimezone}
-                  </span>
-                  {isOvernightOperation && (
-                    <span className="ml-2 text-purple-600">
-                      • 24-Hour Operation ({restaurant.openingTime}-{restaurant.closingTime})
-                    </span>
-                  )}
-                </p>
-              </div>
-              <div className="flex items-center gap-4">
-                {/* View Tabs */}
-                <div className="flex items-center bg-white dark:bg-gray-800 rounded-xl p-1 shadow-lg border border-gray-200/50 dark:border-gray-700/50">
-                  {[
-                    { id: 'schedule', label: 'Schedule', icon: Clock },
-                    { id: 'floorplan', label: 'Floor Plan', icon: Settings },
-                    { id: 'grid', label: 'Grid', icon: MousePointer2 },
-                    { id: 'list', label: 'List', icon: Edit2 }
-                  ].map(({ id, label, icon: Icon }) => (
-                    <button
-                      key={id}
-                      onClick={() => setActiveView(id as any)}
-                      className={`
-                        flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200
-                        ${activeView === id 
-                          ? 'bg-blue-600 text-white shadow-lg shadow-blue-500/25' 
-                          : 'text-gray-600 hover:text-gray-900 hover:bg-gray-100 dark:text-gray-400 dark:hover:text-gray-100 dark:hover:bg-gray-700'
+            const response = await fetch(`/api/reservations/${reservationId}`, {
+                method: 'PATCH',
+                headers: { 'Content-Type': 'application/json' },
+                credentials: 'include',
+                body: JSON.stringify({
+                    tableId: currentTable.id,
+                    time: newTime,
+                    date: selectedDate,
+                    timezone: restaurantTimezone
+                }),
+            });
+            if (!response.ok) throw new Error('Failed to move reservation');
+            return { response: response.json(), newTime, currentTable };
+        },
+
+        onMutate: async ({ reservationId, direction }) => {
+            await queryClient.cancelQueries({ queryKey: ["/api/tables/availability/schedule", selectedDate, restaurantTimezone] });
+
+            const previousData = queryClient.getQueryData(["/api/tables/availability/schedule", selectedDate, restaurantTimezone]);
+
+            const currentSlot = scheduleData?.find(slot =>
+                slot.tables.some((t: any) => t.reservation?.id === reservationId)
+            );
+            const currentTable = currentSlot?.tables.find((t: any) => t.reservation?.id === reservationId);
+
+            if (!currentSlot || !currentTable || !currentTable.reservation) return { previousData };
+
+            const currentHour = parseInt(currentSlot.time.split(':')[0]);
+            const targetHour = direction === 'up' ? currentHour - 1 : currentHour + 1;
+            const targetTime = `${targetHour.toString().padStart(2, '0')}:00`;
+
+            const durationInSlots = Math.ceil((restaurant?.avgReservationDuration || 120) / 60);
+
+            queryClient.setQueryData(["/api/tables/availability/schedule", selectedDate, restaurantTimezone], (old: any) => {
+                if (!old) return old;
+
+                const sourceSlots: string[] = [];
+                const targetSlots: string[] = [];
+
+                for (let i = 0; i < durationInSlots; i++) {
+                    sourceSlots.push(`${(currentHour + i).toString().padStart(2, '0')}:00`);
+                    targetSlots.push(`${(targetHour + i).toString().padStart(2, '0')}:00`);
+                }
+
+                return old.map((slot: any) => ({
+                    ...slot,
+                    tables: slot.tables.map((table: any) => {
+                        if (table.id === currentTable.id &&
+                            sourceSlots.includes(slot.time) &&
+                            table.reservation?.id === reservationId) {
+                            return {
+                                ...table,
+                                reservation: null,
+                                status: 'available'
+                            };
                         }
-                      `}
-                    >
-                      <Icon className="h-4 w-4" />
-                      {label}
-                    </button>
-                  ))}
-                </div>
 
-                {(isLoading || tablesLoading) && (
-                  <div className="flex items-center gap-2 text-sm text-muted-foreground">
-                    <RefreshCw className="h-4 w-4 animate-spin" />
-                    Loading...
-                  </div>
-                )}
-
-                {activeView === 'schedule' && (
-                  <Badge variant="outline" className="text-xs">
-                    {isOvernightOperation ? `${timeSlots.length} overnight slots` : 'Hourly slots'}
-                  </Badge>
-                )}
-              </div>
-            </div>
-          </div>
-
-        {/* Schedule View Content */}
-        <div className="p-6">
-          {activeView === 'schedule' && (
-            <>
-              {scheduleError ? (
-                <div className="text-center py-12">
-                  <p className="text-red-600 mb-4">
-                    Failed to load schedule: {(scheduleError as any).message}
-                  </p>
-                  {isOvernightOperation && (
-                    <p className="text-orange-600 mb-4 text-sm">
-                      Note: 24-hour operations may require additional setup time
-                    </p>
-                  )}
-                  <Button onClick={() => queryClient.refetchQueries({ 
-                    queryKey: ["/api/tables/availability/schedule", selectedDate, restaurantTimezone] 
-                  })}>
-                    <RefreshCw className="h-4 w-4 mr-2" />
-                    Retry
-                  </Button>
+                        if (table.id === currentTable.id && targetSlots.includes(slot.time)) {
+                            return {
+                                ...table,
+                                status: 'reserved',
+                                reservation: {
+                                    ...currentTable.reservation,
+                                    timeSlot: `${targetSlots[0]}-${targetSlots[targetSlots.length - 1]}`
+                                }
+                            };
+                        }
+
+                        return table;
+                    })
+                }));
+            });
+
+            return { previousData };
+        },
+
+        onSuccess: (data, { direction }) => {
+            setContextMenu(null);
+            toast({
+                title: "Reservation Moved",
+                description: `Moved reservation ${direction === 'up' ? 'earlier' : 'later'} by 1 hour.`,
+            });
+        },
+
+        onError: (error, variables, context) => {
+            if (context?.previousData) {
+                queryClient.setQueryData(["/api/tables/availability/schedule", selectedDate, restaurantTimezone], context.previousData);
+            }
+            toast({
+                title: "Move Failed",
+                description: error.message || "Could not move reservation. Check for conflicts.",
+                variant: "destructive",
+            });
+        },
+    });
+
+    // ✅ FIXED: Optimized status style function
+    const getStatusStyle = useCallback((status: string, hasReservation: boolean | undefined, isDragTarget = false) => {
+        if (isDragTarget) {
+            return "bg-gradient-to-br from-green-400 to-green-500 text-white shadow-lg shadow-green-400/50 ring-2 ring-green-300 scale-105";
+        }
+
+        if (hasReservation) {
+            return "bg-gradient-to-br from-red-500 to-red-600 text-white shadow-lg shadow-red-500/25 cursor-grab active:cursor-grabbing";
+        }
+
+        switch (status) {
+            case 'available':
+                return "bg-gradient-to-br from-green-500 to-green-600 text-white shadow-lg shadow-green-500/25 hover:shadow-green-500/40 transition-all duration-200";
+            case 'occupied':
+                return "bg-gradient-to-br from-orange-500 to-orange-600 text-white shadow-lg shadow-orange-500/25";
+            case 'reserved':
+                return "bg-gradient-to-br from-blue-500 to-blue-600 text-white shadow-lg shadow-blue-500/25";
+            case 'unavailable':
+                return "bg-gradient-to-br from-gray-400 to-gray-500 text-white shadow-lg shadow-gray-500/25";
+            default:
+                return "bg-gradient-to-br from-gray-300 to-gray-400 text-gray-800 shadow-lg shadow-gray-400/25";
+        }
+    }, []);
+
+    // Enhanced form submission to handle both Add and Edit
+    const handleTableFormSubmit = useCallback((e: React.FormEvent) => {
+        e.preventDefault();
+
+        if (!tableForm.name.trim() || !tableForm.floorId) {
+            toast({ title: "Missing Information", description: "Please enter a table name and select a floor.", variant: "destructive" });
+            return;
+        }
+
+        if (tableForm.minGuests < 1 || tableForm.maxGuests < tableForm.minGuests) {
+            toast({
+                title: "Invalid Capacity",
+                description: "Please ensure max guests is greater than or equal to min guests",
+                variant: "destructive",
+            });
+            return;
+        }
+
+        if (tableForm.maxGuests > 50) {
+            toast({
+                title: "Capacity Too Large",
+                description: "Maximum table capacity is 50 guests",
+                variant: "destructive",
+            });
+            return;
+        }
+
+        if (editingTable) {
+            editTableMutation.mutate(tableForm);
+        } else {
+            addTableMutation.mutate(tableForm);
+        }
+    }, [tableForm, editingTable, editTableMutation, addTableMutation, toast]);
+
+    // Enhanced date formatting with timezone
+    const formatCurrentDate = useCallback(() => {
+        try {
+            if (!restaurantTimezone || !selectedDate) {
+                return new Date().toLocaleDateString('en-US', {
+                    weekday: 'long',
+                    year: 'numeric',
+                    month: 'long',
+                    day: 'numeric'
+                });
+            }
+
+            const restaurantDateTime = DateTime.fromISO(selectedDate, { zone: restaurantTimezone });
+            return restaurantDateTime.toFormat('EEEE, MMMM d, yyyy');
+        } catch (error) {
+            console.error('Error formatting date:', error);
+            return new Date(selectedDate).toLocaleDateString('en-US', {
+                weekday: 'long',
+                year: 'numeric',
+                month: 'long',
+                day: 'numeric'
+            });
+        }
+    }, [restaurantTimezone, selectedDate]);
+
+    const getTodayDateStr = useCallback(() => {
+        return getRestaurantDateString(restaurantTimezone);
+    }, [restaurantTimezone]);
+
+    const getTomorrowDateStr = useCallback(() => {
+        return getTomorrowDateString(restaurantTimezone);
+    }, [restaurantTimezone]);
+
+    // ✅ FIXED: Stable header tables calculation
+    const headerTables = useMemo(() => {
+        if (!scheduleData || !Array.isArray(scheduleData) || scheduleData.length === 0) return [];
+        const firstSlotWithTables = scheduleData.find(slot => slot && slot.tables && slot.tables.length > 0);
+        return firstSlotWithTables ? firstSlotWithTables.tables : [];
+    }, [scheduleData]);
+
+    // Loading states
+    if (restaurantLoading) {
+        return (
+            <DashboardLayout>
+                <div className="container mx-auto px-4 py-8">
+                    <div className="flex items-center justify-center h-64">
+                        <div className="flex items-center gap-3">
+                            <RefreshCw className="h-6 w-6 animate-spin text-blue-600" />
+                            <span className="text-lg text-gray-600">Loading restaurant profile...</span>
+                        </div>
+                    </div>
                 </div>
-              ) : isLoading ? (
-                <div className="text-center py-12">
-                  <RefreshCw className="h-6 w-6 animate-spin text-blue-600 mx-auto mb-4" />
-                  <p className="text-gray-600">
-                    Loading {isOvernightOperation ? '24-hour' : 'schedule'} data...
-                  </p>
-                  {isOvernightOperation && (
-                    <p className="text-sm text-blue-600 mt-2">
-                      Processing {timeSlots.length} overnight time slots
-                    </p>
-                  )}
+            </DashboardLayout>
+        );
+    }
+
+    if (restaurantError || !restaurant) {
+        return (
+            <DashboardLayout>
+                <div className="container mx-auto px-4 py-8">
+                    <div className="text-center py-12">
+                        <h2 className="text-xl font-semibold text-red-600 mb-4">Unable to Load Restaurant</h2>
+                        <p className="text-gray-600 mb-4">
+                            {restaurantError ? (restaurantError as any).message : 'Restaurant profile not found'}
+                        </p>
+                        <Button onClick={() => window.location.reload()}>
+                            <RefreshCw className="h-4 w-4 mr-2" />
+                            Reload Page
+                        </Button>
+                    </div>
                 </div>
-              ) : scheduleData && scheduleData.length > 0 && scheduleData[0]?.tables?.length > 0 ? (
-                <DndContext onDragEnd={handleDragEnd}>
-                  <div className="overflow-x-auto">
-                    <div className="min-w-[800px]">
-                      {/* Sticky Header */}
-                      <div className="sticky top-0 bg-gradient-to-r from-gray-50 to-gray-100 dark:from-gray-800 dark:to-gray-750 border-b border-gray-200/50 dark:border-gray-700/50 px-4 py-2 z-10 rounded-lg mb-4">
-                        <div className="flex">
-                          <div className="w-20 flex-shrink-0 font-semibold text-gray-700 dark:text-gray-300 text-xs py-2">
-                            TIME
-                            {isOvernightOperation && (
-                              <div className="text-xs text-blue-600 mt-1">24h</div>
-                            )}
-                          </div>
-                          <div className="flex overflow-x-auto gap-1 flex-1">
-                            {scheduleData[0]?.tables?.map((table: TableData) => (
-                              <div key={table.id} className="w-24 flex-shrink-0 text-center bg-white/50 dark:bg-gray-700/50 rounded-lg p-1.5 border border-gray-200/50 dark:border-gray-600/50 relative group">
-                                <div className="font-medium text-xs text-gray-900 dark:text-gray-100">{table.name}</div>
-                                <div className="text-xs text-gray-500 dark:text-gray-400 flex items-center justify-center gap-1">
-                                  <Users className="h-3 w-3" />
-                                  {table.minGuests}-{table.maxGuests}
-                                </div>
+            </DashboardLayout>
+        );
+    }
+
+    const isOvernightOperation = restaurant?.openingTime && restaurant?.closingTime &&
+        (parseInt(restaurant.closingTime.split(':')[0]) < parseInt(restaurant.openingTime.split(':')[0]));
+
+    return (
+        <DashboardLayout>
+            <div className="container mx-auto px-4 py-8 space-y-8">
+                {/* Date Selection Panel */}
+                <Card className="border border-gray-200/50 dark:border-gray-700/50">
+                    <CardHeader className="pb-4">
+                        <div className="flex items-center justify-between">
+                            <div className="flex items-center gap-2">
+                                <Calendar className="h-5 w-5 text-blue-600" />
+                                <CardTitle className="text-lg">Table Management</CardTitle>
+                                <Badge variant="outline" className="text-xs">
+                                    {restaurantTimezone}
+                                </Badge>
+                                {isOvernightOperation && (
+                                    <Badge variant="outline" className="text-xs bg-blue-50 text-blue-700">
+                                        <Clock className="h-3 w-3 mr-1" />
+                                        24-Hour Operation
+                                    </Badge>
+                                )}
+                            </div>
+                            <div className="flex items-center gap-2">
+                                {/* ✅ FIXED: Simple connection status display */}
+                                <Badge variant={isConnected ? "outline" : "destructive"} className={isConnected ? "border-green-500 text-green-700 bg-green-50" : ""}>
+                                    ● {isConnected ? "Connected" : "Disconnected"}
+                                </Badge>
                                 <Button
-                                  variant="destructive"
-                                  size="sm"
-                                  onClick={() => {
-                                    if (confirm(`Delete table ${table.name}? This cannot be undone.`)) {
-                                      deleteTableMutation.mutate(table.id);
-                                    }
-                                  }}
-                                  className="absolute -top-2 -right-2 h-6 w-6 p-0 opacity-0 group-hover:opacity-100 transition-opacity"
+                                    onClick={handleOpenAddModal}
+                                    className="bg-green-600 hover:bg-green-700 text-white"
+                                    size="sm"
                                 >
-                                  <X className="h-3 w-3" />
+                                    <Plus className="h-4 w-4 mr-1" />
+                                    Add Table
                                 </Button>
-                              </div>
-                            ))}
-                          </div>
+
+                                <Button
+                                    variant="outline"
+                                    size="sm"
+                                    onClick={() => setSelectedDate(getTodayDateStr())}
+                                    className="text-xs"
+                                    disabled={!restaurantTimezone}
+                                >
+                                    Today
+                                </Button>
+                                <Button
+                                    variant="outline"
+                                    size="sm"
+                                    onClick={() => setSelectedDate(getTomorrowDateStr())}
+                                    className="text-xs"
+                                    disabled={!restaurantTimezone}
+                                >
+                                    Tomorrow
+                                </Button>
+                                <input
+                                    type="date"
+                                    value={selectedDate}
+                                    onChange={(e) => setSelectedDate(e.target.value)}
+                                    className="px-3 py-1 text-xs border border-gray-300 dark:border-gray-600 rounded-md dark:bg-gray-700 dark:text-white"
+                                />
+                            </div>
                         </div>
-                      </div>
-
-                      {/* Time Slots with overnight operation visual cues */}
-                      <div className="space-y-1">
-                        {scheduleData?.map((slot: ScheduleSlot) => {
-                          const hour = parseInt(slot.time.split(':')[0]);
-                          const isEarlyMorning = isOvernightOperation && hour < 6;
-                          const isLateNight = isOvernightOperation && hour >= 22;
-                          
-                          return (
-                            <div 
-                              key={slot.time} 
-                              className={cn(
-                                "flex hover:bg-gray-50/50 dark:hover:bg-gray-800/50 rounded-lg transition-colors duration-200",
-                                isEarlyMorning && "bg-blue-50/30",
-                                isLateNight && "bg-purple-50/30"
-                              )}
-                            >
-                              <div className={cn(
-                                "w-20 flex-shrink-0 px-4 py-3 text-sm font-medium border-r border-gray-200/50 dark:border-gray-700/50",
-                                isEarlyMorning && "text-blue-700 dark:text-blue-300",
-                                isLateNight && "text-purple-700 dark:text-purple-300",
-                                !isEarlyMorning && !isLateNight && "text-gray-700 dark:text-gray-300"
-                              )}>
-                                {slot.time}
-                                {isOvernightOperation && (
-                                  <div className="text-xs opacity-60">
-                                    {isEarlyMorning ? "Early" : isLateNight ? "Night" : "Day"}
-                                  </div>
-                                )}
-                              </div>
-                              <div className="flex overflow-x-auto gap-1 flex-1 px-2 py-1">
-                                {slot.tables?.map((table: TableData) => {
-                                  const hasReservation = table.reservation && table.reservation.status === 'confirmed';
-                                  const uniqueSlotId = `${table.id}-${slot.time}`; // Unique ID for the droppable area
-                                  
-                                  return (
-                                    <div
-                                      key={table.id}
-                                      className={cn(
-                                        "w-24 flex-shrink-0 rounded-lg p-2 text-center transition-all duration-200",
-                                        getStatusStyle(table.status, hasReservation),
-                                        !hasReservation && "hover:scale-105"
-                                      )}
-                                      onContextMenu={(e) => {
-                                        e.preventDefault();
-                                        setContextMenu({
-                                          x: e.clientX,
-                                          y: e.clientY,
-                                          reservationId: hasReservation ? table.reservation?.id : undefined,
-                                          tableId: table.id,
-                                          timeSlot: slot.time,
-                                          guestName: hasReservation ? table.reservation?.guestName : undefined,
-                                        });
-                                      }}
+                    </CardHeader>
+                </Card>
+
+                {/* Table Statistics - memoized */}
+                {useMemo(() => {
+                    if (tablesLoading) {
+                        return (
+                            <Card className="bg-blue-50 border-blue-200">
+                                <CardContent className="pt-4">
+                                    <div className="flex items-center justify-center h-16">
+                                        <RefreshCw className="h-5 w-5 animate-spin text-blue-600 mr-2" />
+                                        <span className="text-blue-700">Loading tables...</span>
+                                    </div>
+                                </CardContent>
+                            </Card>
+                        );
+                    }
+                    
+                    if (tables && Array.isArray(tables) && tables.length > 0) {
+                        return (
+                            <Card className="bg-blue-50 border-blue-200">
+                                <CardContent className="pt-4">
+                                    <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
+                                        <div className="text-center">
+                                            <div className="text-2xl font-bold text-blue-600">{tables.length}</div>
+                                            <div className="text-blue-700">Total Tables</div>
+                                        </div>
+                                        <div className="text-center">
+                                            <div className="text-2xl font-bold text-blue-600">
+                                                {tables.reduce((sum: number, table: any) => sum + table.maxGuests, 0)}
+                                            </div>
+                                            <div className="text-blue-700">Total Capacity</div>
+                                        </div>
+                                        <div className="text-center">
+                                            <div className="text-2xl font-bold text-blue-600">
+                                                {Math.round(tables.reduce((sum: number, table: any) => sum + table.maxGuests, 0) / tables.length)}
+                                            </div>
+                                            <div className="text-blue-700">Avg Table Size</div>
+                                        </div>
+                                        <div className="text-center">
+                                            <div className="text-2xl font-bold text-blue-600">
+                                                {Math.max(...tables.map((t: any) => t.maxGuests))}
+                                            </div>
+                                            <div className="text-blue-700">Largest Table</div>
+                                        </div>
+                                    </div>
+                                </CardContent>
+                            </Card>
+                        );
+                    }
+                    
+                    return (
+                        <Card className="bg-yellow-50 border-yellow-200">
+                            <CardContent className="pt-4">
+                                <div className="text-center py-8">
+                                    <Users className="h-12 w-12 text-yellow-600 mx-auto mb-4" />
+                                    <h3 className="text-lg font-semibold text-yellow-800 mb-2">No Tables Found</h3>
+                                    <p className="text-yellow-700 mb-4">
+                                        Add tables to start managing reservations and table availability.
+                                    </p>
+                                    <Button
+                                        onClick={handleOpenAddModal}
+                                        className="bg-green-600 hover:bg-green-700 text-white"
                                     >
-                                      {/* ✅ NEW: Use DraggableReservation and DroppableSlot components */}
-                                      {hasReservation && table.reservation ? (
-                                        <DraggableReservation 
-                                          id={table.reservation.id} 
-                                          data={{
-                                            guestName: table.reservation.guestName,
-                                            guestCount: table.reservation.guestCount,
-                                          }}
-                                        >
-                                          {/* The content of the reservation card */}
-                                          <div className="text-xs font-bold opacity-90 flex items-center justify-center gap-1 cursor-grab active:cursor-grabbing">
-                                            <Move className="h-3 w-3" />
-                                            {table.name}
-                                          </div>
-                                          <div className="text-xs opacity-75 mt-1 truncate">
-                                            {table.reservation.guestName}
-                                          </div>
-                                          <div className="text-xs opacity-60 mt-1">
-                                            {`${table.reservation.guestCount} guests`}
-                                          </div>
-                                        </DraggableReservation>
-                                      ) : (
-                                        <DroppableSlot 
-                                          id={uniqueSlotId}
-                                          data={{ tableId: table.id, time: slot.time, table: table }}
+                                        <Plus className="h-4 w-4 mr-2" />
+                                        Add Your First Table
+                                    </Button>
+                                </div>
+                            </CardContent>
+                        </Card>
+                    );
+                }, [tablesLoading, tables, handleOpenAddModal])}
+
+                {/* Main content area */}
+                <div className="bg-gradient-to-br from-white to-gray-50 dark:from-gray-900 dark:to-gray-800 rounded-3xl shadow-2xl border border-gray-200/50 dark:border-gray-700/50 overflow-hidden">
+                    <div className="p-6 border-b border-gray-200/50 dark:border-gray-700/50">
+                        <div className="flex items-center justify-between">
+                            <div>
+                                <h3 className="text-xl font-bold text-gray-900 dark:text-white">
+                                    Restaurant Management - {formatCurrentDate()}
+                                </h3>
+                                <p className="text-gray-500 dark:text-gray-400 mt-1">
+                                    Real-time availability across all tables • Live updates via WebSocket
+                                    <span className="ml-2 text-blue-600">
+                                        • {restaurantTimezone}
+                                    </span>
+                                    {isOvernightOperation && (
+                                        <span className="ml-2 text-purple-600">
+                                            • 24-Hour Operation ({restaurant.openingTime}-{restaurant.closingTime})
+                                        </span>
+                                    )}
+                                </p>
+                            </div>
+                            <div className="flex items-center gap-4">
+                                <div className="flex items-center bg-white dark:bg-gray-800 rounded-xl p-1 shadow-lg border border-gray-200/50 dark:border-gray-700/50">
+                                    {[
+                                        { id: 'schedule', label: 'Schedule', icon: Clock },
+                                        { id: 'floorplan', label: 'Floor Plan', icon: Settings },
+                                        { id: 'grid', label: 'Grid', icon: MousePointer2 },
+                                        { id: 'list', label: 'List', icon: Edit2 }
+                                    ].map(({ id, label, icon: Icon }) => (
+                                        <button
+                                            key={id}
+                                            onClick={(e) => {
+                                                try {
+                                                    e.preventDefault();
+                                                    setActiveView(id as any);
+                                                } catch (error) {
+                                                    console.error(`[ModernTables] Error switching to view ${id}:`, error);
+                                                }
+                                            }}
+                                            className={`
+                        flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200
+                        ${activeView === id
+                                                    ? 'bg-blue-600 text-white shadow-lg shadow-blue-500/25'
+                                                    : 'text-gray-600 hover:text-gray-900 hover:bg-gray-100 dark:text-gray-400 dark:hover:text-gray-100 dark:hover:bg-gray-700'
+                                                }
+                      `}
                                         >
-                                          {/* The content of an empty, droppable slot */}
-                                          <div className="h-full flex flex-col justify-center">
-                                            <div className="text-xs font-bold opacity-90">{table.name}</div>
-                                            <div className="text-xs opacity-60 mt-1">{table.status}</div>
-                                          </div>
-                                        </DroppableSlot>
-                                      )}
+                                            <Icon className="h-4 w-4" />
+                                            {label}
+                                        </button>
+                                    ))}
+                                </div>
+
+                                {(isLoading || tablesLoading || !dndLoaded) && (
+                                    <div className="flex items-center gap-2 text-sm text-muted-foreground">
+                                        <RefreshCw className="h-4 w-4 animate-spin" />
+                                        Loading{!dndLoaded ? ' components' : ''}...
                                     </div>
-                                  );
-                                })}
-                              </div>
+                                )}
+
+                                {activeView === 'schedule' && (
+                                    <Badge variant="outline" className="text-xs">
+                                        {isOvernightOperation ? `${timeSlots.length} overnight slots` : 'Hourly slots'}
+                                    </Badge>
+                                )}
                             </div>
-                          );
-                        })}
-                      </div>
+                        </div>
+                    </div>
+
+                    <div className="p-6">
+                        {activeView === 'schedule' && (
+                            <>
+                                {scheduleError ? (
+                                    <div className="text-center py-12">
+                                        <p className="text-red-600 mb-4">
+                                            Failed to load schedule: {(scheduleError as any).message}
+                                        </p>
+                                        {isOvernightOperation && (
+                                            <p className="text-orange-600 mb-4 text-sm">
+                                                Note: 24-hour operations may require additional setup time
+                                            </p>
+                                        )}
+                                        <Button onClick={() => queryClient.refetchQueries({
+                                            queryKey: ["/api/tables/availability/schedule", selectedDate, restaurantTimezone]
+                                        })}>
+                                            <RefreshCw className="h-4 w-4 mr-2" />
+                                            Retry
+                                        </Button>
+                                    </div>
+                                ) : isLoading ? (
+                                    <div className="text-center py-12">
+                                        <RefreshCw className="h-6 w-6 animate-spin text-blue-600 mx-auto mb-4" />
+                                        <p className="text-gray-600">
+                                            Loading {isOvernightOperation ? '24-hour' : 'schedule'} data...
+                                        </p>
+                                        {isOvernightOperation && (
+                                            <p className="text-sm text-blue-600 mt-2">
+                                                Processing {timeSlots.length} overnight time slots
+                                            </p>
+                                        )}
+                                    </div>
+                                ) : scheduleData && scheduleData.length > 0 && headerTables.length > 0 && dndLoaded ? (
+                                    <StableDndContext onDragEnd={handleDragEnd}>
+                                        <div className="overflow-x-auto">
+                                            <div className="min-w-[800px]">
+                                                <div className="sticky top-0 bg-gradient-to-r from-gray-50 to-gray-100 dark:from-gray-800 dark:to-gray-750 border-b border-gray-200/50 dark:border-gray-700/50 px-4 py-2 z-10 rounded-lg mb-4">
+                                                    <div className="flex">
+                                                        <div className="w-20 flex-shrink-0 font-semibold text-gray-700 dark:text-gray-300 text-xs py-2">
+                                                            TIME
+                                                            {isOvernightOperation && (
+                                                                <div className="text-xs text-blue-600 mt-1">24h</div>
+                                                            )}
+                                                        </div>
+                                                        <div className="flex overflow-x-auto gap-1 flex-1">
+                                                            {headerTables.map((table: TableData) => (
+                                                                <div key={table.id} className="w-24 flex-shrink-0 text-center bg-white/50 dark:bg-gray-700/50 rounded-lg p-1.5 border border-gray-200/50 dark:border-gray-600/50 relative group">
+                                                                    <div className="font-medium text-xs text-gray-900 dark:text-gray-100">{table.name}</div>
+                                                                    {table.floor?.name && (
+                                                                        <div className="text-[10px] text-blue-600 dark:text-blue-400 truncate" title={table.floor.name}>
+                                                                            {table.floor.name}
+                                                                        </div>
+                                                                    )}
+                                                                    <div className="text-xs text-gray-500 dark:text-gray-400 flex items-center justify-center gap-1">
+                                                                        <Users className="h-3 w-3" />
+                                                                        {table.minGuests}-{table.maxGuests}
+                                                                    </div>
+                                                                    <div className="absolute -top-2 -right-2 opacity-0 group-hover:opacity-100 transition-opacity">
+                                                                        <DropdownMenu>
+                                                                            <DropdownMenuTrigger asChild>
+                                                                                <Button variant="secondary" size="sm" className="h-6 w-6 p-0">
+                                                                                    <MoreHorizontal className="h-4 w-4" />
+                                                                                </Button>
+                                                                            </DropdownMenuTrigger>
+                                                                            <DropdownMenuContent align="end">
+                                                                                <DropdownMenuItem onClick={() => handleOpenEditModal(table)}>
+                                                                                    <Edit2 className="mr-2 h-4 w-4" />
+                                                                                    <span>Edit</span>
+                                                                                </DropdownMenuItem>
+                                                                                <DropdownMenuSeparator />
+                                                                                <DropdownMenuItem
+                                                                                    className="text-red-600 focus:text-red-600 focus:bg-red-50"
+                                                                                    onClick={() => {
+                                                                                        if (confirm(`Delete table "${table.name}"? This cannot be undone.`)) {
+                                                                                            deleteTableMutation.mutate(table.id);
+                                                                                        }
+                                                                                    }}
+                                                                                >
+                                                                                    <Trash2 className="mr-2 h-4 w-4" />
+                                                                                    <span>Delete</span>
+                                                                                </DropdownMenuItem>
+                                                                            </DropdownMenuContent>
+                                                                        </DropdownMenu>
+                                                                    </div>
+                                                                </div>
+                                                            ))}
+                                                        </div>
+                                                    </div>
+                                                </div>
+
+                                                <div className="space-y-1">
+                                                    {scheduleData?.map((slot: ScheduleSlot) => {
+                                                        const hour = parseInt(slot.time.split(':')[0]);
+                                                        const isEarlyMorning = isOvernightOperation && hour < 6;
+                                                        const isLateNight = isOvernightOperation && hour >= 22;
+
+                                                        return (
+                                                            <div
+                                                                key={slot.time}
+                                                                className={cn(
+                                                                    "flex hover:bg-gray-50/50 dark:hover:bg-gray-800/50 rounded-lg transition-colors duration-200",
+                                                                    isEarlyMorning && "bg-blue-50/30",
+                                                                    isLateNight && "bg-purple-50/30"
+                                                                )}
+                                                            >
+                                                                <div className={cn(
+                                                                    "w-20 flex-shrink-0 px-4 py-3 text-sm font-medium border-r border-gray-200/50 dark:border-gray-700/50",
+                                                                    isEarlyMorning && "text-blue-700 dark:text-blue-300",
+                                                                    isLateNight && "text-purple-700 dark:text-purple-300",
+                                                                    !isEarlyMorning && !isLateNight && "text-gray-700 dark:text-gray-300"
+                                                                )}>
+                                                                    {slot.time}
+                                                                    {isOvernightOperation && (
+                                                                        <div className="text-xs opacity-60">
+                                                                            {isEarlyMorning ? "Early" : isLateNight ? "Night" : "Day"}
+                                                                        </div>
+                                                                    )}
+                                                                </div>
+                                                                <div className="flex overflow-x-auto gap-1 flex-1 px-2 py-1">
+                                                                    {slot.tables?.map((table: TableData) => {
+                                                                        const hasReservation = table.reservation && table.reservation.status === 'confirmed';
+                                                                        const uniqueSlotId = `${table.id}-${slot.time}`;
+
+                                                                        return (
+                                                                            <div
+                                                                                key={table.id}
+                                                                                className={cn(
+                                                                                    "w-24 flex-shrink-0 rounded-lg p-2 text-center transition-all duration-200",
+                                                                                    getStatusStyle(table.status, hasReservation),
+                                                                                    !hasReservation && "hover:scale-105"
+                                                                                )}
+                                                                                onContextMenu={(e) => {
+                                                                                    e.preventDefault();
+                                                                                    setContextMenu({
+                                                                                        x: e.clientX,
+                                                                                        y: e.clientY,
+                                                                                        reservationId: hasReservation ? table.reservation?.id : undefined,
+                                                                                        tableId: table.id,
+                                                                                        timeSlot: slot.time,
+                                                                                        guestName: hasReservation ? table.reservation?.guestName : undefined,
+                                                                                    });
+                                                                                }}
+                                                                            >
+                                                                                {hasReservation && table.reservation ? (
+                                                                                    <StableDraggableReservation
+                                                                                        id={table.reservation.id}
+                                                                                        data={{
+                                                                                            guestName: table.reservation.guestName,
+                                                                                            guestCount: table.reservation.guestCount,
+                                                                                        }}
+                                                                                    >
+                                                                                        <div className="text-xs font-bold opacity-90 flex items-center justify-center gap-1 cursor-grab active:cursor-grabbing">
+                                                                                            <Move className="h-3 w-3" />
+                                                                                            {table.name}
+                                                                                        </div>
+                                                                                        <div className="text-xs opacity-75 mt-1 truncate">
+                                                                                            {table.reservation.guestName}
+                                                                                        </div>
+                                                                                        <div className="text-xs opacity-60 mt-1">
+                                                                                            {`${table.reservation.guestCount} guests`}
+                                                                                        </div>
+                                                                                    </StableDraggableReservation>
+                                                                                ) : (
+                                                                                    <StableDroppableSlot
+                                                                                        id={uniqueSlotId}
+                                                                                        data={{ tableId: table.id, time: slot.time, table: table }}
+                                                                                    >
+                                                                                        <div className="h-full flex flex-col justify-center">
+                                                                                            <div className="text-xs font-bold opacity-90">{table.name}</div>
+                                                                                            <div className="text-xs opacity-60 mt-1">{table.status}</div>
+                                                                                        </div>
+                                                                                    </StableDroppableSlot>
+                                                                                )}
+                                                                            </div>
+                                                                        );
+                                                                    })}
+                                                                </div>
+                                                            </div>
+                                                        );
+                                                    })}
+                                                </div>
+                                            </div>
+                                        </div>
+                                    </StableDndContext>
+                                ) : (
+                                    <div className="text-center py-12">
+                                        <Users className="h-12 w-12 text-gray-400 mx-auto mb-4" />
+                                        <h3 className="text-lg font-semibold text-gray-600 mb-2">
+                                            {!dndLoaded ? "Loading Components..." : "No Tables Available"}
+                                        </h3>
+                                        <p className="text-gray-500 mb-4">
+                                            {!dndLoaded 
+                                                ? "Please wait while we load the drag & drop functionality..." 
+                                                : "Add tables to start managing reservations and viewing table availability."
+                                            }
+                                        </p>
+                                        {dndLoaded && (
+                                            <Button
+                                                onClick={handleOpenAddModal}
+                                                className="bg-green-600 hover:bg-green-700 text-white"
+                                            >
+                                                <Plus className="h-4 w-4 mr-2" />
+                                                Add Your First Table
+                                            </Button>
+                                        )}
+                                    </div>
+                                )}
+                            </>
+                        )}
+
+                        {/* Floor plan view */}
+                        {activeView === 'floorplan' && (
+                            <ErrorBoundary fallback={<FloorPlanViewFallback floors={floors || []} isLoading={floorsLoading} isManageFloorsOpen={isManageFloorsOpen} setIsManageFloorsOpen={setIsManageFloorsOpen} />}>
+                                <Suspense fallback={
+                                    <div className="flex items-center justify-center h-64">
+                                        <RefreshCw className="h-6 w-6 animate-spin text-blue-600 mr-2" />
+                                        <span>Loading Floor Plan...</span>
+                                    </div>
+                                }>
+                                    <FloorPlanView
+                                        floors={floors || []}
+                                        isLoading={floorsLoading}
+                                        isManageFloorsOpen={isManageFloorsOpen}
+                                        setIsManageFloorsOpen={setIsManageFloorsOpen}
+                                    />
+                                </Suspense>
+                            </ErrorBoundary>
+                        )}
+
+                        {activeView !== 'schedule' && activeView !== 'floorplan' && (
+                            <div className="text-center py-12">
+                                <p className="text-gray-500 dark:text-gray-400">
+                                    {activeView} view coming soon...
+                                </p>
+                            </div>
+                        )}
                     </div>
-                  </div>
-                </DndContext>
-              ) : (
-                <div className="text-center py-12">
-                  <Users className="h-12 w-12 text-gray-400 mx-auto mb-4" />
-                  <h3 className="text-lg font-semibold text-gray-600 mb-2">No Tables Available</h3>
-                  <p className="text-gray-500 mb-4">
-                    Add tables to start managing reservations and viewing table availability.
-                  </p>
-                  {isOvernightOperation && (
-                    <p className="text-sm text-blue-600 mb-4">
-                      24-hour operation detected ({restaurant.openingTime}-{restaurant.closingTime})
-                    </p>
-                  )}
-                  <Button 
-                    onClick={() => setShowAddTableModal(true)}
-                    className="bg-green-600 hover:bg-green-700 text-white"
-                  >
-                    <Plus className="h-4 w-4 mr-2" />
-                    Add Your First Table
-                  </Button>
                 </div>
-              )}
-            </>
-          )}
-
-          {/* Other Views Placeholder */}
-          {activeView !== 'schedule' && (
-            <div className="text-center py-12">
-              <p className="text-gray-500 dark:text-gray-400">
-                {activeView} view coming soon...
-              </p>
-            </div>
-          )}
-        </div>
-      </div>
-      </div>
-
-      {/* Enhanced Add Table Modal */}
-      <Dialog open={showAddTableModal} onOpenChange={setShowAddTableModal}>
-        <DialogContent className="max-w-md">
-          <DialogHeader>
-            <DialogTitle>Add New Table</DialogTitle>
-            <DialogDescription>
-              Create a new table for your restaurant. You can edit these details later.
-              {isOvernightOperation && (
-                <span className="block mt-2 text-blue-600 text-sm">
-                  🌙 24-hour operation detected - table will be available around the clock
-                </span>
-              )}
-            </DialogDescription>
-          </DialogHeader>
-          
-          <form onSubmit={handleAddTable} className="space-y-4">
-            <div>
-              <Label htmlFor="tableName">Table Name *</Label>
-              <Input
-                id="tableName"
-                value={addTableForm.name}
-                onChange={(e) => setAddTableForm(prev => ({ ...prev, name: e.target.value }))}
-                placeholder="e.g. Table 1, Corner Table, Patio A"
-                required
-                maxLength={50}
-              />
-            </div>
-            
-            <div className="grid grid-cols-2 gap-4">
-              <div>
-                <Label htmlFor="minGuests">Min Guests *</Label>
-                <Input
-                  id="minGuests"
-                  type="number"
-                  min="1"
-                  max="20"
-                  value={addTableForm.minGuests}
-                  onChange={(e) => setAddTableForm(prev => ({ ...prev, minGuests: parseInt(e.target.value) || 1 }))}
-                  required
-                />
-              </div>
-              
-              <div>
-                <Label htmlFor="maxGuests">Max Guests *</Label>
-                <Input
-                  id="maxGuests"
-                  type="number"
-                  min="1"
-                  max="50"
-                  value={addTableForm.maxGuests}
-                  onChange={(e) => setAddTableForm(prev => ({ ...prev, maxGuests: parseInt(e.target.value) || 4 }))}
-                  required
-                />
-              </div>
-            </div>
-            
-            <div>
-              <Label htmlFor="features">Features (Optional)</Label>
-              <Input
-                id="features"
-                value={addTableForm.features}
-                onChange={(e) => setAddTableForm(prev => ({ ...prev, features: e.target.value }))}
-                placeholder="e.g. Window view, Outdoor, Private"
-                maxLength={200}
-              />
-            </div>
-            
-            <div>
-              <Label htmlFor="comments">Comments (Optional)</Label>
-              <Textarea
-                id="comments"
-                value={addTableForm.comments}
-                onChange={(e) => setAddTableForm(prev => ({ ...prev, comments: e.target.value }))}
-                placeholder="Any additional notes about this table"
-                rows={2}
-                maxLength={500}
-              />
             </div>
-            
-            <div className="flex justify-end space-x-2 pt-4">
-              <Button 
-                type="button" 
-                variant="outline" 
-                onClick={() => setShowAddTableModal(false)}
-                disabled={addTableMutation.isPending}
-              >
-                Cancel
-              </Button>
-              <Button 
-                type="submit" 
-                disabled={addTableMutation.isPending}
-                className="bg-green-600 hover:bg-green-700 text-white"
-              >
-                {addTableMutation.isPending ? (
-                  <>
-                    <RefreshCw className="h-4 w-4 mr-2 animate-spin" />
-                    Adding...
-                  </>
-                ) : (
-                  <>
-                    <Save className="h-4 w-4 mr-2" />
-                    Add Table
-                  </>
-                )}
-              </Button>
-            </div>
-          </form>
-        </DialogContent>
-      </Dialog>
-
-      {/* Context Menu */}
-      {contextMenu && (
-        <>
-          <div 
-            className="fixed inset-0 z-40" 
-            onClick={() => setContextMenu(null)}
-          />
-          <div
-            className="fixed z-50 bg-white border border-gray-200 rounded-md shadow-lg py-1 min-w-[180px]"
-            style={{ left: contextMenu.x, top: contextMenu.y }}
-          >
-            {contextMenu.reservationId ? (
-              <>
-                <div className="px-3 py-2 text-sm font-medium text-gray-900 border-b">
-                  {contextMenu.guestName || 'Reservation'}
-                </div>
-                <button
-                  className="w-full px-3 py-2 text-sm text-left hover:bg-gray-100 flex items-center gap-2"
-                  onClick={() => quickMoveMutation.mutate({ reservationId: contextMenu.reservationId!, direction: 'up' })}
-                >
-                  <ArrowUp className="w-4 h-4" />
-                  Move 1 Hour Earlier
-                </button>
-                <button
-                  className="w-full px-3 py-2 text-sm text-left hover:bg-gray-100 flex items-center gap-2"
-                  onClick={() => quickMoveMutation.mutate({ reservationId: contextMenu.reservationId!, direction: 'down' })}
-                >
-                  <ArrowDown className="w-4 h-4" />
-                  Move 1 Hour Later
-                </button>
-                <button
-                  className="w-full px-3 py-2 text-sm text-left hover:bg-gray-100 flex items-center gap-2"
-                  onClick={() => {
-                    setContextMenu(null);
-                    toast({ title: "Edit Feature", description: "Edit reservation feature coming soon!" });
-                  }}
-                >
-                  <Edit2 className="w-4 h-4" />
-                  Edit Details
-                </button>
-                <div className="border-t my-1" />
-                <button
-                  className="w-full px-3 py-2 text-sm text-left hover:bg-red-50 text-red-600 flex items-center gap-2"
-                  onClick={() => cancelReservationMutation.mutate(contextMenu.reservationId!)}
-                >
-                  <Trash2 className="w-4 h-4" />
-                  Cancel Reservation
-                </button>
-              </>
-            ) : (
-              <>
-                <div className="px-3 py-2 text-sm font-medium text-gray-900 border-b">
-                  Available Slot
-                </div>
-                <button
-                  className="w-full px-3 py-2 text-sm text-left hover:bg-gray-100 flex items-center gap-2"
-                  onClick={() => {
-                    setContextMenu(null);
-                    toast({ title: "Create Feature", description: "Create new reservation feature coming soon!" });
-                  }}
-                >
-                  <UserPlus className="w-4 h-4" />
-                  Create New Reservation
-                </button>
-              </>
+
+            {/* Add/Edit Table Modal */}
+            <Dialog open={showTableModal} onOpenChange={setShowTableModal}>
+                <DialogContent className="max-w-md">
+                    <DialogHeader>
+                        <DialogTitle>{editingTable ? 'Edit Table' : 'Add New Table'}</DialogTitle>
+                        <DialogDescription>
+                            {editingTable ? `Update the details for table "${editingTable.name}".` : 'Create a new table for your restaurant.'}
+                        </DialogDescription>
+                    </DialogHeader>
+                    <form onSubmit={handleTableFormSubmit} className="space-y-4 pt-4">
+                        <div>
+                            <Label htmlFor="tableName">Table Name *</Label>
+                            <Input id="tableName" value={tableForm.name} onChange={(e) => setTableForm(prev => ({ ...prev, name: e.target.value }))} placeholder="e.g. T1, Patio A" required />
+                        </div>
+
+                        <div className="grid grid-cols-2 gap-4">
+                            <div>
+                                <Label htmlFor="floor">Floor / Зал *</Label>
+                                <Select
+                                    value={tableForm.floorId ? String(tableForm.floorId) : ""}
+                                    onValueChange={(value) => setTableForm(prev => ({ ...prev, floorId: Number(value) }))}
+                                    required
+                                >
+                                    <SelectTrigger id="floor">
+                                        <SelectValue placeholder="Select a floor" />
+                                    </SelectTrigger>
+                                    <SelectContent>
+                                        {floorsLoading ? (
+                                            <SelectItem value="loading" disabled>Loading floors...</SelectItem>
+                                        ) : (
+                                            floors?.map(floor => (
+                                                <SelectItem key={floor.id} value={String(floor.id)}>
+                                                    {floor.name}
+                                                </SelectItem>
+                                            ))
+                                        )}
+                                    </SelectContent>
+                                </Select>
+                            </div>
+                            <div>
+                                <Label htmlFor="shape">Shape</Label>
+                                <Select
+                                    value={tableForm.shape}
+                                    onValueChange={(value: 'square' | 'round') => setTableForm(prev => ({ ...prev, shape: value }))}
+                                >
+                                    <SelectTrigger id="shape">
+                                        <SelectValue placeholder="Select a shape" />
+                                    </SelectTrigger>
+                                    <SelectContent>
+                                        <SelectItem value="square">Square</SelectItem>
+                                        <SelectItem value="round">Round</SelectItem>
+                                    </SelectContent>
+                                </Select>
+                            </div>
+                        </div>
+
+                        <div className="grid grid-cols-2 gap-4">
+                            <div>
+                                <Label htmlFor="minGuests">Min Guests *</Label>
+                                <Input id="minGuests" type="number" min="1" value={tableForm.minGuests} onChange={(e) => setTableForm(prev => ({ ...prev, minGuests: parseInt(e.target.value) || 1 }))} required />
+                            </div>
+                            <div>
+                                <Label htmlFor="maxGuests">Max Guests *</Label>
+                                <Input id="maxGuests" type="number" min="1" value={tableForm.maxGuests} onChange={(e) => setTableForm(prev => ({ ...prev, maxGuests: parseInt(e.target.value) || 4 }))} required />
+                            </div>
+                        </div>
+
+                        <div>
+                            <Label htmlFor="features">Features (Optional, comma-separated)</Label>
+                            <Input id="features" value={tableForm.features} onChange={(e) => setTableForm(prev => ({ ...prev, features: e.target.value }))} placeholder="e.g. Window view, Outdoor" />
+                        </div>
+                        <div className="flex items-center space-x-2 pt-2">
+                            <Checkbox id="isNonCombinable" checked={tableForm.isNonCombinable} onCheckedChange={(checked) => setTableForm(prev => ({ ...prev, isNonCombinable: !!checked }))} />
+                            <Label htmlFor="isNonCombinable">Exclude from automatic combinations</Label>
+                        </div>
+                        <div>
+                            <Label htmlFor="comments">Comments (Optional)</Label>
+                            <Textarea id="comments" value={tableForm.comments} onChange={(e) => setTableForm(prev => ({ ...prev, comments: e.target.value }))} placeholder="Any additional notes" rows={2} />
+                        </div>
+
+                        <DialogFooter className="pt-4">
+                            <Button type="button" variant="outline" onClick={() => setShowTableModal(false)} disabled={addTableMutation.isPending || editTableMutation.isPending}>Cancel</Button>
+                            <Button type="submit" disabled={addTableMutation.isPending || editTableMutation.isPending} className="bg-green-600 hover:bg-green-700 text-white">
+                                {(addTableMutation.isPending || editTableMutation.isPending) ? <RefreshCw className="h-4 w-4 mr-2 animate-spin" /> : <Save className="h-4 w-4 mr-2" />}
+                                {editingTable ? 'Save Changes' : 'Add Table'}
+                            </Button>
+                        </DialogFooter>
+                    </form>
+                </DialogContent>
+            </Dialog>
+
+            {/* Context Menu */}
+            {contextMenu && (
+                <>
+                    <div
+                        className="fixed inset-0 z-40"
+                        onClick={() => setContextMenu(null)}
+                    />
+                    <div
+                        className="fixed z-50 bg-white border border-gray-200 rounded-md shadow-lg py-1 min-w-[180px]"
+                        style={{ left: contextMenu.x, top: contextMenu.y }}
+                    >
+                        {contextMenu.reservationId ? (
+                            <>
+                                <div className="px-3 py-2 text-sm font-medium text-gray-900 border-b">
+                                    {contextMenu.guestName || 'Reservation'}
+                                </div>
+                                <button
+                                    className="w-full px-3 py-2 text-sm text-left hover:bg-gray-100 flex items-center gap-2"
+                                    onClick={() => quickMoveMutation.mutate({ reservationId: contextMenu.reservationId!, direction: 'up' })}
+                                >
+                                    <ArrowUp className="w-4 h-4" />
+                                    Move 1 Hour Earlier
+                                </button>
+                                <button
+                                    className="w-full px-3 py-2 text-sm text-left hover:bg-gray-100 flex items-center gap-2"
+                                    onClick={() => quickMoveMutation.mutate({ reservationId: contextMenu.reservationId!, direction: 'down' })}
+                                >
+                                    <ArrowDown className="w-4 h-4" />
+                                    Move 1 Hour Later
+                                </button>
+                                <button
+                                    className="w-full px-3 py-2 text-sm text-left hover:bg-gray-100 flex items-center gap-2"
+                                    onClick={() => {
+                                        setContextMenu(null);
+                                        toast({ title: "Edit Feature", description: "Edit reservation feature coming soon!" });
+                                    }}
+                                >
+                                    <Edit2 className="w-4 h-4" />
+                                    Edit Details
+                                </button>
+                                <div className="border-t my-1" />
+                                <button
+                                    className="w-full px-3 py-2 text-sm text-left hover:bg-red-50 text-red-600 flex items-center gap-2"
+                                    onClick={() => cancelReservationMutation.mutate(contextMenu.reservationId!)}
+                                >
+                                    <Trash2 className="w-4 h-4" />
+                                    Cancel Reservation
+                                </button>
+                            </>
+                        ) : (
+                            <>
+                                <div className="px-3 py-2 text-sm font-medium text-gray-900 border-b">
+                                    Available Slot
+                                </div>
+                                <button
+                                    className="w-full px-3 py-2 text-sm text-left hover:bg-gray-100 flex items-center gap-2"
+                                    onClick={() => {
+                                        setContextMenu(null);
+                                        toast({ title: "Create Feature", description: "Create new reservation feature coming soon!" });
+                                    }}
+                                >
+                                    <UserPlus className="w-4 h-4" />
+                                    Create New Reservation
+                                </button>
+                            </>
+                        )}
+                    </div>
+                </>
             )}
-          </div>
-        </>
-      )}
-    </DashboardLayout>
-  );
+        </DashboardLayout>
+    );
 }
\ No newline at end of file
diff --git a/server/routes.ts b/server/routes.ts
index a87918e..7246e43 100644
--- a/server/routes.ts
+++ b/server/routes.ts
@@ -8,6 +8,8 @@ import {
     insertUserSchema, insertRestaurantSchema,
     insertTableSchema, insertGuestSchema,
     insertReservationSchema, insertIntegrationSettingSchema,
+    // ✅ NEW: Import the floor schema
+    insertFloorSchema,
     reservations,
     type Guest
 } from "@shared/schema";
@@ -31,11 +33,11 @@ import { enhancedConversationManager } from "./services/enhanced-conversation-ma
 
 // Multi-tenant security middleware
 import { tenantIsolation, strictTenantValidation, trackUsage, getTenantContext } from "./middleware/tenant-isolation";
-import { 
-    requireFeature, 
-    requireAiChat, 
-    requireMenuManagement, 
-    requireGuestAnalytics, 
+import {
+    requireFeature,
+    requireAiChat,
+    requireMenuManagement,
+    requireGuestAnalytics,
     requireAdvancedReporting,
     requireTelegramBot
 } from "./middleware/feature-flags";
@@ -109,14 +111,14 @@ function isOvernightOperation(openingTime: string, closingTime: string): boolean
         }
         return hours * 60 + minutes;
     };
-    
+
     const openingMinutes = parseTime(openingTime);
     const closingMinutes = parseTime(closingTime);
-    
+
     if (openingMinutes === null || closingMinutes === null) {
         return false;
     }
-    
+
     return closingMinutes < openingMinutes;
 }
 
@@ -128,7 +130,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
     console.log('✅ [Routes] WebSocket server stored in Express app context');
 
     // 🔒 SUPER ADMIN: Authorization Middleware Functions
-    
+
     // Basic authentication check (existing)
     const isAuthenticated = (req: Request, res: Response, next: Function) => {
         if (req.isAuthenticated()) {
@@ -146,9 +148,9 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
                 return next();
             }
         }
-        
+
         console.log(`[SuperAdmin] Access denied - user not authenticated as super admin`);
-        res.status(403).json({ 
+        res.status(403).json({
             message: "Super admin access required",
             code: 'INSUFFICIENT_PERMISSIONS'
         });
@@ -261,7 +263,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
         if (user) {
             console.log(`[Auth] Logout: ${user.email} (${user.isSuperAdmin ? 'Super Admin' : 'Tenant User'})`);
         }
-        
+
         req.logout((err) => {
             if (err) {
                 return next(err);
@@ -291,7 +293,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
     app.get("/api/websocket/stats", isAuthenticated, tenantIsolation, async (req, res, next) => {
         try {
             const wsServer = req.app.get('wss') as ExtendedWebSocketServer;
-            
+
             if (!wsServer) {
                 return res.status(503).json({ error: 'WebSocket server not available' });
             }
@@ -333,11 +335,11 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
     // 🔒 SUPER ADMIN: Get all tenants with filtering and pagination
     app.get("/api/superadmin/tenants", isSuperAdmin, logSuperAdminActivity('list_tenants'), async (req, res, next) => {
         try {
-            const { 
-                page = 1, 
-                limit = 20, 
-                status, 
-                plan, 
+            const {
+                page = 1,
+                limit = 20,
+                status,
+                plan,
                 search,
                 sortBy = 'created_at',
                 sortOrder = 'desc'
@@ -387,7 +389,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
     app.get("/api/superadmin/tenants/:id", isSuperAdmin, logSuperAdminActivity('view_tenant'), async (req, res, next) => {
         try {
             const tenantId = parseInt(req.params.id);
-            
+
             if (isNaN(tenantId)) {
                 return res.status(400).json({ message: "Invalid tenant ID" });
             }
@@ -428,20 +430,20 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
                 subdomain: z.string().min(2, "Subdomain must be at least 2 characters").regex(/^[a-z0-9-]+$/, "Subdomain can only contain lowercase letters, numbers, and hyphens"),
                 plan: z.enum(['starter', 'professional', 'enterprise']),
                 timezone: z.string().default('UTC'),
-                
+
                 // Owner details
                 ownerName: z.string().min(1, "Owner name is required"),
                 ownerEmail: z.string().email("Valid email is required"),
                 ownerPhone: z.string().optional(),
                 initialPassword: z.string().min(6, "Password must be at least 6 characters"),
-                
+
                 // ✅ FIX 4: Ensure boolean coercion with proper defaults
                 enableAiChat: z.boolean().default(true),
                 enableTelegramBot: z.boolean().default(false),
                 enableGuestAnalytics: z.boolean().default(true),
                 enableAdvancedReporting: z.boolean().default(false),
                 enableMenuManagement: z.boolean().default(true),
-                
+
                 // Optional settings
                 maxTables: z.number().optional(),
                 maxUsers: z.number().optional(),
@@ -466,11 +468,11 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
                     enableMenuManagement: typeof validatedData.enableMenuManagement,
                 }
             });
-            
+
             // Check if subdomain is already taken
             const existingTenant = await storage.getTenantBySubdomain(validatedData.subdomain);
             if (existingTenant) {
-                return res.status(409).json({ 
+                return res.status(409).json({
                     message: "Subdomain already exists",
                     field: "subdomain"
                 });
@@ -479,7 +481,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
             // Check if owner email is already used
             const existingUser = await storage.getUserByEmail(validatedData.ownerEmail);
             if (existingUser) {
-                return res.status(409).json({ 
+                return res.status(409).json({
                     message: "Email address already registered",
                     field: "ownerEmail"
                 });
@@ -533,9 +535,9 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
         } catch (error: any) {
             console.error('[SuperAdmin] Error creating tenant:', error);
             if (error instanceof z.ZodError) {
-                return res.status(400).json({ 
-                    message: "Validation failed", 
-                    errors: error.errors 
+                return res.status(400).json({
+                    message: "Validation failed",
+                    errors: error.errors
                 });
             }
             next(error);
@@ -546,7 +548,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
     app.patch("/api/superadmin/tenants/:id", isSuperAdmin, logSuperAdminActivity('update_tenant'), async (req, res, next) => {
         try {
             const tenantId = parseInt(req.params.id);
-            
+
             if (isNaN(tenantId)) {
                 return res.status(400).json({ message: "Invalid tenant ID" });
             }
@@ -559,26 +561,26 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
                 plan: z.enum(['starter', 'professional', 'enterprise']).optional(),
                 status: z.enum(['active', 'suspended', 'terminated']).optional(),
                 timezone: z.string().optional(),
-                
+
                 // Feature flags
                 enableAiChat: z.boolean().optional(),
                 enableTelegramBot: z.boolean().optional(),
                 enableGuestAnalytics: z.boolean().optional(),
                 enableAdvancedReporting: z.boolean().optional(),
                 enableMenuManagement: z.boolean().optional(),
-                
+
                 // Limits
                 maxTables: z.number().optional(),
                 maxUsers: z.number().optional(),
                 maxReservationsPerMonth: z.number().optional(),
-                
+
                 // Settings
                 customSettings: z.record(z.any()).optional(),
                 adminNotes: z.string().optional()
             });
 
             const validatedData = updateTenantSchema.parse(req.body);
-            
+
             console.log(`[SuperAdmin] Updating tenant ${tenantId}:`, Object.keys(validatedData));
 
             // Check if tenant exists
@@ -591,7 +593,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
             if (validatedData.subdomain && validatedData.subdomain !== existingTenant.subdomain) {
                 const subdomainTaken = await storage.getTenantBySubdomain(validatedData.subdomain);
                 if (subdomainTaken) {
-                    return res.status(409).json({ 
+                    return res.status(409).json({
                         message: "Subdomain already exists",
                         field: "subdomain"
                     });
@@ -626,9 +628,9 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
         } catch (error: any) {
             console.error('[SuperAdmin] Error updating tenant:', error);
             if (error instanceof z.ZodError) {
-                return res.status(400).json({ 
-                    message: "Validation failed", 
-                    errors: error.errors 
+                return res.status(400).json({
+                    message: "Validation failed",
+                    errors: error.errors
                 });
             }
             next(error);
@@ -801,10 +803,10 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
     // 🔒 SUPER ADMIN: Super admin profile and settings
     app.get("/api/superadmin/profile", isSuperAdmin, async (req, res) => {
         const user = req.user as SuperAdminUser;
-        
+
         try {
             const profile = await storage.getSuperAdmin(user.id);
-            
+
             res.json({
                 id: user.id,
                 email: user.email,
@@ -824,6 +826,23 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
     // 🔒 REGULAR TENANT ROUTES (Enhanced with tenant isolation)
     // ============================================================================
 
+    // ✅ NEW: Advanced Analytics Endpoint
+    app.get("/api/analytics/overview", isAuthenticated, tenantIsolation, requireAdvancedReporting, async (req, res, next) => {
+        try {
+            const context = getTenantContext(req);
+            const days = req.query.days ? parseInt(req.query.days as string) : 30;
+
+            console.log(`📊 [Analytics] Requesting overview for restaurant ${context.restaurant.id} for last ${days} days.`);
+
+            const overviewData = await storage.getAnalyticsOverview(context.restaurant.id, context.restaurant.timezone, days);
+
+            res.json(overviewData);
+        } catch (error) {
+            console.error('❌ [Analytics] Error generating overview:', error);
+            next(error);
+        }
+    });
+
     // 🔒 Restaurant routes with tenant isolation
     app.get("/api/restaurants/profile", isAuthenticated, tenantIsolation, async (req, res, next) => {
         try {
@@ -865,7 +884,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
         try {
             const context = getTenantContext(req);
             const restaurantId = parseInt(req.params.id);
-            
+
             if (context.restaurant.id !== restaurantId) {
                 return res.status(403).json({ message: "Access denied" });
             }
@@ -899,12 +918,97 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
         }
     });
 
+    // ============================================================================
+    // ✨ NEW: FLOOR PLAN MANAGEMENT
+    // ============================================================================
+
+    // ✅ NEW: Get all floors for the tenant
+    app.get("/api/floors", isAuthenticated, tenantIsolation, async (req, res, next) => {
+        try {
+            const context = getTenantContext(req);
+            const floors = await storage.getFloors(context.restaurant.id);
+            res.json(floors);
+        } catch (error) {
+            console.error(`❌ [Floors] Error fetching floors for restaurant ${getTenantContext(req).restaurant.id}:`, error);
+            next(error);
+        }
+    });
+
+    // ✅ NEW: Create a new floor
+    app.post("/api/floors", isAuthenticated, tenantIsolation, async (req, res, next) => {
+        try {
+            const context = getTenantContext(req);
+            const validatedData = insertFloorSchema.parse({
+                ...req.body,
+                restaurantId: context.restaurant.id,
+            });
+            const newFloor = await storage.createFloor(validatedData);
+            console.log(`✅ [Floors] Created new floor '${newFloor.name}' for restaurant ${context.restaurant.id}`);
+            res.status(201).json(newFloor);
+        } catch (error) {
+            console.error(`❌ [Floors] Error creating floor for restaurant ${getTenantContext(req).restaurant.id}:`, error);
+            if (error instanceof z.ZodError) {
+                return res.status(400).json({ message: "Validation failed", errors: error.errors });
+            }
+            next(error);
+        }
+    });
+
+    // ✅ NEW: Update a floor
+    app.patch("/api/floors/:id", isAuthenticated, tenantIsolation, async (req, res, next) => {
+        try {
+            const context = getTenantContext(req);
+            const floorId = parseInt(req.params.id);
+            const floor = await storage.getFloor(floorId);
+
+            if (!floor || floor.restaurantId !== context.restaurant.id) {
+                return res.status(404).json({ message: "Floor not found or access denied" });
+            }
+
+            const validatedData = insertFloorSchema.partial().parse(req.body);
+            const updatedFloor = await storage.updateFloor(floorId, validatedData);
+            console.log(`✅ [Floors] Updated floor ${floorId} for restaurant ${context.restaurant.id}`);
+            res.json(updatedFloor);
+        } catch (error) {
+            console.error(`❌ [Floors] Error updating floor ${req.params.id}:`, error);
+            if (error instanceof z.ZodError) {
+                return res.status(400).json({ message: "Validation failed", errors: error.errors });
+            }
+            next(error);
+        }
+    });
+
+    // ✅ NEW: Delete a floor
+    app.delete("/api/floors/:id", isAuthenticated, tenantIsolation, async (req, res, next) => {
+        try {
+            const context = getTenantContext(req);
+            const floorId = parseInt(req.params.id);
+            const floor = await storage.getFloor(floorId);
+
+            if (!floor || floor.restaurantId !== context.restaurant.id) {
+                return res.status(404).json({ message: "Floor not found or access denied" });
+            }
+
+            await storage.deleteFloor(floorId);
+            console.log(`✅ [Floors] Deleted floor ${floorId} from restaurant ${context.restaurant.id}`);
+            res.json({ success: true, message: "Floor deleted successfully." });
+        } catch (error) {
+            console.error(`❌ [Floors] Error deleting floor ${req.params.id}:`, error);
+            next(error);
+        }
+    });
+
+
     // 🔒 Table routes with tenant isolation and usage tracking + WebSocket integration
+    // 🔄 MODIFIED: Now accepts a 'floorId' query parameter to filter tables
     app.get("/api/tables", isAuthenticated, tenantIsolation, async (req, res, next) => {
         try {
             const context = getTenantContext(req);
-            const tables = await storage.getTables(context.restaurant.id);
-            console.log(`🔍 [Tables] Found ${tables.length} tables for restaurant ${context.restaurant.id}`);
+            const { floorId } = req.query;
+
+            const tables = await storage.getTables(context.restaurant.id, floorId ? Number(floorId) : undefined);
+
+            console.log(`🔍 [Tables] Found ${tables.length} tables for restaurant ${context.restaurant.id}${floorId ? ` on floor ${floorId}` : ''}`);
             res.json(tables);
         } catch (error) {
             console.error('❌ [Tables] Error fetching tables:', error);
@@ -912,20 +1016,22 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
         }
     });
 
+    // 🔄 MODIFIED: Now accepts floor plan fields during table creation
     app.post("/api/tables", isAuthenticated, tenantIsolation, trackUsage('table_created'), async (req, res, next) => {
         try {
             const context = getTenantContext(req);
+            // The validation now picks up the new floor plan fields from the body
             const validatedData = insertTableSchema.parse({
                 ...req.body,
                 restaurantId: context.restaurant.id,
             });
-            
+
             // 🔒 Pass tenant context for limit checking
             const newTable = await storage.createTable(validatedData, context);
-            
+
             CacheInvalidation.onTableChange(context.restaurant.id);
-            
-            console.log(`✅ [Tables] Created new table: ${newTable.name} (ID: ${newTable.id})`);
+
+            console.log(`✅ [Tables] Created new table '${newTable.name}' on floor ${newTable.floorId}`);
             res.status(201).json(newTable);
         } catch (error: any) {
             console.error('❌ [Tables] Error creating table:', error);
@@ -934,7 +1040,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
             }
             // Handle tenant limit errors
             if (error.message.includes('limit')) {
-                return res.status(402).json({ 
+                return res.status(402).json({
                     message: error.message,
                     code: 'LIMIT_EXCEEDED',
                     upgradeRequired: true
@@ -951,16 +1057,16 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
             const context = getTenantContext(req);
             const tableId = parseInt(req.params.id);
             const table = await storage.getTable(tableId);
-            
+
             if (!table || table.restaurantId !== context.restaurant.id) {
                 return res.status(404).json({ message: "Table not found" });
             }
-            
+
             const validatedData = insertTableSchema.partial().parse(req.body);
             const updatedTable = await storage.updateTable(tableId, validatedData);
-            
+
             CacheInvalidation.onTableChange(context.restaurant.id);
-            
+
             // 🔌 WEBSOCKET: Broadcast table status change
             if (validatedData.status && validatedData.status !== table.status) {
                 wss.broadcastToTenant(context.restaurant.id, {
@@ -975,7 +1081,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
                 });
                 console.log(`🔌 [WebSocket] Broadcasted table status change: ${table.name} ${table.status} → ${updatedTable.status}`);
             }
-            
+
             res.json(updatedTable);
         } catch (error: any) {
             if (error instanceof z.ZodError) {
@@ -985,20 +1091,50 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
         }
     });
 
+    // ✅ NEW: Update a table's position on the floor plan
+    app.patch("/api/tables/:id/position", isAuthenticated, tenantIsolation, async (req, res, next) => {
+        try {
+            const context = getTenantContext(req);
+            const tableId = parseInt(req.params.id);
+            const { posX, posY, rotation } = req.body;
+
+            // Basic validation
+            if (typeof posX !== 'number' || typeof posY !== 'number') {
+                return res.status(400).json({ message: "posX and posY must be numbers." });
+            }
+
+            const table = await storage.getTable(tableId);
+            if (!table || table.restaurantId !== context.restaurant.id) {
+                return res.status(404).json({ message: "Table not found" });
+            }
+
+            const updatedTable = await storage.updateTable(tableId, { posX, posY, rotation });
+
+            // Invalidate cache that depends on table data
+            CacheInvalidation.onTableChange(context.restaurant.id);
+            console.log(`✅ [Tables] Updated position for table ${tableId}: (${posX}, ${posY})`);
+
+            res.json(updatedTable);
+        } catch (error) {
+            console.error(`❌ [Tables] Error updating position for table ${req.params.id}:`, error);
+            next(error);
+        }
+    });
+
     app.delete("/api/tables/:id", isAuthenticated, tenantIsolation, async (req, res, next) => {
         try {
             const context = getTenantContext(req);
             const tableId = parseInt(req.params.id);
             const table = await storage.getTable(tableId);
-            
+
             if (!table || table.restaurantId !== context.restaurant.id) {
                 return res.status(404).json({ message: "Table not found" });
             }
-            
+
             await storage.deleteTable(tableId);
-            
+
             CacheInvalidation.onTableChange(context.restaurant.id);
-            
+
             res.json({ success: true });
         } catch (error) {
             next(error);
@@ -1050,17 +1186,17 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
             }
 
             const reservationHistory = await storage.getGuestReservationHistory(guestId, context.restaurant.id);
-            
+
             // Calculate additional analytics
             const completedVisits = reservationHistory.filter(r => r.reservation.status === 'completed');
-            const completionRate = reservationHistory.length > 0 ? 
+            const completionRate = reservationHistory.length > 0 ?
                 Math.round((completedVisits.length / reservationHistory.length) * 100) : 100;
 
             // Calculate loyalty status
             const getLoyaltyStatus = (guest: any): string => {
                 const visits = guest.visit_count || 0;
                 const reputationScore = guest.reputation_score || 100;
-                
+
                 if (visits >= 20 && reputationScore >= 95) return 'VIP';
                 if (visits >= 10 && reputationScore >= 90) return 'Frequent';
                 if (visits >= 5 && reputationScore >= 85) return 'Regular';
@@ -1078,18 +1214,18 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
                     if (hour < 21) return 'evening';
                     return 'late';
                 });
-                
+
                 const counts = timeSlots.reduce((acc, slot) => {
                     acc[slot] = (acc[slot] || 0) + 1;
                     return acc;
                 }, {} as Record<string, number>);
-                
+
                 return Object.entries(counts)
-                    .sort(([,a], [,b]) => b - a)
+                    .sort(([, a], [, b]) => b - a)
                     .slice(0, 2)
                     .map(([slot]) => slot);
             };
-            
+
             const analytics = {
                 guest: {
                     ...guest,
@@ -1100,7 +1236,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
                 reputationScore: guest.reputation_score || 100,
                 vipLevel: guest.vip_level || 0,
                 completionRate,
-                averageSpending: guest.total_spent && guest.visit_count ? 
+                averageSpending: guest.total_spent && guest.visit_count ?
                     (parseFloat(guest.total_spent) / guest.visit_count).toFixed(2) : '0.00',
                 totalSpent: guest.total_spent || '0.00',
                 lastVisit: guest.last_visit_date,
@@ -1126,7 +1262,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
                     approach: (() => {
                         const visits = guest.visit_count || 0;
                         const reputation = guest.reputation_score || 100;
-                        
+
                         if (visits >= 10) return "VIP treatment - recognize their loyalty and offer premium service";
                         if (visits >= 5) return "Regular guest - personalized service based on their history";
                         if (reputation < 80) return "Handle with care - previous issues noted, ensure exceptional service";
@@ -1150,7 +1286,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
         try {
             const { date, time } = req.query;
             const context = getTenantContext(req);
-            
+
             if (!date || !time) {
                 return res.status(400).json({ message: "Date and time are required" });
             }
@@ -1158,8 +1294,8 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
             console.log(`🔍 [Table Availability] Checking for date=${date}, time=${time} in timezone ${context.restaurant.timezone}`);
 
             // ✅ DYNAMIC: Check if restaurant operates overnight (works for ANY times)
-            const isOvernight = context.restaurant.openingTime && context.restaurant.closingTime && 
-                               isOvernightOperation(context.restaurant.openingTime, context.restaurant.closingTime);
+            const isOvernight = context.restaurant.openingTime && context.restaurant.closingTime &&
+                isOvernightOperation(context.restaurant.openingTime, context.restaurant.closingTime);
 
             if (isOvernight) {
                 console.log(`🌙 [Table Availability] Detected overnight operation: ${context.restaurant.openingTime} to ${context.restaurant.closingTime}`);
@@ -1168,35 +1304,35 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
             const cacheKey = CacheKeys.tableAvailability(context.restaurant.id, `${date}_${time}`);
             const tableAvailabilityData = await withCache(cacheKey, async () => {
                 const tablesData = await storage.getTables(context.restaurant.id);
-                
+
                 if (tablesData.length === 0) {
                     console.log(`⚠️ [Table Availability] No tables found for restaurant ${context.restaurant.id} - this might be why frontend shows empty arrays`);
                     return [];
                 }
-                
+
                 console.log(`📋 [Table Availability] Found ${tablesData.length} tables for restaurant ${context.restaurant.id}`);
-                
+
                 // ✅ DYNAMIC: Enhanced reservation fetching for overnight operations
                 let reservationsData;
                 if (isOvernight) {
                     // Get reservations from current date
-                    const currentDateReservations = await storage.getReservations(context.restaurant.id, { 
+                    const currentDateReservations = await storage.getReservations(context.restaurant.id, {
                         date: date as string,
                         timezone: context.restaurant.timezone
                     });
-                    
+
                     // For overnight operations, also check previous day if checking early morning hours
                     const checkHour = parseInt((time as string).split(':')[0]);
                     const closingHour = parseInt((context.restaurant.closingTime || '0:00').split(':')[0]);
-                    
+
                     if (checkHour < closingHour) { // Early morning hours (before closing time)
                         const previousDate = DateTime.fromISO(date as string, { zone: context.restaurant.timezone })
                             .minus({ days: 1 }).toISODate();
-                        const previousDateReservations = await storage.getReservations(context.restaurant.id, { 
+                        const previousDateReservations = await storage.getReservations(context.restaurant.id, {
                             date: previousDate,
                             timezone: context.restaurant.timezone
                         });
-                        
+
                         reservationsData = [...currentDateReservations, ...previousDateReservations];
                         console.log(`🌙 [Table Availability] Overnight operation: ${currentDateReservations.length} current + ${previousDateReservations.length} previous day reservations`);
                     } else {
@@ -1204,7 +1340,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
                     }
                 } else {
                     // Standard operation - just get current date reservations
-                    reservationsData = await storage.getReservations(context.restaurant.id, { 
+                    reservationsData = await storage.getReservations(context.restaurant.id, {
                         date: date as string,
                         timezone: context.restaurant.timezone
                     });
@@ -1216,8 +1352,8 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
                 const availabilityResult = tablesData.map(table => {
                     const tableReservations = reservationsData.filter(r => {
                         const actualReservation = r.reservation || r;
-                        return actualReservation.tableId === table.id && 
-                               ['confirmed', 'created'].includes(actualReservation.status || '');
+                        return actualReservation.tableId === table.id &&
+                            ['confirmed', 'created'].includes(actualReservation.status || '');
                     });
 
                     if (tableReservations.length > 0) {
@@ -1236,7 +1372,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
                             duration: r.reservation?.duration || r.duration,
                             id: r.reservation?.id || r.id
                         };
-                        
+
                         // Note the "!" to invert the result
                         // If the table is NOT available, it is occupied
                         return !isTableAvailableAtTimeSlot(
@@ -1262,7 +1398,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
                                 duration: r.reservation?.duration || r.duration,
                                 id: r.reservation?.id || r.id
                             };
-                            
+
                             return !isTableAvailableAtTimeSlot(
                                 table.id,
                                 time as string,
@@ -1281,7 +1417,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
                             const guest = conflictingReservation.guest || {};
 
                             const reservationDateTime = parsePostgresTimestamp(actualReservation.reservation_utc);
-                            
+
                             if (reservationDateTime.isValid) {
                                 const reservationLocal = reservationDateTime.setZone(context.restaurant.timezone);
                                 const startTime = reservationLocal.toFormat('HH:mm:ss');
@@ -1300,22 +1436,22 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
                         }
                     }
 
-                    return { 
-                        ...table, 
-                        status: isOccupied ? 'reserved' : 'available', 
+                    return {
+                        ...table,
+                        status: isOccupied ? 'reserved' : 'available',
                         reservation: conflictingReservationData
                     };
                 });
 
                 console.log(`✅ [Table Availability] Processed ${availabilityResult.length} tables with timezone ${context.restaurant.timezone} (overnight: ${isOvernight})`);
-                
+
                 if (availabilityResult.length === 0) {
                     console.log(`❌ [Table Availability] RETURNING EMPTY ARRAY - Check table creation and restaurant association`);
                 } else {
-                    console.log(`✅ [Table Availability] Returning ${availabilityResult.length} tables:`, 
+                    console.log(`✅ [Table Availability] Returning ${availabilityResult.length} tables:`,
                         availabilityResult.map(t => ({ id: t.id, name: t.name, status: t.status })));
                 }
-                
+
                 return availabilityResult;
             }, 30);
 
@@ -1331,30 +1467,30 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
         try {
             const context = getTenantContext(req);
             const { date, guests, exactTime } = req.query; // NEW: exactTime param
-            const restaurantId = context.restaurant.id;           
-            
+            const restaurantId = context.restaurant.id;
+
             if (!restaurantId || !date || !guests) {
                 return res.status(400).json({ message: "Missing required parameters" });
             }
-            
+
             console.log(`[Routes] Getting available times for restaurant ${restaurantId}, date ${date}, guests ${guests} in timezone ${context.restaurant.timezone}${exactTime ? ` (exact time: ${exactTime})` : ''}`);
-            
+
             // ✅ NEW: Handle exact time checking
             if (exactTime) {
                 console.log(`[Routes] 🎯 Exact time check: ${exactTime} for ${guests} guests on ${date}`);
-                
+
                 const availableSlots = await getAvailableTimeSlots(
                     parseInt(restaurantId as string),
                     date as string,
                     parseInt(guests as string),
-                    { 
+                    {
                         requestedTime: exactTime as string,
                         exactTimeOnly: true, // NEW: Only check this exact time
                         timezone: context.restaurant.timezone,
                         allowCombinations: true
                     }
                 );
-                
+
                 return res.json({
                     exactTimeRequested: exactTime,
                     available: availableSlots.length > 0,
@@ -1375,34 +1511,34 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
                     minTimeIncrement: context.restaurant.minTimeIncrement || 15 // NEW: Include restaurant setting
                 });
             }
-            
+
             // ✅ EXISTING LOGIC (enhanced with restaurant settings):
-            const isOvernight = context.restaurant.openingTime && context.restaurant.closingTime && 
-                               isOvernightOperation(context.restaurant.openingTime, context.restaurant.closingTime);
-            
+            const isOvernight = context.restaurant.openingTime && context.restaurant.closingTime &&
+                isOvernightOperation(context.restaurant.openingTime, context.restaurant.closingTime);
+
             // Use restaurant's configured slot interval
             const slotInterval = context.restaurant.slotInterval || 30; // NEW: Use restaurant setting
-            
+
             // ✅ ENHANCED: maxResults calculation for overnight operations
             let maxResults: number;
             let operatingHours: number;
-            
+
             if (isOvernight) {
                 // Calculate total operating hours for overnight operations
                 const parseTime = (timeStr: string): number => {
                     const parts = timeStr.split(':');
                     return parseInt(parts[0], 10) * 60 + parseInt(parts[1] || '0', 10);
                 };
-                
+
                 const openingMinutes = parseTime(context.restaurant.openingTime || '10:00');
                 const closingMinutes = parseTime(context.restaurant.closingTime || '22:00');
-                
+
                 // ✅ DYNAMIC: For overnight operations, calculate correctly (works for ANY times)
                 operatingHours = (24 * 60 - openingMinutes + closingMinutes) / 60;
-                
+
                 // ✅ DYNAMIC: More generous slot calculation for overnight operations
                 maxResults = Math.max(80, Math.floor(operatingHours * 2.5)); // Extra buffer for overnight
-                
+
                 console.log(`[Routes] 🌙 Overnight operation detected: ${context.restaurant.openingTime}-${context.restaurant.closingTime} (${operatingHours.toFixed(1)} hours), maxResults=${maxResults}`);
             } else {
                 // Standard operation
@@ -1410,22 +1546,22 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
                     const parts = timeStr.split(':');
                     return parseInt(parts[0], 10) * 60 + parseInt(parts[1] || '0', 10);
                 };
-                
+
                 const openingMinutes = parseTime(context.restaurant.openingTime || '10:00');
                 const closingMinutes = parseTime(context.restaurant.closingTime || '22:00');
                 operatingHours = (closingMinutes - openingMinutes) / 60;
-                
+
                 maxResults = Math.max(30, Math.floor(operatingHours * 2));
-                
+
                 console.log(`[Routes] 📅 Standard operation: ${context.restaurant.openingTime}-${context.restaurant.closingTime} (${operatingHours.toFixed(1)} hours), maxResults=${maxResults}`);
             }
-            
+
             // ✅ ENHANCED: Pass restaurant configuration to getAvailableTimeSlots
             const availableSlots = await getAvailableTimeSlots(
                 parseInt(restaurantId as string),
                 date as string,
                 parseInt(guests as string),
-                { 
+                {
                     maxResults: maxResults,
                     timezone: context.restaurant.timezone,
                     lang: 'en',
@@ -1438,7 +1574,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
                     }
                 }
             );
-            
+
             // ✅ ENHANCED: Better slot information with overnight support
             const timeSlots = availableSlots.map(slot => ({
                 time: slot.time,
@@ -1449,7 +1585,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
                 canAccommodate: true,
                 tablesCount: slot.isCombined ? (slot.constituentTables?.length || 1) : 1,
                 isCombined: slot.isCombined || false,
-                message: slot.isCombined 
+                message: slot.isCombined
                     ? `${slot.tableName} available (seats up to ${slot.tableCapacity.max})`
                     : `Table ${slot.tableName} available (seats up to ${slot.tableCapacity.max})`,
                 slotType: (() => {
@@ -1464,11 +1600,11 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
                     return 'standard';
                 })()
             }));
-            
+
             console.log(`[Routes] 📊 Found ${timeSlots.length} available time slots for ${context.restaurant.timezone} ${isOvernight ? '(overnight operation)' : '(standard operation)'}`);
-            
+
             // ✅ ENHANCED: Response with restaurant time configuration
-            res.json({ 
+            res.json({
                 availableSlots: timeSlots,
                 isOvernightOperation: isOvernight,
                 operatingHours: {
@@ -1477,16 +1613,16 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
                     totalHours: operatingHours
                 },
                 timezone: context.restaurant.timezone,
-                
+
                 // ✅ NEW: Include restaurant's flexible time configuration
                 slotInterval: slotInterval, // Restaurant's preferred slot interval
                 allowAnyTime: context.restaurant.allowAnyTime !== false, // Whether any time booking is allowed
                 minTimeIncrement: context.restaurant.minTimeIncrement || 15, // Minimum time precision
-                
+
                 totalSlotsGenerated: timeSlots.length,
                 maxSlotsRequested: maxResults,
                 reservationDuration: context.restaurant.avgReservationDuration || 120,
-                
+
                 debugInfo: {
                     openingTime: context.restaurant.openingTime,
                     closingTime: context.restaurant.closingTime,
@@ -1497,7 +1633,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
                     operatingHours: operatingHours,
                     calculatedMaxResults: maxResults,
                     actualSlotsReturned: timeSlots.length,
-                    
+
                     // ✅ NEW: Debug info for time configuration
                     restaurantSlotInterval: context.restaurant.slotInterval,
                     restaurantAllowAnyTime: context.restaurant.allowAnyTime,
@@ -1532,7 +1668,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
             const context = getTenantContext(req);
             const reservationId = parseInt(req.params.id);
             const reservation = await storage.getReservation(reservationId);
-            
+
             if (!reservation || reservation.reservation.restaurantId !== context.restaurant.id) {
                 return res.status(404).json({ message: "Reservation not found" });
             }
@@ -1553,11 +1689,11 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
             const wss = req.app.get('wss') as ExtendedWebSocketServer;
             const context = getTenantContext(req);
             const { guestName, guestPhone, date, time, guests: numGuests } = req.body;
-            
+
             if (!guestName || !guestPhone || !date || !time || !numGuests) {
                 return res.status(400).json({ message: "Missing required fields: guestName, guestPhone, date, time, guests" });
             }
-            
+
             let guest: Guest | undefined = await storage.getGuestByPhone(guestPhone, context.restaurant.id);
             if (!guest) {
                 guest = await storage.createGuest({
@@ -1573,27 +1709,27 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
 
             // ✅ DYNAMIC: Convert date/time to UTC timestamp before booking
             const restaurantTimezone = req.body.timezone || context.restaurant.timezone;
-            
+
             let localDateTime: DateTime;
             let reservation_utc: string;
-            
+
             try {
                 localDateTime = DateTime.fromISO(`${date}T${time}`, { zone: restaurantTimezone });
                 if (!localDateTime.isValid) {
                     throw new Error(`Invalid date/time combination: ${date}T${time} in timezone ${restaurantTimezone}`);
                 }
-                
+
                 reservation_utc = localDateTime.toUTC().toISO();
                 if (!reservation_utc) {
                     throw new Error('Failed to convert to UTC timestamp');
                 }
-                
+
                 console.log(`📅 [Reservation] Converting ${date}T${time} (${restaurantTimezone}) -> ${reservation_utc} (UTC)`);
             } catch (conversionError) {
                 console.error('❌ [Reservation] DateTime conversion failed:', conversionError);
-                return res.status(400).json({ 
-                    message: "Invalid date/time format or timezone", 
-                    details: conversionError instanceof Error ? conversionError.message : 'Unknown conversion error' 
+                return res.status(400).json({
+                    message: "Invalid date/time format or timezone",
+                    details: conversionError instanceof Error ? conversionError.message : 'Unknown conversion error'
                 });
             }
 
@@ -1790,7 +1926,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
             await cancelReservation(
                 wss, // 🔽 Pass WebSocket server for broadcasting
                 context.restaurant.id, // ✅ Authenticated tenant ID from middleware
-                reservationId, 
+                reservationId,
                 context.restaurant.languages?.[0] || 'en'
             );
 
@@ -1822,16 +1958,16 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
             const { tableNotes, staffMember } = req.body;
             const reservationId = parseInt(req.params.id);
             const context = getTenantContext(req);
-            
+
             // Validate current status
             const reservation = await storage.getReservation(reservationId);
             if (!reservation || reservation.reservation.restaurantId !== context.restaurant.id) {
                 return res.status(404).json({ message: "Reservation not found" });
             }
-            
+
             if (!['confirmed', 'created'].includes(reservation.reservation.status)) {
-                return res.status(400).json({ 
-                    message: `Cannot seat guests - reservation status is ${reservation.reservation.status}. Only confirmed reservations can be seated.` 
+                return res.status(400).json({
+                    message: `Cannot seat guests - reservation status is ${reservation.reservation.status}. Only confirmed reservations can be seated.`
                 });
             }
 
@@ -1847,10 +1983,10 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
 
             // Update table status if there's a table assigned
             if (reservation.reservation.tableId) {
-                await storage.updateTable(reservation.reservation.tableId, { 
-                    status: 'occupied' 
+                await storage.updateTable(reservation.reservation.tableId, {
+                    status: 'occupied'
                 });
-                
+
                 // Invalidate table cache
                 CacheInvalidation.onTableChange(context.restaurant.id);
             }
@@ -1870,8 +2006,8 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
 
             console.log(`✅ [Reservation Status] Seated guests for reservation ${reservationId} by ${staffMember || 'Unknown staff'} + WebSocket broadcast`);
 
-            res.json({ 
-                success: true, 
+            res.json({
+                success: true,
                 message: "Guests have been seated successfully",
                 reservationId,
                 newStatus: 'seated',
@@ -1890,22 +2026,22 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
             const { feedback, totalAmount, staffMember } = req.body;
             const reservationId = parseInt(req.params.id);
             const context = getTenantContext(req);
-            
+
             const reservation = await storage.getReservation(reservationId);
             if (!reservation || reservation.reservation.restaurantId !== context.restaurant.id) {
                 return res.status(404).json({ message: "Reservation not found" });
             }
 
             if (!['seated', 'in_progress'].includes(reservation.reservation.status)) {
-                return res.status(400).json({ 
-                    message: `Cannot complete visit - reservation status is ${reservation.reservation.status}. Only seated or in-progress reservations can be completed.` 
+                return res.status(400).json({
+                    message: `Cannot complete visit - reservation status is ${reservation.reservation.status}. Only seated or in-progress reservations can be completed.`
                 });
             }
 
             // Calculate visit duration
             const seatedTime = await storage.getStatusChangeTime(reservationId, 'seated');
-            const duration = seatedTime ? 
-                Math.round((Date.now() - seatedTime.getTime()) / 60000) : 
+            const duration = seatedTime ?
+                Math.round((Date.now() - seatedTime.getTime()) / 60000) :
                 reservation.reservation.duration;
 
             // Update reservation
@@ -1916,8 +2052,8 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
             }, {
                 changedBy: 'staff',
                 changeReason: 'Visit completed by staff',
-                metadata: { 
-                    staffMember: staffMember || 'Unknown staff', 
+                metadata: {
+                    staffMember: staffMember || 'Unknown staff',
                     actualDuration: duration,
                     totalAmount: totalAmount ? parseFloat(totalAmount) : null
                 }
@@ -1932,10 +2068,10 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
 
             // Free up table
             if (reservation.reservation.tableId) {
-                await storage.updateTable(reservation.reservation.tableId, { 
-                    status: 'free' 
+                await storage.updateTable(reservation.reservation.tableId, {
+                    status: 'free'
                 });
-                
+
                 // Invalidate table cache
                 CacheInvalidation.onTableChange(context.restaurant.id);
             }
@@ -1957,8 +2093,8 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
 
             console.log(`✅ [Reservation Status] Completed visit for reservation ${reservationId}, duration: ${duration}min, amount: $${totalAmount || 0} + WebSocket broadcast`);
 
-            res.json({ 
-                success: true, 
+            res.json({
+                success: true,
                 message: "Visit completed successfully",
                 reservationId,
                 newStatus: 'completed',
@@ -1979,15 +2115,15 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
             const { reason, staffMember } = req.body;
             const reservationId = parseInt(req.params.id);
             const context = getTenantContext(req);
-            
+
             const reservation = await storage.getReservation(reservationId);
             if (!reservation || reservation.reservation.restaurantId !== context.restaurant.id) {
                 return res.status(404).json({ message: "Reservation not found" });
             }
 
             if (!['confirmed', 'created'].includes(reservation.reservation.status)) {
-                return res.status(400).json({ 
-                    message: `Cannot mark as no-show - reservation status is ${reservation.reservation.status}. Only confirmed reservations can be marked as no-show.` 
+                return res.status(400).json({
+                    message: `Cannot mark as no-show - reservation status is ${reservation.reservation.status}. Only confirmed reservations can be marked as no-show.`
                 });
             }
 
@@ -1997,8 +2133,8 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
             }, {
                 changedBy: 'staff',
                 changeReason: 'Marked as no-show by staff',
-                metadata: { 
-                    staffMember: staffMember || 'Unknown staff', 
+                metadata: {
+                    staffMember: staffMember || 'Unknown staff',
                     reason: reason || 'No reason provided'
                 }
             });
@@ -2010,10 +2146,10 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
 
             // Free up table
             if (reservation.reservation.tableId) {
-                await storage.updateTable(reservation.reservation.tableId, { 
-                    status: 'free' 
+                await storage.updateTable(reservation.reservation.tableId, {
+                    status: 'free'
                 });
-                
+
                 // Invalidate table cache
                 CacheInvalidation.onTableChange(context.restaurant.id);
             }
@@ -2034,8 +2170,8 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
 
             console.log(`⚠️ [Reservation Status] Marked reservation ${reservationId} as no-show: ${reason || 'No reason provided'} + WebSocket broadcast`);
 
-            res.json({ 
-                success: true, 
+            res.json({
+                success: true,
                 message: "Reservation marked as no-show",
                 reservationId,
                 newStatus: 'no_show',
@@ -2053,17 +2189,17 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
         try {
             const reservationId = parseInt(req.params.id);
             const context = getTenantContext(req);
-            
+
             // Verify reservation belongs to this restaurant
             const reservation = await storage.getReservation(reservationId);
             if (!reservation || reservation.reservation.restaurantId !== context.restaurant.id) {
                 return res.status(404).json({ message: "Reservation not found" });
             }
-            
+
             const history = await storage.getReservationStatusHistory(reservationId);
-            
+
             console.log(`📋 [Reservation History] Retrieved ${history.length} status changes for reservation ${reservationId}`);
-            
+
             res.json({
                 reservationId,
                 history: history.map(entry => ({
@@ -2084,7 +2220,79 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
     });
 
     // ============================================================================
-    // ✅ MENU MANAGEMENT SYSTEM with feature gate (No WebSocket needed - configuration)
+    // ✨ NEW: MENU CATEGORY MANAGEMENT with feature gate
+    // ============================================================================
+
+    // Get all menu categories for the restaurant
+    app.get("/api/menu-categories", isAuthenticated, tenantIsolation, requireMenuManagement, async (req, res, next) => {
+        try {
+            const context = getTenantContext(req);
+            const categories = await storage.getMenuCategories(context.restaurant.id);
+            res.json(categories);
+        } catch (error) {
+            next(error);
+        }
+    });
+
+    // Create a new menu category
+    app.post("/api/menu-categories", isAuthenticated, tenantIsolation, requireMenuManagement, async (req, res, next) => {
+        try {
+            const context = getTenantContext(req);
+            const { name, description } = req.body;
+            if (!name) {
+                return res.status(400).json({ message: "Category name is required" });
+            }
+            const newCategory = await storage.createMenuCategory({
+                restaurantId: context.restaurant.id,
+                name,
+                description,
+                // A simple slug generation
+                slug: name.toLowerCase().replace(/\s+/g, '-').replace(/[^\w-]+/g, ''),
+            });
+            res.status(201).json(newCategory);
+        } catch (error) {
+            next(error);
+        }
+    });
+
+    // Update a menu category
+    app.patch("/api/menu-categories/:id", isAuthenticated, tenantIsolation, requireMenuManagement, async (req, res, next) => {
+        try {
+            const context = getTenantContext(req);
+            const categoryId = parseInt(req.params.id);
+            const category = await storage.getMenuCategory(categoryId);
+
+            if (!category || category.restaurantId !== context.restaurant.id) {
+                return res.status(404).json({ message: "Category not found" });
+            }
+
+            const updatedCategory = await storage.updateMenuCategory(categoryId, req.body);
+            res.json(updatedCategory);
+        } catch (error) {
+            next(error);
+        }
+    });
+
+    // Delete a menu category
+    app.delete("/api/menu-categories/:id", isAuthenticated, tenantIsolation, requireMenuManagement, async (req, res, next) => {
+        try {
+            const context = getTenantContext(req);
+            const categoryId = parseInt(req.params.id);
+            const category = await storage.getMenuCategory(categoryId);
+
+            if (!category || category.restaurantId !== context.restaurant.id) {
+                return res.status(404).json({ message: "Category not found" });
+            }
+
+            await storage.deleteMenuCategory(categoryId);
+            res.json({ success: true, message: "Category deleted successfully." });
+        } catch (error) {
+            next(error);
+        }
+    });
+
+    // ============================================================================
+    // ✅ UPGRADED: MENU MANAGEMENT SYSTEM with feature gate
     // ============================================================================
 
     // Get menu items with advanced filtering
@@ -2092,7 +2300,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
         try {
             const context = getTenantContext(req);
             const { category, available, search, popular, limit } = req.query;
-            
+
             const filters = {
                 category: category as string,
                 availableOnly: available === 'true',
@@ -2104,7 +2312,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
             console.log(`🍽️ [Menu Items] Fetching menu items for restaurant ${context.restaurant.id} with filters:`, filters);
 
             const menuItems = await storage.getMenuItems(context.restaurant.id, filters);
-            
+
             // Group by category for better UI organization
             const groupedItems = menuItems.reduce((acc, item) => {
                 const cat = item.categoryName || 'other';
@@ -2138,34 +2346,24 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
         }
     });
 
-    // ✅ BUG 1 FIX: Create new menu item with category name lookup
+    // Create new menu item with on-the-fly category creation
     app.post("/api/menu-items", isAuthenticated, tenantIsolation, requireMenuManagement, async (req, res, next) => {
         try {
             const context = getTenantContext(req);
 
-            // Basic validation schema for menu items
             const menuItemSchema = z.object({
                 name: z.string().min(1, "Name is required"),
                 description: z.string().optional(),
                 price: z.string().or(z.number()).transform(val => String(val)),
                 category: z.string().min(1, "Category is required"),
-                allergens: z.array(z.string()).optional(),
-                dietaryTags: z.array(z.string()).optional(),
                 isAvailable: z.boolean().default(true),
                 isPopular: z.boolean().default(false),
-                isNew: z.boolean().default(false),
-                preparationTime: z.number().optional(),
-                spicyLevel: z.number().min(0).max(5).default(0)
             });
 
             const validatedData = menuItemSchema.parse(req.body);
 
-            // ✅ BUG 1 FIX: Look up the category ID from the category name
-            const category = await storage.getMenuCategoryByName(context.restaurant.id, validatedData.category);
-
-            if (!category) {
-                return res.status(400).json({ message: `Category '${validatedData.category}' not found.` });
-            }
+            // ✨ UPGRADED LOGIC: This now finds OR creates the category automatically.
+            const category = await storage.getOrCreateMenuCategoryByName(context.restaurant.id, validatedData.category);
 
             const newItem = await storage.createMenuItem({
                 name: validatedData.name,
@@ -2173,18 +2371,13 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
                 description: validatedData.description,
                 isAvailable: validatedData.isAvailable,
                 isPopular: validatedData.isPopular,
-                isNew: validatedData.isNew,
-                preparationTime: validatedData.preparationTime,
-                spicyLevel: validatedData.spicyLevel,
-                allergens: validatedData.allergens,
-                dietaryTags: validatedData.dietaryTags,
                 restaurantId: context.restaurant.id,
-                categoryId: category.id  // ✅ BUG 1 FIX: Use the correct numeric categoryId
+                categoryId: category.id  // Use the ID from the found or newly created category
             });
-            
+
             // Invalidate menu cache
             cache.invalidatePattern(`menu_items_${context.restaurant.id}`);
-            
+
             console.log(`✅ [Menu Items] Created new item: ${newItem.name} (${validatedData.category}) - ${newItem.price}`);
 
             res.status(201).json({
@@ -2194,9 +2387,9 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
         } catch (error: any) {
             console.error('[Menu Items] Error creating item:', error);
             if (error instanceof z.ZodError) {
-                return res.status(400).json({ 
-                    message: "Validation failed", 
-                    errors: error.errors 
+                return res.status(400).json({
+                    message: "Validation failed",
+                    errors: error.errors
                 });
             }
             next(error);
@@ -2208,7 +2401,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
         try {
             const context = getTenantContext(req);
             const itemId = parseInt(req.params.id);
-            
+
             // Verify the item belongs to this restaurant
             const existingItem = await storage.getMenuItem(itemId);
             if (!existingItem || existingItem.restaurantId !== context.restaurant.id) {
@@ -2216,10 +2409,10 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
             }
 
             const updatedItem = await storage.updateMenuItem(itemId, req.body);
-            
+
             // Invalidate menu cache
             cache.invalidatePattern(`menu_items_${context.restaurant.id}`);
-            
+
             console.log(`✅ [Menu Items] Updated item ${itemId}: ${updatedItem.name}`);
 
             res.json({
@@ -2237,7 +2430,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
         try {
             const context = getTenantContext(req);
             const itemId = parseInt(req.params.id);
-            
+
             // Verify the item belongs to this restaurant
             const existingItem = await storage.getMenuItem(itemId);
             if (!existingItem || existingItem.restaurantId !== context.restaurant.id) {
@@ -2245,14 +2438,14 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
             }
 
             await storage.deleteMenuItem(itemId);
-            
+
             // Invalidate menu cache
             cache.invalidatePattern(`menu_items_${context.restaurant.id}`);
-            
+
             console.log(`🗑️ [Menu Items] Deleted item ${itemId}: ${existingItem.name}`);
 
-            res.json({ 
-                success: true, 
+            res.json({
+                success: true,
                 message: "Menu item deleted successfully",
                 deletedItem: { id: itemId, name: existingItem.name }
             });
@@ -2279,14 +2472,14 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
             console.log(`🔄 [Menu Items] Bulk ${action} update for ${items.length} items in restaurant ${context.restaurant.id}`);
 
             const results = await storage.bulkUpdateMenuItems(context.restaurant.id, items, action);
-            
+
             // Invalidate cache
             cache.invalidatePattern(`menu_items_${context.restaurant.id}`);
-            
+
             console.log(`✅ [Menu Items] Bulk ${action} completed: ${results.length} items processed`);
-            
-            res.json({ 
-                success: true, 
+
+            res.json({
+                success: true,
                 action,
                 updatedCount: results.length,
                 items: results,
@@ -2303,7 +2496,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
         try {
             const context = getTenantContext(req);
             const { q: query, category, dietary, priceMin, priceMax } = req.query;
-            
+
             if (!query || typeof query !== 'string') {
                 return res.status(400).json({ message: "Search query is required" });
             }
@@ -2382,7 +2575,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
         try {
             const context = getTenantContext(req);
             const type = req.params.type;
-            
+
             // Check feature access for telegram
             if (type === 'telegram' && !context.features.telegramBot) {
                 return res.status(402).json({
@@ -2406,11 +2599,11 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
         try {
             const context = getTenantContext(req);
             const settings = await storage.getIntegrationSettings(context.restaurant.id, 'telegram');
-            
+
             if (!settings || !settings.enabled || !settings.token) {
                 return res.status(400).json({ message: "Telegram bot is not configured or enabled" });
             }
-            
+
             try {
                 const TelegramBot = require('node-telegram-bot-api');
                 const bot = new TelegramBot(settings.token);
@@ -2450,7 +2643,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
         try {
             const context = getTenantContext(req);
             const type = req.params.type;
-            
+
             // Check feature access for telegram
             if (type === 'telegram' && !context.features.telegramBot) {
                 return res.status(402).json({
@@ -2472,7 +2665,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
                 settings: customSettings
             });
             const savedSettings = await storage.saveIntegrationSettings(validatedData);
-            
+
             if (type === 'telegram' && savedSettings.enabled && savedSettings.token) {
                 try {
                     await initializeTelegramBot(context.restaurant.id);
@@ -2549,16 +2742,16 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
             const { sessionId, message } = req.body;
 
             if (!sessionId || !message) {
-                return res.status(400).json({ 
-                    message: "Session ID and message are required" 
+                return res.status(400).json({
+                    message: "Session ID and message are required"
                 });
             }
 
             // Validate session exists
             const session = enhancedConversationManager.getSession(sessionId);
             if (!session) {
-                return res.status(404).json({ 
-                    message: "Session not found. Please create a new session." 
+                return res.status(404).json({
+                    message: "Session not found. Please create a new session."
                 });
             }
 
@@ -2598,18 +2791,18 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
 
         } catch (error) {
             console.error('[API] Error handling Sofia message:', error);
-            
+
             // Provide helpful error response
             const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
-            
+
             if (errorMessage.includes('Session') && errorMessage.includes('not found')) {
-                return res.status(404).json({ 
-                    message: "Your session has expired. Please refresh the page to start a new conversation." 
+                return res.status(404).json({
+                    message: "Your session has expired. Please refresh the page to start a new conversation."
                 });
             }
 
-            res.status(500).json({ 
-                message: "I encountered an error. Please try again or refresh the page." 
+            res.status(500).json({
+                message: "I encountered an error. Please try again or refresh the page."
             });
         }
     });
@@ -2626,7 +2819,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
 
             // Verify user has access to this restaurant
             const context = getTenantContext(req);
-            
+
             if (context.restaurant.id !== session.restaurantId) {
                 return res.status(403).json({ message: "Access denied" });
             }
@@ -2680,9 +2873,9 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
 
             console.log(`[API] Ended Sofia chat session ${sessionId}`);
 
-            res.json({ 
+            res.json({
                 message: "Session ended successfully",
-                sessionId 
+                sessionId
             });
 
         } catch (error) {
@@ -2878,7 +3071,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
             return res.json({
                 restaurantId: context.restaurant.id,
                 restaurantName: context.restaurant.name,
-                
+
                 // Raw database values
                 rawFeatures: {
                     enableAiChat: rawRestaurant?.enableAiChat,
@@ -2887,14 +3080,14 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
                     enableAdvancedReporting: rawRestaurant?.enableAdvancedReporting,
                     enableMenuManagement: rawRestaurant?.enableMenuManagement,
                 },
-                
+
                 // Tenant context features (processed)
                 contextFeatures: context.features,
-                
+
                 // Plan and status
                 tenantPlan: context.restaurant.tenantPlan,
                 tenantStatus: context.restaurant.tenantStatus,
-                
+
                 // Feature checks
                 featureChecks: {
                     aiChat: context.features.aiChat,
@@ -2903,7 +3096,7 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
                     guestAnalytics: context.features.guestAnalytics,
                     advancedReporting: context.features.advancedReporting,
                 },
-                
+
                 debugTimestamp: new Date().toISOString()
             });
 
@@ -2915,4 +3108,4 @@ export async function registerRoutes(app: Express, wss: ExtendedWebSocketServer)
 
     const httpServer = createServer(app);
     return httpServer;
-}
\ No newline at end of file
+}
diff --git a/server/services/agents/sofia-agent.ts b/server/services/agents/sofia-agent.ts
index 36ad88a..ab498e9 100644
--- a/server/services/agents/sofia-agent.ts
+++ b/server/services/agents/sofia-agent.ts
@@ -101,22 +101,6 @@ interface NameExtractionPattern {
     };
 }
 
-/**
- * 🚀 PRODUCTION-READY: Sofia Agent - Booking Specialist with Critical Fixes
- * 
- * This agent completely resolves critical issues through:
- * 1. Comprehensive multi-language pattern matching for name extraction
- * 2. Intelligent attempt limiting with graceful fallbacks
- * 3. Robust fuzzy matching for typos and variations
- * 4. Professional error handling for all edge cases
- * 5. Seamless integration with the fixed context manager
- * 6. 🚨 NEW: Correct date/year context to prevent 2023 assumptions (BUG-00184 FIXED)
- * 7. 🛠️ NEW: Last seating rule awareness (BUG FIX 1)
- * 8. 🛠️ NEW: Guest count confirmation for returning guests (BUG FIX 2)
- * 9. 🔧 CRITICAL: Final booking command positioned at end to prevent date hallucination
- * 10. 🚨 BUG #3 FIX: Prevents premature availability checks with strict validation
- * 11. 🚨 BUG #4 FIX: Eliminates circular references in pending confirmation structure
- */
 export class SofiaAgent extends BaseAgent {
     readonly name = 'Sofia';
     readonly description = 'Production-ready booking specialist with critical bug fixes applied';
@@ -246,11 +230,25 @@ export class SofiaAgent extends BaseAgent {
 `;
             }
         }
-
+        let preProcessedDataInstructions = '';
+        const { date, time } = context.conversationContext?.gatheringInfo || {};
+
+        // 1. Check if our normalization step has already run and provided clean data.
+        if (date && time) {
+            preProcessedDataInstructions = `
+            🚨 CRITICAL PRE-PROCESSED DATA:
+            - The date for this booking has been pre-validated as: ${date}
+            - The time for this booking has been pre-validated as: ${time}
+            - YOUR TASK: Accept this date and time as correct. DO NOT change or re-interpret them.
+            - Your ONLY job now is to gather the REMAINING information (e.g., number of guests).
+            `;
+        }
         return `You are Sofia, the friendly booking specialist for ${this.restaurantConfig.name}.
 
 ${languageInstruction}
 
+${preProcessedDataInstructions}
+
 🎯 YOUR ROLE: Expert Conversation Specialist
 Create smooth, efficient booking experiences by using context intelligently and maintaining natural flow.
 
@@ -274,6 +272,12 @@ ${isOvernightOperation(this.restaurantConfig.openingTime || '09:00', this.restau
 - Current time: ${dateContext.currentTime}
 - Restaurant status: ${dateContext.isOpen ? 'OPEN 🟢' : 'CLOSED 🔴'}
 
+🕐 CURRENT TIME BOOKING RULES:
+- If user requests "now" or current time (${dateContext.currentTime}), validate against operating hours
+- If restaurant closes soon, inform guest of closing time
+- If restaurant is closed, suggest next available time
+- Always be transparent about current time constraints
+
 🚨 CRITICAL DATE PARSING RULES (PREVENTS 2023 BUG):
 - CURRENT YEAR: ${dateContext.currentYear}
 - NEXT YEAR: ${dateContext.nextYear}
@@ -336,6 +340,23 @@ When ANY booking validation fails and user provides new information:
 **RATIONALE:** Validation failures often indicate broader context changes.
 **EXCEPTION:** Skip re-confirmation if date/party size were explicitly confirmed in the last 2 exchanges.
 
+🚨 CRITICAL SUMMARY RULE:
+When summarizing booking details, you MUST ONLY mention details present in the 'gatheringInfo' context.
+- If 'gatheringInfo.guests' is missing, DO NOT mention party size
+- Instead, ask for it again: "How many guests will be joining you?"
+- This prevents misleading confirmations that create user confusion
+
+🚨 CRITICAL GUEST COUNT VALIDATION (BUG FIX):
+When users say collective numerals like:
+- Russian: "вчетвером" (we four), "втроем" (we three), "вдвоем" (we two)  
+- Serbian: "nas četvoro" (four of us), "u troje" (three of us)
+- Hungarian: "négyen leszünk" (we will be four), "hárman" (three of us)
+- German: "zu viert" (as four), "wir sind drei" (we are three)
+- French: "à quatre" (as four), "nous sommes trois" (we are three)
+
+These are VALID guest counts that must be extracted correctly.
+NEVER reject these natural language expressions.
+The system will validate them using multilingual patterns.
 🤝 CONVERSATION STYLE:
 - **Warm & Welcoming**: "I'd love to help you with that!"
 - **Efficient**: Acknowledge information already provided
@@ -1110,6 +1131,66 @@ Or simply type "1" or "2" to choose. After this, I'll automatically use "${reque
         return matrix[str2.length][str1.length];
     }
 
+    /**
+     * 🚨 NEW: Validate if requested time is current time and handle appropriately
+     */
+    private validateCurrentTimeBooking(
+        requestedTime: string,
+        restaurantTimezone: string
+    ): {
+        isCurrentTime: boolean,
+        isWithinOperatingHours: boolean,
+        minutesUntilClose?: number,
+        recommendation?: string
+    } {
+        try {
+            const currentTime = getRestaurantDateTime(restaurantTimezone);
+            const currentTimeString = currentTime.toFormat('HH:mm');
+
+            // Check if requested time is very close to current time (within 5 minutes)
+            const requestedDateTime = DateTime.fromFormat(requestedTime, 'HH:mm');
+            const diffMinutes = Math.abs(requestedDateTime.diff(currentTime, 'minutes').minutes);
+
+            const isCurrentTime = diffMinutes <= 5;
+
+            if (isCurrentTime) {
+                // Check restaurant operating hours
+                const operatingStatus = getRestaurantOperatingStatus(
+                    restaurantTimezone,
+                    this.restaurantConfig.openingTime || '09:00',
+                    this.restaurantConfig.closingTime || '23:00'
+                );
+
+                return {
+                    isCurrentTime: true,
+                    isWithinOperatingHours: operatingStatus.isOpen,
+                    minutesUntilClose: operatingStatus.minutesUntilClose,
+                    recommendation: !operatingStatus.isOpen
+                        ? 'Restaurant is currently closed'
+                        : operatingStatus.minutesUntilClose && operatingStatus.minutesUntilClose < 60
+                            ? `Note: Restaurant closes in ${operatingStatus.minutesUntilClose} minutes`
+                            : undefined
+                };
+            }
+
+            return {
+                isCurrentTime: false,
+                isWithinOperatingHours: true // We'll let normal validation handle this
+            };
+
+        } catch (error) {
+            this.logAgentAction('Error validating current time booking', {
+                error: (error as Error).message,
+                requestedTime,
+                restaurantTimezone
+            });
+            return {
+                isCurrentTime: false,
+                isWithinOperatingHours: true
+            };
+        }
+    }
+
     /**
      * 🔒 SECURITY: Input sanitization
      */
diff --git a/server/services/availability.service.ts b/server/services/availability.service.ts
index 77b7801..2ef9fe3 100644
--- a/server/services/availability.service.ts
+++ b/server/services/availability.service.ts
@@ -490,14 +490,14 @@ async function findCombinableTwoTableSlots(
         );
     });
 
-    if (availableTablesInSlot.length < 2) return [];
+    if (filteredCombinableTables.length < 2) return [];
 
-    availableTablesInSlot.sort((a, b) => a.maxGuests - b.maxGuests);
+    filteredCombinableTables.sort((a, b) => a.maxGuests - b.maxGuests);
 
-    for (let i = 0; i < availableTablesInSlot.length; i++) {
-        for (let j = i + 1; j < availableTablesInSlot.length; j++) {
-            const table1 = availableTablesInSlot[i];
-            const table2 = availableTablesInSlot[j];
+    for (let i = 0; i < filteredCombinableTables.length; i++) {
+        for (let j = i + 1; j < filteredCombinableTables.length; j++) {
+            const table1 = filteredCombinableTables[i];
+            const table2 = filteredCombinableTables[j];
 
             const combinedMinCapacity = table1.minGuests + table2.minGuests;
             const combinedMaxCapacity = table1.maxGuests + table2.maxGuests;
diff --git a/server/services/confirmation.service.ts b/server/services/confirmation.service.ts
index 5e0a965..700fde4 100644
--- a/server/services/confirmation.service.ts
+++ b/server/services/confirmation.service.ts
@@ -7,6 +7,7 @@ import { aiService } from './ai-service';
 import { agentFunctions } from './agents/agent-tools';
 import { smartLog } from './smart-logging.service';
 import type { TenantContext } from './tenant-context';
+import { sanitizeInternalComments } from '../utils/sanitization-utils'; 
 
 // Import types from ECM (these should eventually be moved to a shared types file)
 export type Language = 'en' | 'ru' | 'sr' | 'hu' | 'de' | 'fr' | 'es' | 'it' | 'pt' | 'nl' | 'auto';
@@ -181,6 +182,8 @@ export class ConfirmationService {
             };
 
             // Generate confirmation question
+            const sanitizedComments = sanitizeInternalComments(bookingData.comments); // Add this line
+
             const confirmationQuestion = await TranslationService.translateMessage(
                 `I have all the details for your reservation:
 
@@ -189,7 +192,7 @@ export class ConfirmationService {
 • ${bookingData.date} at ${bookingData.time}
 • Name: ${bookingData.name}
 • Phone: ${bookingData.phone}
-${bookingData.comments ? `• Special requests: ${bookingData.comments}` : ''}
+${sanitizedComments ? `• Special requests: ${sanitizedComments}` : ''}
 
 Shall I go ahead and confirm this booking?`,
                 session.language,
diff --git a/server/services/enhanced-conversation-manager.ts b/server/services/enhanced-conversation-manager.ts
index ecebc11..d857538 100644
--- a/server/services/enhanced-conversation-manager.ts
+++ b/server/services/enhanced-conversation-manager.ts
@@ -8,7 +8,7 @@ import { runGuardrails, requiresConfirmation, type GuardrailResult } from './gua
 import type { Restaurant } from '@shared/schema';
 import { DateTime } from 'luxon';
 import { normalizeTimePatterns } from '../utils/time-normalization-utils';
-
+import { sanitizeInternalComments } from '../utils/sanitization-utils';
 // 🚀 REDIS INTEGRATION: Import Redis service for session persistence
 import { redisService } from './redis-service';
 
@@ -16,12 +16,13 @@ import { redisService } from './redis-service';
 import {
     getRestaurantDateTime,
     getRestaurantTimeContext,
-    isValidTimezone
+    isValidTimezone,
+    getRestaurantOperatingStatus 
 } from '../utils/timezone-utils';
 
-// ✅ STEP 3B.1: Using ContextManager for all context resolution and management
+// ✅ Using ContextManager for all context resolution and management
 import { contextManager } from './context-manager';
-
+import { ValidationPatternLoader } from '../validation/pattern-loader';
 // 🚨 CRITICAL FIX BUG-20250725-001: Import tenant context manager for proper context loading
 import { tenantContextManager } from './tenant-context';
 import type { TenantContext } from './tenant-context';
@@ -561,7 +562,7 @@ export class EnhancedConversationManager {
      * BEFORE: Method created all fields with potential undefined values, overwriting existing session data
      * AFTER: Method only includes fields that actually have values, preserving existing session state
      */
-    private validateExtractedData(extraction: any, originalMessage: string): any {
+    private async validateExtractedData(extraction: any, originalMessage: string, session: BookingSessionWithAgent): Promise<any> {
         const validated: any = {};
 
         // ✅ CONTEXT AMNESIA FIX: Only add fields that actually have values
@@ -588,7 +589,7 @@ export class EnhancedConversationManager {
         }
 
         if (extraction.guests) {
-            const validatedGuests = this.validateGuestsField(extraction.guests, originalMessage);
+            const validatedGuests = this.validateGuestsField(extraction.guests, originalMessage, session);
             if (validatedGuests) validated.guests = validatedGuests;
         }
 
@@ -626,7 +627,8 @@ export class EnhancedConversationManager {
                 language: session.language,
                 restaurantContext: true,
                 sessionId: session.sessionId,
-                logChanges: true
+                logChanges: true,
+                restaurantTimezone: session.timezone
             });
             const normalizedMessage = normalizationResult.normalizedMessage;
 
@@ -640,6 +642,7 @@ EXISTING CONFIRMED INFO: ${JSON.stringify(session.gatheringInfo)}
 LAST ASSISTANT MESSAGE: "${lastAssistantMessage}"
 USER'S LATEST MESSAGE: "${normalizedMessage}"
 CURRENT DATE CONTEXT: Today is ${dateContext.todayDate}.
+CURRENT TIME CONTEXT: Current restaurant time is ${dateContext.currentTime}.
 
 YOUR CRITICAL TASK:
 - Analyze ONLY the "USER'S LATEST MESSAGE".
@@ -648,6 +651,12 @@ YOUR CRITICAL TASK:
 - If a field is NOT MENTIONED in the user's latest message, DO NOT include it in your JSON output.
 - Do NOT invent or assume details. Your output must only contain information from the latest message.
 
+**CRITICAL TIME HANDLING RULES:**
+- If the message contains specific times like "19:30", "7 PM", extract as "time"
+- If the message was normalized from "now" expressions (check if time matches current time ${dateContext.currentTime}), extract as "time"
+- If the user says current/immediate time expressions, this means they want to book NOW, extract current time
+- DO NOT put temporal expressions in comments if they represent the desired booking time
+
 **CRITICAL TIME LOOP PREVENTION RULE:**
 - IF the "LAST ASSISTANT MESSAGE" asked the user to clarify a time (e.g., "please select a specific time")
 - AND the "USER'S LATEST MESSAGE" is an ambiguous time range (e.g., "4-8pm", "16-20"),
@@ -685,7 +694,8 @@ Extract ONLY the relevant fields from the "USER'S LATEST MESSAGE":
   "time": "Time in HH:MM format (null if not in CURRENT message)",
   "guests": "Number of people (null if not in CURRENT message)",
   "name": "Guest name if mentioned (null if not in CURRENT message)",
-  "comments": "Special requests or ambiguous time clarifications (null if not in CURRENT message)"
+  "comments": "Special requests EXPLICITLY MADE BY THE USER (null if none)",
+  "internalDiagnostics": "YOUR reasoning, notes on ambiguity, or system observations (null if none)"
 }`;
             // ✅ CRITICAL FIX: Always pass tenantContext to the AI service
             const extraction = await aiService.generateJSON(prompt, {
@@ -695,7 +705,15 @@ Extract ONLY the relevant fields from the "USER'S LATEST MESSAGE":
             }, session.tenantContext!);
 
             // ✅ BUG-20250727-001 FIX: Use the fixed validateExtractedData method
-            const validatedExtraction = this.validateExtractedData(extraction, normalizedMessage);
+            const validatedExtraction = await this.validateExtractedData(extraction, normalizedMessage, session);
+
+            if (extraction.internalDiagnostics) {
+                session.gatheringInfo.internalDiagnostics = (session.gatheringInfo.internalDiagnostics || '') + ` | ${extraction.internalDiagnostics}`;
+                smartLog.info('Internal diagnostics from AI captured', {
+                    sessionId: session.sessionId,
+                    diagnostics: extraction.internalDiagnostics
+                });
+            }
 
             // ✅ NAME MISMATCH DETECTION: Check if user requested a different name than guest history
             if (validatedExtraction.name && session.guestHistory?.guest_name && 
@@ -927,7 +945,7 @@ Extract ONLY the relevant fields from the "USER'S LATEST MESSAGE":
     /**
      * 🚨 CRITICAL: Validate guests field to prevent hallucination
      */
-    private validateGuestsField(value: any, originalMessage: string): number | undefined {
+    private validateGuestsField(value: any, originalMessage: string, session: BookingSessionWithAgent): number | undefined {
         if (typeof value === 'string') {
             const numValue = parseInt(value, 10);
             if (!isNaN(numValue)) {
@@ -939,26 +957,49 @@ Extract ONLY the relevant fields from the "USER'S LATEST MESSAGE":
             return undefined;
         }
 
+        // 🚀 CRITICAL FIX: Load patterns dynamically based on session language
+        const patterns = ValidationPatternLoader.loadGuestPatterns(session.language || 'en');
         const cleanMessage = originalMessage.toLowerCase();
 
-        const guestIndicators = [
-            String(value),
-            /\d+\s*(people|person|guest|человек|людей|гостей|osoba|ljudi|fő|személy|personen|person|personnes|personne|personas|persona|persone|pessoa|pessoas|personen|persoon)/i,
-            'table for', 'столик на', 'sto za', 'asztal', 'tisch für', 'table pour', 'mesa para', 'tavolo per', 'mesa para', 'tafel voor'
-        ];
+        // Check collective numerals FIRST (THE MAIN FIX)
+        if (patterns.collectiveNumerals) {
+            for (const [term, expectedValue] of Object.entries(patterns.collectiveNumerals)) {
+                if (cleanMessage.includes(term.toLowerCase()) && value === expectedValue) {
+                    smartLog.info('Collective numeral validation success', {
+                        term,
+                        expectedValue,
+                        language: session.language,
+                        bugFixed: 'RUSSIAN_COLLECTIVE_NUMERALS'
+                    });
+                    return value;
+                }
+            }
+        }
 
-        const hasGuestIndicator = guestIndicators.some(indicator => {
-            if (typeof indicator === 'string') {
-                return cleanMessage.includes(indicator);
-            } else {
-                return indicator.test(cleanMessage);
+        // Check phrase patterns
+        if (patterns.phrases) {
+            const hasPhrase = patterns.phrases.some(phrase =>
+                cleanMessage.includes(phrase.toLowerCase())
+            );
+            if (hasPhrase && value >= 1 && value <= 50) {
+                smartLog.info('Phrase pattern validation success', {
+                    value,
+                    language: session.language,
+                    matchedPhrase: patterns.phrases.find(p => cleanMessage.includes(p.toLowerCase()))
+                });
+                return value;
             }
-        });
+        }
+
+        // Keep existing regex as fallback
+        const guestIndicators = patterns.regexPatterns.map(pattern => new RegExp(pattern, 'gi'));
+        const hasGuestIndicator = guestIndicators.some(regex => regex.test(originalMessage));
 
         if (!hasGuestIndicator) {
-            smartLog.warn('Guest count extraction prevented - no guest indicators in message', {
+            smartLog.warn('Guest count extraction prevented - no indicators found', {
                 extractedGuests: value,
-                originalMessage,
+                originalMessage: originalMessage.substring(0, 100),
+                language: session.language,
                 preventedHallucination: true
             });
             return undefined;
@@ -2521,6 +2562,7 @@ Respond with JSON only:
         validationStatus?: any
     ): string {
         const { name, phone, date, time, guests, comments } = bookingData;
+        const sanitizedComment = sanitizeInternalComments(comments);
         const templates: Record<string, string> = {
             en: `🎉 Reservation Confirmed! 
 
@@ -2531,7 +2573,7 @@ Respond with JSON only:
 • Date: ${date}
 • Time: ${time}
 • Guests: ${guests}
-${comments ? `• Special requests: ${comments}` : ''}
+${sanitizedComment ? `• Special requests: ${sanitizedComment}` : ''}
 
 ✅ All details validated and confirmed.
 📞 We'll call if any changes are needed.`,
@@ -2544,7 +2586,7 @@ ${comments ? `• Special requests: ${comments}` : ''}
 • Дата: ${date}  
 • Время: ${time}
 • Гостей: ${guests}
-${comments ? `• Особые пожелания: ${comments}` : ''}
+${sanitizedComment ? `• Особые пожелания: ${sanitizedComment}` : ''}
 
 ✅ Все данные проверены и подтверждены.
 📞 Перезвоним при необходимости.`,
@@ -2557,7 +2599,7 @@ ${comments ? `• Особые пожелания: ${comments}` : ''}
 • Datum: ${date}
 • Vreme: ${time}
 • Gostiju: ${guests}
-${comments ? `• Posebni zahtevi: ${comments}` : ''}
+${sanitizedComment ? `• Posebni zahtevi: ${sanitizedComment}` : ''}
 
 ✅ Svi podaci provereni i potvrđeni.
 📞 Pozvaćemo ako su potrebne izmene.`,
@@ -2570,7 +2612,7 @@ ${comments ? `• Posebni zahtevi: ${comments}` : ''}
 • Dátum: ${date}
 • Idő: ${time}
 • Vendégek: ${guests}
-${comments ? `• Különleges kérések: ${comments}` : ''}
+${sanitizedComment ? `• Különleges kérések: ${sanitizedComment}` : ''}
 
 ✅ Minden adat ellenőrizve és megerősítve.
 📞 Felhívjuk, ha változásokra van szükség.`,
@@ -2583,7 +2625,7 @@ ${comments ? `• Különleges kérések: ${comments}` : ''}
 • Datum: ${date}
 • Zeit: ${time}
 • Gäste: ${guests}
-${comments ? `• Besondere Wünsche: ${comments}` : ''}
+${sanitizedComment ? `• Besondere Wünsche: ${sanitizedComment}` : ''}
 
 ✅ Alle Details validiert und bestätigt.
 📞 Wir rufen an, falls Änderungen nötig sind.`,
@@ -2596,7 +2638,7 @@ ${comments ? `• Besondere Wünsche: ${comments}` : ''}
 • Date : ${date}
 • Heure : ${time}
 • Convives : ${guests}
-${comments ? `• Demandes spéciales : ${comments}` : ''}
+${sanitizedComment ? `• Demandes spéciales : ${sanitizedComment}` : ''}
 
 ✅ Tous les détails validés et confirmés.
 📞 Nous vous appellerons si des changements sont nécessaires.`,
@@ -2609,7 +2651,7 @@ ${comments ? `• Demandes spéciales : ${comments}` : ''}
 • Fecha: ${date}
 • Hora: ${time}
 • Comensales: ${guests}
-${comments ? `• Solicitudes especiales: ${comments}` : ''}
+${sanitizedComment ? `• Solicitudes especiales: ${sanitizedComment}` : ''}
 
 ✅ Todos los detalles validados y confirmados.
 📞 Te llamaremos si necesitamos cambios.`,
@@ -2622,7 +2664,7 @@ ${comments ? `• Solicitudes especiales: ${comments}` : ''}
 • Data: ${date}
 • Ora: ${time}
 • Ospiti: ${guests}
-${comments ? `• Richieste speciali: ${comments}` : ''}
+${sanitizedComment ? `• Richieste speciali: ${sanitizedComment}` : ''}
 
 ✅ Tutti i dettagli validati e confermati.
 📞 Ti chiameremo se servono modifiche.`,
@@ -2635,7 +2677,7 @@ ${comments ? `• Richieste speciali: ${comments}` : ''}
 • Data: ${date}
 • Hora: ${time}
 • Convidados: ${guests}
-${comments ? `• Solicitações especiais: ${comments}` : ''}
+${sanitizedComment ? `• Solicitações especiais: ${sanitizedComment}` : ''}
 
 ✅ Todos os detalhes validados e confirmados.
 📞 Ligaremos se precisarmos de alterações.`,
@@ -2648,7 +2690,7 @@ ${comments ? `• Solicitações especiais: ${comments}` : ''}
 • Datum: ${date}
 • Tijd: ${time}
 • Gasten: ${guests}
-${comments ? `• Speciale verzoeken: ${comments}` : ''}
+${sanitizedComment ? `• Speciale verzoeken: ${sanitizedComment}` : ''}
 
 ✅ Alle details gevalideerd en bevestigd.
 📞 We bellen als er wijzigingen nodig zijn.`
@@ -2842,6 +2884,38 @@ ${comments ? `• Speciale verzoeken: ${comments}` : ''}
 
         const isFirstMessage = session.conversationHistory.length === 0;
 
+        if (isFirstMessage) {
+            // 1. Get the restaurant's current operational status.
+            const restaurantStatus = getRestaurantOperatingStatus(
+                session.timezone,
+                session.tenantContext.restaurant.openingTime,
+                session.tenantContext.restaurant.closingTime
+            );
+
+            // 2. Check if we're in the after-midnight window (e.g., between 00:00 and 03:00).
+            const isAfterMidnightNow = restaurantStatus.isOpen && restaurantStatus.isOvernightOperation;
+
+            // 3. Check for ambiguous "today" + "at night" phrases.
+            const containsAmbiguousTime = /сегодня|today|tonight/i.test(sanitizedMessage) && /ночи|night|am|a.m./i.test(sanitizedMessage);
+
+            if (isAfterMidnightNow && containsAmbiguousTime) {
+                smartLog.info('After-midnight edge case detected. Engaging high-precision time normalization.', { sessionId });
+
+                // 4. Call the new high-precision normalization function (created in Step 2).
+                const normalizedTime = await normalizeAfterMidnightTime(
+                    sanitizedMessage,
+                    session.tenantContext
+                );
+
+                // 5. If successful, inject the clean, unambiguous date and time into the session.
+                if (normalizedTime.date && normalizedTime.time) {
+                    session.gatheringInfo.date = normalizedTime.date;
+                    session.gatheringInfo.time = normalizedTime.time;
+                    smartLog.info('Successfully injected normalized date and time into session.', { sessionId, date: normalizedTime.date, time: normalizedTime.time });
+                }
+            }
+        }
+
         // 🚨 FIX: Make language detection a blocking step at the start of the conversation
         if (isFirstMessage && !session.languageLocked) {
             smartLog.info('First message: Detecting language before proceeding...', { sessionId });
diff --git a/server/services/session-manager.ts b/server/services/session-manager.ts
index 8ce5434..96bc14a 100644
--- a/server/services/session-manager.ts
+++ b/server/services/session-manager.ts
@@ -35,6 +35,7 @@ export interface BookingSession {
         name?: string;
         phone?: string;
         comments?: string;
+        internalDiagnostics?: string;
     };
     conversationHistory: Array<{
         role: 'user' | 'assistant';
diff --git a/server/services/telegram_booking.ts b/server/services/telegram_booking.ts
index 6946361..b8ec897 100644
--- a/server/services/telegram_booking.ts
+++ b/server/services/telegram_booking.ts
@@ -16,6 +16,7 @@ import type { Language } from './enhanced-conversation-manager';
 import type { AvailabilitySlot as ServiceAvailabilitySlot } from './availability.service'; // Import AvailabilitySlot
 import type { TenantContext } from './tenant-context'; 
 import { wss } from '../index';
+import { sanitizeInternalComments } from '../utils/sanitization-utils';
 
 // Updated result type
 export type CreateTelegramReservationResult = {
diff --git a/server/storage.ts b/server/storage.ts
index ae73840..eea4bf3 100644
--- a/server/storage.ts
+++ b/server/storage.ts
@@ -1,19 +1,11 @@
-//
-// storage.ts (🔒 SECURITY FIXED: Complete Multi-Tenant Guest Isolation)
-// 🚨 CRITICAL FIXES APPLIED:
-// 1. Guest data privacy breach - Added restaurant scoping to all guest methods
-// 2. Currency data corruption - Updated all financial calculations for decimal types
-// 3. Complete tenant isolation across all operations
-// 4. Added missing super admin methods: getAllTenants and logSuperAdminActivity
-// 5. 🚨 NEW FIX: Added missing updateTenant method for super admin functionality
-// 6. ✅ BUG FIX: Fixed tenant feature flags bug in createTenantWithOwner method
-//
-
 import {
     users, restaurants, tables, guests, reservations,
     integrationSettings, aiActivities,
     reservationStatusHistory, menuItems, restaurantMenuCategories, menuSearchLog,
     superAdmins, tenantAuditLogs, tenantUsageMetrics, planLimits,
+    // ✅ NEW: Import floor-related schema and types
+    floors,
+    type Floor, type InsertFloor,
     type User, type InsertUser,
     type Restaurant, type InsertRestaurant,
     type Table, type InsertTable,
@@ -30,51 +22,108 @@ import {
     type TenantUsageMetrics, type PlanLimits
 } from "@shared/schema";
 import { db } from "./db";
-import { eq, and, gte, lte, desc, sql, count, or, inArray, gt, ne, notExists, like, ilike } from "drizzle-orm";
+import { eq, and, gte, lte, desc, sql, count, or, inArray, gt, ne, notExists, like, ilike, sum, avg } from "drizzle-orm";
 import { DateTime } from 'luxon';
-import bcrypt from 'bcryptjs'; 
-// ✅ PROPER FIX: Use centralized timezone utilities for consistency across the application
+import bcrypt from 'bcryptjs';
 import { getRestaurantDateTime, getRestaurantDateString } from './utils/timezone-utils';
-// ✅ NEW: Import tenant context system
-import { 
-    tenantContextManager, 
-    validateTenantAction, 
+import {
+    tenantContextManager,
+    validateTenantAction,
     trackTenantUsage,
-    type TenantContext 
+    type TenantContext
 } from './services/tenant-context';
 
-// ✅ TYPE SAFETY FIX: Define valid reservation statuses
 type ReservationStatus = 'confirmed' | 'created' | 'canceled' | 'completed' | 'archived' | 'seated' | 'in_progress' | 'no_show';
 
+// ✅ NEW: Define the structure for the detailed analytics data
+export interface AnalyticsOverview {
+    timeframe: {
+        start: string;
+        end: string;
+        timezone: string;
+    };
+    revenue: {
+        totalRevenue: string;
+        avgRevenuePerBooking: string;
+        sources: { source: string; revenue: string; count: number }[];
+    };
+    reservations: {
+        total: number;
+        byStatus: Record<string, number>;
+        funnel: {
+            created: number;
+            confirmed: number;
+            seated: number;
+            completed: number;
+            noShowRate: number;
+            cancellationRate: number;
+        };
+        avgGuests: number;
+        bySource: { source: string; count: number }[];
+    };
+    guests: {
+        total: number;
+        new: number;
+        returning: number;
+        segmentation: {
+            vip: number;
+            regulars: number;
+            atRisk: number;
+        };
+    };
+    tables: {
+        performance: {
+            id: number;
+            name: string;
+            bookingCount: number;
+            revenue: string;
+            avgGuests: number;
+        }[];
+        turnaroundTime: number;
+    };
+    operations: {
+        seatingEfficiency: number; // avg time from confirmed to seated
+        popularTimes: { hour: number; count: number }[];
+    };
+}
+
+
 export interface IStorage {
-    // ✅ EXISTING: User methods
+    // User methods
     getUser(id: number): Promise<User | undefined>;
     getUserByEmail(email: string): Promise<User | undefined>;
     createUser(user: InsertUser): Promise<User>;
 
-    // ✅ EXISTING: Restaurant methods
+    // Restaurant methods
     getRestaurant(id: number): Promise<Restaurant | undefined>;
     getRestaurantByUserId(userId: number): Promise<Restaurant | undefined>;
     getAllRestaurants(): Promise<Restaurant[]>;
     createRestaurant(restaurant: InsertRestaurant): Promise<Restaurant>;
     updateRestaurant(id: number, restaurant: Partial<InsertRestaurant>): Promise<Restaurant>;
 
-    // ✅ ENHANCED: Table methods with tenant context
-    getTables(restaurantId: number): Promise<Table[]>;
+    // ✅ NEW: Floor methods
+    getFloors(restaurantId: number): Promise<Floor[]>;
+    getFloor(id: number): Promise<Floor | undefined>;
+    createFloor(floor: InsertFloor): Promise<Floor>;
+    updateFloor(id: number, floor: Partial<InsertFloor>): Promise<Floor>;
+    deleteFloor(id: number): Promise<void>;
+
+    // Table methods
+    getTables(restaurantId: number, floorId?: number): Promise<Table[]>; // 🔄 Modified
     getTable(id: number): Promise<Table | undefined>;
     createTable(table: InsertTable, tenantContext?: TenantContext): Promise<Table>;
     updateTable(id: number, table: Partial<InsertTable>): Promise<Table>;
     deleteTable(id: number): Promise<void>;
 
-    // 🔒 SECURITY FIXED: Guest methods with restaurant scoping
+    // Guest methods
     getGuests(restaurantId: number): Promise<Guest[]>;
     getGuest(id: number, restaurantId: number): Promise<Guest | undefined>;
-    getGuestByPhone(phone: string, restaurantId: number): Promise<Guest | undefined>; // ✅ SECURITY FIX: Added restaurantId
-    getGuestByTelegramId(telegramUserId: string, restaurantId: number): Promise<Guest | undefined>; // ✅ SECURITY FIX: Added restaurantId
-    createGuest(guest: InsertGuest): Promise<Guest>; // ✅ SECURITY: guest.restaurantId required in schema
-    updateGuest(id: number, guest: Partial<InsertGuest>, restaurantId: number): Promise<Guest>; // ✅ SECURITY FIX: Added restaurantId
+    getGuestByPhone(phone: string, restaurantId: number): Promise<Guest | undefined>;
+    getGuestByTelegramId(telegramUserId: string, restaurantId: number): Promise<Guest | undefined>;
+    createGuest(guest: InsertGuest): Promise<Guest>;
+    updateGuest(id: number, guest: Partial<InsertGuest>, restaurantId: number): Promise<Guest>;
 
-    // ✅ ENHANCED: Reservation methods with tenant context
+    // Reservation methods
     getReservations(restaurantId: number, filters?: {
         date?: string;
         status?: string[];
@@ -98,9 +147,9 @@ export interface IStorage {
         totalGuests: number;
     }>;
 
-    // ✅ NEW: Enhanced reservation status management
+    // Reservation status management
     updateReservationWithHistory(
-        reservationId: number, 
+        reservationId: number,
         updateData: Partial<InsertReservation>,
         historyData: {
             changedBy: 'system' | 'staff' | 'guest';
@@ -111,7 +160,7 @@ export interface IStorage {
     getStatusChangeTime(reservationId: number, status: string): Promise<Date | null>;
     getReservationStatusHistory(reservationId: number): Promise<ReservationStatusHistory[]>;
 
-    // ✅ NEW: Enhanced guest analytics
+    // Guest analytics
     updateGuestAnalytics(
         guestId: number,
         analytics: {
@@ -120,11 +169,14 @@ export interface IStorage {
             duration?: number;
             totalSpent?: number;
         },
-        restaurantId: number // ✅ SECURITY FIX: Added restaurantId
+        restaurantId: number
     ): Promise<Guest>;
     getGuestReservationHistory(guestId: number, restaurantId: number): Promise<any[]>;
 
-    // ✅ NEW: Menu management system
+    // ✅ NEW: Advanced Analytics Method
+    getAnalyticsOverview(restaurantId: number, timezone: string, days?: number): Promise<AnalyticsOverview>;
+
+    // Menu management system
     getMenuItems(restaurantId: number, filters?: {
         category?: string;
         availableOnly?: boolean;
@@ -136,7 +188,7 @@ export interface IStorage {
     getMenuItem(id: number): Promise<MenuItem | undefined>;
     updateMenuItem(id: number, data: Partial<InsertMenuItem>): Promise<MenuItem>;
     deleteMenuItem(id: number): Promise<void>;
-    getMenuCategoryByName(restaurantId: number, name: string): Promise<RestaurantMenuCategory | undefined>;
+    getOrCreateMenuCategoryByName(restaurantId: number, name: string): Promise<RestaurantMenuCategory>;
     searchMenuItems(restaurantId: number, options: {
         query: string;
         category?: string;
@@ -160,20 +212,27 @@ export interface IStorage {
     getPopularMenuItems(restaurantId: number, limit?: number): Promise<MenuItem[]>;
     logMenuSearch(restaurantId: number, query: string, source: string): Promise<MenuSearchLog>;
 
-    // ✅ EXISTING: Integration settings methods
+    // Menu Category CRUD methods
+    getMenuCategories(restaurantId: number): Promise<RestaurantMenuCategory[]>;
+    getMenuCategory(id: number): Promise<RestaurantMenuCategory | undefined>;
+    createMenuCategory(data: InsertRestaurantMenuCategory): Promise<RestaurantMenuCategory>;
+    updateMenuCategory(id: number, data: Partial<InsertRestaurantMenuCategory>): Promise<RestaurantMenuCategory>;
+    deleteMenuCategory(id: number): Promise<void>;
+
+    // Integration settings methods
     getIntegrationSettings(restaurantId: number, type: string): Promise<IntegrationSetting | undefined>;
     saveIntegrationSettings(settings: InsertIntegrationSetting): Promise<IntegrationSetting>;
 
-    // ✅ EXISTING: AI activities methods
+    // AI activities methods
     getAiActivities(restaurantId: number, limit?: number): Promise<AiActivity[]>;
     logAiActivity(activity: InsertAiActivity): Promise<AiActivity>;
 
-    // ✅ EXISTING: Real-time table availability methods
+    // Real-time table availability methods
     updateTableStatusFromReservations(tableId: number, restaurantTimezone: string): Promise<void>;
     updateAllTableStatuses(restaurantId: number, restaurantTimezone: string): Promise<void>;
     getTableAvailability(restaurantId: number, date: string, time: string, excludeReservationId?: number): Promise<Table[]>;
 
-    // ✅ NEW: Multi-tenant management methods
+    // Multi-tenant management methods
     getSuperAdmin(id: number): Promise<SuperAdmin | undefined>;
     getSuperAdminByEmail(email: string): Promise<SuperAdmin | undefined>;
     createSuperAdmin(admin: InsertSuperAdmin): Promise<SuperAdmin>;
@@ -196,7 +255,7 @@ export interface IStorage {
         tenantsByPlan: any[];
     }>;
 
-    // 🚨 MISSING METHODS ADDED: Super admin tenant management
+    // Super admin tenant management
     getAllTenants(filters: {
         page: number;
         limit: number;
@@ -238,14 +297,14 @@ export interface IStorage {
         customSettings?: object;
     }): Promise<{ restaurant: Restaurant, owner: User }>;
 
-    // 🚨 MISSING METHODS ADDED: Tenant detail view functions
+    // Tenant detail view functions
     getTenantById(tenantId: number): Promise<any | undefined>;
     getTenantMetrics(tenantId: number): Promise<any>;
     getTenantUsage(tenantId: number): Promise<any>;
     getTenantRecentActivity(tenantId: number, limit: number): Promise<any[]>;
     getTenantAuditLogs(tenantId: number, options: { limit: number; offset: number }): Promise<any[]>;
 
-    // 🚨 CRITICAL FIX: Add missing updateTenant method
+    // updateTenant method
     updateTenant(tenantId: number, data: {
         restaurantName?: string;
         subdomain?: string;
@@ -266,7 +325,7 @@ export interface IStorage {
 }
 
 export class DatabaseStorage implements IStorage {
-    
+
     private parseTimeToMinutes(timeStr: string): number {
         if (!timeStr) {
             throw new Error(`Invalid time string: ${timeStr}`);
@@ -292,7 +351,6 @@ export class DatabaseStorage implements IStorage {
         }
     }
 
-    // 🔒 CURRENCY HELPER: Safe decimal operations
     private addDecimal(a: string | number, b: string | number): string {
         const numA = typeof a === 'string' ? parseFloat(a) : a;
         const numB = typeof b === 'string' ? parseFloat(b) : b;
@@ -304,10 +362,6 @@ export class DatabaseStorage implements IStorage {
         return Math.round((currentAvg * currentCount + newValue) / (currentCount + 1));
     }
 
-    // ================================
-    // ✅ EXISTING USER METHODS
-    // ================================
-
     async getUser(id: number): Promise<User | undefined> {
         const [user] = await db.select().from(users).where(eq(users.id, id));
         return user;
@@ -323,10 +377,6 @@ export class DatabaseStorage implements IStorage {
         return newUser;
     }
 
-    // ================================
-    // ✅ EXISTING RESTAURANT METHODS
-    // ================================
-
     async getRestaurant(id: number): Promise<Restaurant | undefined> {
         const [restaurant] = await db.select().from(restaurants).where(eq(restaurants.id, id));
         return restaurant;
@@ -355,10 +405,6 @@ export class DatabaseStorage implements IStorage {
         return updatedRestaurant;
     }
 
-    // ================================
-    // 🚨 CRITICAL FIX: MISSING updateTenant METHOD IMPLEMENTATION
-    // ================================
-
     async updateTenant(tenantId: number, data: {
         restaurantName?: string;
         subdomain?: string;
@@ -377,51 +423,35 @@ export class DatabaseStorage implements IStorage {
         customSettings?: any;
     }): Promise<Restaurant> {
         console.log(`🏢 [Storage] Updating tenant ${tenantId} with data:`, Object.keys(data));
-        
+
         return await db.transaction(async (tx) => {
-            // Prepare restaurant updates with proper field mapping
             const updates: Partial<InsertRestaurant> = {};
-            
-            // Basic restaurant fields
             if (data.restaurantName !== undefined) updates.name = data.restaurantName;
             if (data.subdomain !== undefined) updates.subdomain = data.subdomain;
             if (data.plan !== undefined) updates.tenantPlan = data.plan;
             if (data.status !== undefined) updates.tenantStatus = data.status;
             if (data.timezone !== undefined) updates.timezone = data.timezone;
-            
-            // Feature flags (exact field mapping)
             if (data.enableAiChat !== undefined) updates.enableAiChat = data.enableAiChat;
             if (data.enableTelegramBot !== undefined) updates.enableTelegramBot = data.enableTelegramBot;
             if (data.enableGuestAnalytics !== undefined) updates.enableGuestAnalytics = data.enableGuestAnalytics;
             if (data.enableAdvancedReporting !== undefined) updates.enableAdvancedReporting = data.enableAdvancedReporting;
             if (data.enableMenuManagement !== undefined) updates.enableMenuManagement = data.enableMenuManagement;
-            
-            // Tenant limits (proper field mapping)
             if (data.maxTables !== undefined) updates.maxTablesAllowed = data.maxTables;
             if (data.maxUsers !== undefined) updates.maxStaffAccounts = data.maxUsers;
             if (data.maxReservationsPerMonth !== undefined) updates.maxMonthlyReservations = data.maxReservationsPerMonth;
-            
-            // Admin fields (if schema supports them - currently commented out)
-            // if (data.adminNotes !== undefined) updates.adminNotes = data.adminNotes;
-            // if (data.customSettings !== undefined) updates.customSettings = data.customSettings;
-            
-            // Always update modification timestamp
+            // @ts-ignore
             updates.lastModifiedAt = new Date();
-            
-            console.log(`🏢 [Storage] Applying ${Object.keys(updates).length} field updates to tenant ${tenantId}`);
-            
-            // Update the restaurant record
+
             const [updatedRestaurant] = await tx
                 .update(restaurants)
                 .set(updates)
                 .where(eq(restaurants.id, tenantId))
                 .returning();
-                
+
             if (!updatedRestaurant) {
                 throw new Error(`Tenant ${tenantId} not found`);
             }
-            
-            // Log audit event
+
             await this.logTenantAudit({
                 restaurantId: tenantId,
                 action: 'tenant_updated',
@@ -433,18 +463,44 @@ export class DatabaseStorage implements IStorage {
                     changes: data
                 }
             });
-            
-            console.log(`✅ [Storage] Tenant ${tenantId} updated successfully - ${Object.keys(updates).length} fields modified`);
+
             return updatedRestaurant;
         });
     }
 
-    // ================================
-    // ✅ ENHANCED TABLE METHODS WITH TENANT CONTEXT
-    // ================================
+    // ✅ NEW: Floor management methods
+    async getFloors(restaurantId: number): Promise<Floor[]> {
+        return db.select().from(floors)
+            .where(eq(floors.restaurantId, restaurantId))
+            .orderBy(floors.displayOrder, floors.name);
+    }
+
+    async getFloor(id: number): Promise<Floor | undefined> {
+        const [floor] = await db.select().from(floors).where(eq(floors.id, id));
+        return floor;
+    }
 
-    async getTables(restaurantId: number): Promise<Table[]> {
-        return db.select().from(tables).where(eq(tables.restaurantId, restaurantId));
+    async createFloor(floor: InsertFloor): Promise<Floor> {
+        const [newFloor] = await db.insert(floors).values(floor).returning();
+        return newFloor;
+    }
+
+    async updateFloor(id: number, floor: Partial<InsertFloor>): Promise<Floor> {
+        const [updatedFloor] = await db.update(floors).set(floor).where(eq(floors.id, id)).returning();
+        return updatedFloor;
+    }
+
+    async deleteFloor(id: number): Promise<void> {
+        await db.delete(floors).where(eq(floors.id, id));
+    }
+
+    // 🔄 MODIFIED: getTables now accepts an optional floorId to filter by
+    async getTables(restaurantId: number, floorId?: number): Promise<Table[]> {
+        const conditions = [eq(tables.restaurantId, restaurantId)];
+        if (floorId) {
+            conditions.push(eq(tables.floorId, floorId));
+        }
+        return db.select().from(tables).where(and(...conditions));
     }
 
     async getTable(id: number): Promise<Table | undefined> {
@@ -454,33 +510,27 @@ export class DatabaseStorage implements IStorage {
 
     async createTable(table: InsertTable, tenantContext?: TenantContext): Promise<Table> {
         console.log(`🏢 [Storage] Creating table for restaurant ${table.restaurantId}`);
-        
-        // Load tenant context if not provided
         const context = tenantContext || await tenantContextManager.loadContext(table.restaurantId);
         if (!context) {
             throw new Error('Tenant context not found');
         }
-        
-        // Check table limit
+
         const limitCheck = await validateTenantAction(table.restaurantId, 'create_table', context);
         if (!limitCheck.allowed) {
             console.log(`❌ [Storage] Table creation blocked: ${limitCheck.reason}`);
             throw new Error(limitCheck.reason || 'Table limit exceeded');
         }
-        
         console.log(`✅ [Storage] Table limit check passed (${context.usage.currentTableCount}/${context.limits.maxTables})`);
-        
+
         const [newTable] = await db.insert(tables).values(table).returning();
-        
-        // Log audit event
+
         await tenantContextManager.logAuditEvent({
             restaurantId: table.restaurantId,
             action: 'table_created',
-            performedBy: 'restaurant_owner', // TODO: Get actual user
+            performedBy: 'restaurant_owner',
             performedByType: 'restaurant',
             details: { tableId: newTable.id, tableName: newTable.name }
         });
-        
         console.log(`✅ [Storage] Table ${newTable.id} created successfully`);
         return newTable;
     }
@@ -498,17 +548,12 @@ export class DatabaseStorage implements IStorage {
         await db.delete(tables).where(eq(tables.id, id));
     }
 
-    // ================================
-    // 🔒 SECURITY FIXED: GUEST METHODS WITH RESTAURANT SCOPING
-    // ================================
-
     async getGuests(restaurantId: number): Promise<Guest[]> {
         console.log(`👥 [Storage] Getting guests for restaurant ${restaurantId} (TENANT SCOPED)`);
-        
         const guestsWithCounts = await db
             .select({
                 id: guests.id,
-                restaurantId: guests.restaurantId, // ✅ SECURITY: Include restaurant ID
+                restaurantId: guests.restaurantId,
                 name: guests.name,
                 phone: guests.phone,
                 email: guests.email,
@@ -531,124 +576,100 @@ export class DatabaseStorage implements IStorage {
             .from(guests)
             .leftJoin(reservations, and(
                 eq(guests.id, reservations.guestId),
-                eq(reservations.restaurantId, restaurantId) // ✅ SECURITY: Double-check restaurant scoping
+                eq(reservations.restaurantId, restaurantId)
             ))
-            .where(eq(guests.restaurantId, restaurantId)) // 🚨 CRITICAL SECURITY FIX: Filter by restaurant
+            .where(eq(guests.restaurantId, restaurantId))
             .groupBy(guests.id);
-
         console.log(`👥 [Storage] Found ${guestsWithCounts.length} guests for restaurant ${restaurantId}`);
         return guestsWithCounts as Guest[];
     }
 
     async getGuest(id: number, restaurantId: number): Promise<Guest | undefined> {
         console.log(`👤 [Storage] Getting guest ${id} for restaurant ${restaurantId} (TENANT SCOPED)`);
-        
         const [guest] = await db
             .select()
             .from(guests)
             .where(
                 and(
                     eq(guests.id, id),
-                    eq(guests.restaurantId, restaurantId) // 🚨 CRITICAL SECURITY FIX: Filter by restaurant
+                    eq(guests.restaurantId, restaurantId)
                 )
             );
-        
         if (!guest) {
             console.log(`👤 [Storage] Guest ${id} not found for restaurant ${restaurantId}`);
         }
-        
         return guest;
     }
 
-    // 🚨 CRITICAL SECURITY FIX: Guest lookup by phone with restaurant scoping
     async getGuestByPhone(phone: string, restaurantId: number): Promise<Guest | undefined> {
         console.log(`📞 [Storage] Getting guest by phone ${phone} for restaurant ${restaurantId} (TENANT SCOPED)`);
-        
         const [guest] = await db
             .select()
             .from(guests)
             .where(
                 and(
                     eq(guests.phone, phone),
-                    eq(guests.restaurantId, restaurantId) // 🚨 CRITICAL SECURITY FIX: Filter by restaurant
+                    eq(guests.restaurantId, restaurantId)
                 )
             );
-        
         if (guest) {
             console.log(`📞 [Storage] Found guest ${guest.id} (${guest.name}) for restaurant ${restaurantId}`);
         } else {
             console.log(`📞 [Storage] No guest found with phone ${phone} for restaurant ${restaurantId}`);
         }
-        
         return guest;
     }
 
-    // 🚨 CRITICAL SECURITY FIX: Guest lookup by Telegram ID with restaurant scoping
     async getGuestByTelegramId(telegramUserId: string, restaurantId: number): Promise<Guest | undefined> {
         console.log(`📱 [Storage] Getting guest by Telegram ID ${telegramUserId} for restaurant ${restaurantId} (TENANT SCOPED)`);
-        
         const [guest] = await db
             .select()
             .from(guests)
             .where(
                 and(
                     eq(guests.telegram_user_id, telegramUserId),
-                    eq(guests.restaurantId, restaurantId) // 🚨 CRITICAL SECURITY FIX: Filter by restaurant
+                    eq(guests.restaurantId, restaurantId)
                 )
             );
-        
         if (guest) {
             console.log(`📱 [Storage] Found guest ${guest.id} (${guest.name}) for restaurant ${restaurantId}`);
         } else {
             console.log(`📱 [Storage] No guest found with Telegram ID ${telegramUserId} for restaurant ${restaurantId}`);
         }
-        
         return guest;
     }
 
     async createGuest(guest: InsertGuest): Promise<Guest> {
         console.log(`👤 [Storage] Creating guest for restaurant ${guest.restaurantId} (TENANT SCOPED)`);
-        
-        // ✅ SECURITY: Schema now enforces restaurantId is required
         if (!guest.restaurantId) {
             throw new Error('Guest must be associated with a restaurant');
         }
-        
         const [newGuest] = await db.insert(guests).values(guest).returning();
-        
         console.log(`✅ [Storage] Created guest ${newGuest.id} for restaurant ${newGuest.restaurantId}`);
         return newGuest;
     }
 
-    // 🚨 CRITICAL SECURITY FIX: Guest update with restaurant validation
     async updateGuest(id: number, guest: Partial<InsertGuest>, restaurantId: number): Promise<Guest> {
         console.log(`👤 [Storage] Updating guest ${id} for restaurant ${restaurantId} (TENANT SCOPED)`);
-        
-        // ✅ SECURITY: Verify guest belongs to restaurant before updating
         const existingGuest = await this.getGuest(id, restaurantId);
         if (!existingGuest) {
             throw new Error(`Guest ${id} not found for restaurant ${restaurantId}`);
         }
-        
+
         const [updatedGuest] = await db
             .update(guests)
             .set(guest)
             .where(
                 and(
                     eq(guests.id, id),
-                    eq(guests.restaurantId, restaurantId) // 🚨 CRITICAL SECURITY FIX: Filter by restaurant
+                    eq(guests.restaurantId, restaurantId)
                 )
             )
             .returning();
-        
         console.log(`✅ [Storage] Updated guest ${id} for restaurant ${restaurantId}`);
         return updatedGuest;
     }
 
-    // ================================
-    // ✅ ENHANCED RESERVATION METHODS WITH TENANT CONTEXT
-    // ================================
-
     async getReservations(restaurantId: number, filters?: {
         date?: string;
         status?: string[];
@@ -666,7 +687,7 @@ export class DatabaseStorage implements IStorage {
         if (filters?.date && filters?.timezone) {
             const startOfDay = DateTime.fromISO(filters.date, { zone: filters.timezone }).startOf('day').toUTC().toISO();
             const endOfDay = DateTime.fromISO(filters.date, { zone: filters.timezone }).endOf('day').toUTC().toISO();
-            
+
             if (startOfDay && endOfDay) {
                 whereConditions.push(
                     and(
@@ -679,10 +700,10 @@ export class DatabaseStorage implements IStorage {
         }
 
         if (filters?.status && filters.status.length > 0) {
-            const validStatuses = filters.status.filter(status => 
+            const validStatuses = filters.status.filter(status =>
                 ['confirmed', 'created', 'canceled', 'completed', 'archived', 'seated', 'in_progress', 'no_show'].includes(status)
             ) as ReservationStatus[];
-            
+
             if (validStatuses.length > 0) {
                 whereConditions.push(inArray(reservations.status, validStatuses));
             }
@@ -709,7 +730,7 @@ export class DatabaseStorage implements IStorage {
             .from(reservations)
             .innerJoin(guests, and(
                 eq(reservations.guestId, guests.id),
-                eq(guests.restaurantId, restaurantId) // ✅ SECURITY: Ensure guest belongs to same restaurant
+                eq(guests.restaurantId, restaurantId)
             ))
             .innerJoin(tables, eq(reservations.tableId, tables.id))
             .where(and(...whereConditions))
@@ -747,47 +768,38 @@ export class DatabaseStorage implements IStorage {
 
     async createReservation(reservation: InsertReservation, tenantContext?: TenantContext): Promise<Reservation> {
         console.log(`🏢 [Storage] Creating reservation for restaurant ${reservation.restaurantId}`);
-        
-        // Load tenant context if not provided
         const context = tenantContext || await tenantContextManager.loadContext(reservation.restaurantId);
         if (!context) {
             throw new Error('Tenant context not found');
         }
-        
-        // Check reservation limit
+
         const limitCheck = await validateTenantAction(reservation.restaurantId, 'create_reservation', context);
         if (!limitCheck.allowed) {
             console.log(`❌ [Storage] Reservation creation blocked: ${limitCheck.reason}`);
             throw new Error(limitCheck.reason || 'Reservation limit exceeded');
         }
-        
         console.log(`✅ [Storage] Reservation limit check passed (${context.usage.currentMonthReservations}/${context.limits.maxMonthlyReservations})`);
-        
-        const [newReservation] = await db.insert(reservations).values(reservation).returning();
 
-        // Track usage
+        const [newReservation] = await db.insert(reservations).values(reservation).returning();
         await trackTenantUsage(reservation.restaurantId, 'reservation_created');
-        
-        // Update table status
+
         if (newReservation.tableId) {
             const restaurant = await this.getRestaurant(newReservation.restaurantId);
             const timezone = restaurant?.timezone || 'Europe/Moscow';
             await this.updateTableStatusFromReservations(newReservation.tableId, timezone);
         }
-        
-        // Log audit event
+
         await tenantContextManager.logAuditEvent({
             restaurantId: reservation.restaurantId,
             action: 'reservation_created',
-            performedBy: 'system', // TODO: Get actual user
+            performedBy: 'system',
             performedByType: 'system',
-            details: { 
+            details: {
                 reservationId: newReservation.id,
                 guestId: newReservation.guestId,
                 tableId: newReservation.tableId
             }
         });
-        
         console.log(`✅ [Storage] Reservation ${newReservation.id} created successfully`);
         return newReservation;
     }
@@ -798,14 +810,11 @@ export class DatabaseStorage implements IStorage {
         tenantContext?: TenantContext
     ): Promise<Reservation> {
         console.log(`🔒 [AtomicBooking] Starting atomic reservation creation for table ${expectedSlot.tableId} at ${expectedSlot.time}`);
-
-        // Load tenant context if not provided
         const context = tenantContext || await tenantContextManager.loadContext(reservation.restaurantId);
         if (!context) {
             throw new Error('Tenant context not found');
         }
-        
-        // Check reservation limit before starting transaction
+
         const limitCheck = await validateTenantAction(reservation.restaurantId, 'create_reservation', context);
         if (!limitCheck.allowed) {
             console.log(`❌ [AtomicBooking] Reservation creation blocked: ${limitCheck.reason}`);
@@ -862,10 +871,8 @@ export class DatabaseStorage implements IStorage {
 
                     if (hasOverlap) {
                         console.log(`❌ [AtomicBooking] CONFLICT DETECTED: Table ${expectedSlot.tableId} has existing reservation from ${existingStartUtc.toISO()} to ${existingEndUtc.toISO()} (ID: ${existing.id})`);
-
                         const conflictStartLocal = existingStartUtc.setZone(restaurantTimezone).toFormat('HH:mm');
                         const conflictEndLocal = existingEndUtc.setZone(restaurantTimezone).toFormat('HH:mm');
-
                         throw new Error(`Table no longer available - conflict detected with existing reservation from ${conflictStartLocal} to ${conflictEndLocal}`);
                     }
                 }
@@ -877,7 +884,6 @@ export class DatabaseStorage implements IStorage {
                     .values(reservation)
                     .returning();
 
-                // Track usage (increment counters)
                 await tx
                     .update(restaurants)
                     .set({
@@ -892,7 +898,6 @@ export class DatabaseStorage implements IStorage {
 
             } catch (error: any) {
                 console.log(`❌ [AtomicBooking] Transaction failed:`, error.message);
-
                 if (error.code === '40P01') {
                     throw new Error('Deadlock detected - please try again');
                 } else if (error.code === '40001') {
@@ -925,7 +930,6 @@ export class DatabaseStorage implements IStorage {
     async getUpcomingReservations(restaurantId: number, restaurantTimezone: string, hours: number = 3): Promise<any[]> {
         const nowUtc = DateTime.now().toUTC();
         const endTimeUtc = nowUtc.plus({ hours });
-
         console.log(`⏰ [Storage] Getting upcoming reservations from UTC ${nowUtc.toISO()} to ${endTimeUtc.toISO()}`);
 
         const results = await db
@@ -937,7 +941,7 @@ export class DatabaseStorage implements IStorage {
             .from(reservations)
             .innerJoin(guests, and(
                 eq(reservations.guestId, guests.id),
-                eq(guests.restaurantId, restaurantId) // ✅ SECURITY: Ensure guest belongs to same restaurant
+                eq(guests.restaurantId, restaurantId)
             ))
             .innerJoin(tables, eq(reservations.tableId, tables.id))
             .where(
@@ -972,13 +976,11 @@ export class DatabaseStorage implements IStorage {
         if (!startOfDayUtc || !endOfDayUtc) {
             throw new Error('Invalid timezone for statistics calculation');
         }
-
         console.log(`📊 [Storage] Getting stats for restaurant ${restaurantId} for UTC range: ${startOfDayUtc} to ${endOfDayUtc}`);
 
         const [todayCount] = await db
             .select({ count: count() })
             .from(reservations)
-            .innerJoin(tables, eq(reservations.tableId, tables.id))
             .where(
                 and(
                     eq(reservations.restaurantId, restaurantId),
@@ -991,7 +993,6 @@ export class DatabaseStorage implements IStorage {
         const [confirmedCount] = await db
             .select({ count: count() })
             .from(reservations)
-            .innerJoin(tables, eq(reservations.tableId, tables.id))
             .where(
                 and(
                     eq(reservations.restaurantId, restaurantId),
@@ -1004,7 +1005,6 @@ export class DatabaseStorage implements IStorage {
         const [pendingCount] = await db
             .select({ count: count() })
             .from(reservations)
-            .innerJoin(tables, eq(reservations.tableId, tables.id))
             .where(
                 and(
                     eq(reservations.restaurantId, restaurantId),
@@ -1017,7 +1017,6 @@ export class DatabaseStorage implements IStorage {
         const [guestsResult] = await db
             .select({ total: sql<number>`SUM(${reservations.guests})`.mapWith(Number) })
             .from(reservations)
-            .innerJoin(tables, eq(reservations.tableId, tables.id))
             .where(
                 and(
                     eq(reservations.restaurantId, restaurantId),
@@ -1033,17 +1032,12 @@ export class DatabaseStorage implements IStorage {
             pendingReservations: pendingCount?.count || 0,
             totalGuests: guestsResult?.total || 0,
         };
-
         console.log(`📊 [Storage] Computed stats:`, stats);
         return stats;
     }
 
-    // ================================
-    // ✅ NEW: ENHANCED RESERVATION STATUS MANAGEMENT
-    // ================================
-
     async updateReservationWithHistory(
-        reservationId: number, 
+        reservationId: number,
         updateData: Partial<InsertReservation>,
         historyData: {
             changedBy: 'system' | 'staff' | 'guest';
@@ -1053,16 +1047,15 @@ export class DatabaseStorage implements IStorage {
     ): Promise<Reservation> {
         return await db.transaction(async (tx) => {
             console.log(`🔄 [Storage] Updating reservation ${reservationId} with history tracking`);
-            
             const [currentReservation] = await tx
                 .select()
                 .from(reservations)
                 .where(eq(reservations.id, reservationId));
-                
+
             if (!currentReservation) {
                 throw new Error(`Reservation ${reservationId} not found`);
             }
-            
+
             if (updateData.status && updateData.status !== currentReservation.status) {
                 await tx.insert(reservationStatusHistory).values({
                     reservationId,
@@ -1072,16 +1065,14 @@ export class DatabaseStorage implements IStorage {
                     changeReason: historyData.changeReason,
                     metadata: historyData.metadata
                 });
-                
                 console.log(`📝 [Storage] Status change logged: ${currentReservation.status} → ${updateData.status}`);
             }
-            
+
             const [updatedReservation] = await tx
                 .update(reservations)
                 .set({ ...updateData, lastModifiedAt: new Date() })
                 .where(eq(reservations.id, reservationId))
                 .returning();
-                
             console.log(`✅ [Storage] Reservation ${reservationId} updated successfully`);
             return updatedReservation;
         });
@@ -1099,7 +1090,7 @@ export class DatabaseStorage implements IStorage {
             )
             .orderBy(desc(reservationStatusHistory.timestamp))
             .limit(1);
-            
+
         return statusChange?.timestamp ? new Date(statusChange.timestamp) : null;
     }
 
@@ -1111,10 +1102,6 @@ export class DatabaseStorage implements IStorage {
             .orderBy(reservationStatusHistory.timestamp);
     }
 
-    // ================================
-    // 🔒 SECURITY FIXED: ENHANCED GUEST ANALYTICS WITH RESTAURANT VALIDATION
-    // ================================
-
     async updateGuestAnalytics(
         guestId: number,
         analytics: {
@@ -1123,69 +1110,65 @@ export class DatabaseStorage implements IStorage {
             duration?: number;
             totalSpent?: number;
         },
-        restaurantId: number // 🚨 CRITICAL SECURITY FIX: Added restaurantId parameter
+        restaurantId: number
     ): Promise<Guest> {
         return await db.transaction(async (tx) => {
             console.log(`📊 [Storage] Updating guest ${guestId} analytics for restaurant ${restaurantId} (TENANT SCOPED):`, analytics);
-            
-            // ✅ SECURITY: Verify guest belongs to restaurant
             const [currentGuest] = await tx
                 .select()
                 .from(guests)
                 .where(
                     and(
                         eq(guests.id, guestId),
-                        eq(guests.restaurantId, restaurantId) // 🚨 CRITICAL SECURITY FIX: Filter by restaurant
+                        eq(guests.restaurantId, restaurantId)
                     )
                 );
-                
+
             if (!currentGuest) {
                 throw new Error(`Guest ${guestId} not found for restaurant ${restaurantId}`);
             }
-            
+
             const updates: Partial<InsertGuest> = {
                 last_visit_date: new Date()
             };
-            
+
             if (analytics.visitCompleted) {
                 updates.visit_count = (currentGuest.visit_count || 0) + 1;
-                
+
                 if (analytics.totalSpent && analytics.totalSpent > 0) {
-                    // 🔒 CURRENCY FIX: Safe decimal operations
                     const currentSpent = currentGuest.total_spent || '0';
                     updates.total_spent = this.addDecimal(currentSpent, analytics.totalSpent);
                     console.log(`💰 [Storage] Updated total spent: ${currentSpent} + ${analytics.totalSpent} = ${updates.total_spent}`);
                 }
-                
+
                 if (analytics.duration) {
                     const currentCount = currentGuest.visit_count || 0;
                     const currentAvg = currentGuest.average_duration || 120;
                     updates.average_duration = this.calculateAverage(currentAvg, currentCount, analytics.duration);
                     console.log(`⏱️ [Storage] Updated average duration: ${updates.average_duration} minutes`);
                 }
-                
+
                 updates.reputation_score = Math.min(100, (currentGuest.reputation_score || 100) + 2);
             }
-            
+
             if (analytics.noShowOccurred) {
                 updates.no_show_count = (currentGuest.no_show_count || 0) + 1;
-                
                 const reputationPenalty = Math.min(15, 5 + (currentGuest.no_show_count || 0) * 2);
                 updates.reputation_score = Math.max(0, (currentGuest.reputation_score || 100) - reputationPenalty);
                 console.log(`⚠️ [Storage] Applied reputation penalty: -${reputationPenalty} points`);
             }
-            
+
             const [updatedGuest] = await tx
                 .update(guests)
                 .set(updates)
                 .where(
                     and(
                         eq(guests.id, guestId),
-                        eq(guests.restaurantId, restaurantId) // 🚨 CRITICAL SECURITY FIX: Filter by restaurant
+                        eq(guests.restaurantId, restaurantId)
                     )
                 )
                 .returning();
-                
+
             console.log(`✅ [Storage] Guest ${guestId} analytics updated for restaurant ${restaurantId}`);
             return updatedGuest;
         });
@@ -1193,7 +1176,6 @@ export class DatabaseStorage implements IStorage {
 
     async getGuestReservationHistory(guestId: number, restaurantId: number): Promise<any[]> {
         console.log(`📋 [Storage] Getting reservation history for guest ${guestId} at restaurant ${restaurantId} (TENANT SCOPED)`);
-        
         const results = await db
             .select({
                 reservation: reservations,
@@ -1217,20 +1199,182 @@ export class DatabaseStorage implements IStorage {
             .where(
                 and(
                     eq(reservations.guestId, guestId),
-                    eq(reservations.restaurantId, restaurantId) // ✅ SECURITY: Double-check restaurant scoping
+                    eq(reservations.restaurantId, restaurantId)
                 )
             )
             .groupBy(reservations.id, tables.id)
             .orderBy(desc(reservations.reservation_utc))
             .limit(20);
-            
         console.log(`📋 [Storage] Found ${results.length} reservations in history for guest ${guestId}`);
         return results;
     }
 
-    // ================================
-    // ✅ NEW: MENU MANAGEMENT SYSTEM (UNCHANGED - Already tenant-scoped)
-    // ================================
+    async getAnalyticsOverview(restaurantId: number, timezone: string, days: number = 30): Promise<AnalyticsOverview> {
+        console.log(`📊 [Analytics] Generating overview for restaurant ${restaurantId} for the last ${days} days in timezone ${timezone}`);
+
+        const endDate = DateTime.now().setZone(timezone).endOf('day');
+        const startDate = endDate.minus({ days: days - 1 }).startOf('day');
+
+        const startUtc = startDate.toUTC().toISO();
+        const endUtc = endDate.toUTC().toISO();
+
+        if (!startUtc || !endUtc) {
+            throw new Error(`Invalid timeframe for analytics: ${timezone}`);
+        }
+
+        const relevantReservations = await db.select()
+            .from(reservations)
+            .where(and(
+                eq(reservations.restaurantId, restaurantId),
+                gte(reservations.reservation_utc, startUtc),
+                lte(reservations.reservation_utc, endUtc)
+            ));
+
+        const completedReservations = relevantReservations.filter(r => r.status === 'completed' && r.totalAmount);
+        const totalRevenue = completedReservations.reduce((sum, r) => sum + parseFloat(r.totalAmount || '0'), 0);
+        const avgRevenuePerBooking = completedReservations.length > 0 ? totalRevenue / completedReservations.length : 0;
+
+        const revenueBySource = completedReservations.reduce((acc, r) => {
+            const source = r.source || 'direct';
+            if (!acc[source]) {
+                acc[source] = { source, revenue: 0, count: 0 };
+            }
+            acc[source].revenue += parseFloat(r.totalAmount || '0');
+            acc[source].count++;
+            return acc;
+        }, {} as Record<string, { source: string, revenue: number, count: number }>);
+
+        const reservationsByStatus = relevantReservations.reduce((acc, r) => {
+            const status = r.status || 'created';
+            acc[status] = (acc[status] || 0) + 1;
+            return acc;
+        }, {} as Record<string, number>);
+
+        const totalReservations = relevantReservations.length;
+        const createdCount = reservationsByStatus.created || 0;
+        const confirmedCount = reservationsByStatus.confirmed || 0;
+        const seatedCount = reservationsByStatus.seated || 0;
+        const completedCount = reservationsByStatus.completed || 0;
+        const noShowCount = reservationsByStatus.no_show || 0;
+        const canceledCount = reservationsByStatus.canceled || 0;
+        const totalPotentialVisits = totalReservations - createdCount;
+
+        const allGuests = await db.select({
+            id: guests.id,
+            createdAt: guests.createdAt,
+            visit_count: guests.visit_count,
+            vip_level: guests.vip_level,
+            reputation_score: guests.reputation_score
+        }).from(guests).where(eq(guests.restaurantId, restaurantId));
+
+        const newGuests = allGuests.filter(g => DateTime.fromJSDate(g.createdAt) >= startDate.toJSDate()).length;
+
+        const tablePerformance = await db.select({
+            id: tables.id,
+            name: tables.name,
+            bookingCount: count(reservations.id),
+            revenue: sum(sql<number>`CAST(${reservations.totalAmount} AS numeric)`),
+            avgGuests: avg(reservations.guests)
+        })
+            .from(tables)
+            .leftJoin(reservations, eq(tables.id, reservations.tableId))
+            .where(and(
+                eq(tables.restaurantId, restaurantId),
+                gte(reservations.reservation_utc, startUtc),
+                lte(reservations.reservation_utc, endUtc),
+                eq(reservations.status, 'completed')
+            ))
+            .groupBy(tables.id);
+
+        const popularTimes = relevantReservations.reduce((acc, r) => {
+            const hour = DateTime.fromISO(r.reservation_utc, { zone: 'utc' }).setZone(timezone).hour;
+            acc[hour] = (acc[hour] || 0) + 1;
+            return acc;
+        }, {} as Record<number, number>);
+
+        const bySourceCounts = relevantReservations.reduce((acc, r) => {
+            const source = r.source || 'direct';
+            acc[source] = (acc[source] || 0) + 1;
+            return acc;
+        }, {} as Record<string, number>);
+
+        return {
+            timeframe: { start: startDate.toISO()!, end: endDate.toISO()!, timezone },
+            revenue: {
+                totalRevenue: totalRevenue.toFixed(2),
+                avgRevenuePerBooking: avgRevenuePerBooking.toFixed(2),
+                sources: Object.entries(revenueBySource).map(([source, data]) => ({ ...data, source, revenue: data.revenue.toFixed(2) })),
+            },
+            reservations: {
+                total: totalReservations,
+                byStatus: reservationsByStatus,
+                funnel: {
+                    created: createdCount,
+                    confirmed: confirmedCount,
+                    seated: seatedCount,
+                    completed: completedCount,
+                    noShowRate: totalPotentialVisits > 0 ? (noShowCount / totalPotentialVisits) * 100 : 0,
+                    cancellationRate: totalPotentialVisits > 0 ? (canceledCount / totalPotentialVisits) * 100 : 0,
+                },
+                avgGuests: relevantReservations.length > 0 ? relevantReservations.reduce((sum, r) => sum + r.guests, 0) / relevantReservations.length : 0,
+                bySource: Object.entries(bySourceCounts).map(([source, count]) => ({ source, count })),
+            },
+            guests: {
+                total: allGuests.length,
+                new: newGuests,
+                returning: allGuests.length - newGuests,
+                segmentation: {
+                    vip: allGuests.filter(g => (g.vip_level || 0) > 3).length,
+                    regulars: allGuests.filter(g => (g.visit_count || 0) >= 5 && (g.vip_level || 0) <= 3).length,
+                    atRisk: allGuests.filter(g => (g.reputation_score || 100) < 80).length,
+                },
+            },
+            tables: {
+                performance: tablePerformance.map(t => ({ ...t, revenue: t.revenue || '0.00', avgGuests: parseFloat(t.avgGuests || '0') })),
+                turnaroundTime: 120, // Placeholder
+            },
+            operations: {
+                seatingEfficiency: 5, // Placeholder
+                popularTimes: Object.entries(popularTimes).map(([hour, count]) => ({ hour: parseInt(hour), count })).sort((a, b) => b.count - a.count),
+            },
+        };
+    }
+
+
+    async getMenuCategories(restaurantId: number): Promise<RestaurantMenuCategory[]> {
+        return db
+            .select()
+            .from(restaurantMenuCategories)
+            .where(eq(restaurantMenuCategories.restaurantId, restaurantId))
+            .orderBy(restaurantMenuCategories.displayOrder, restaurantMenuCategories.name);
+    }
+
+    async getMenuCategory(id: number): Promise<RestaurantMenuCategory | undefined> {
+        const [category] = await db.select().from(restaurantMenuCategories).where(eq(restaurantMenuCategories.id, id));
+        return category;
+    }
+
+    async createMenuCategory(data: InsertRestaurantMenuCategory): Promise<RestaurantMenuCategory> {
+        const [newCategory] = await db.insert(restaurantMenuCategories).values(data).returning();
+        return newCategory;
+    }
+
+    async updateMenuCategory(id: number, data: Partial<InsertRestaurantMenuCategory>): Promise<RestaurantMenuCategory> {
+        const [updatedCategory] = await db
+            .update(restaurantMenuCategories)
+            .set({ ...data, updatedAt: new Date() })
+            .where(eq(restaurantMenuCategories.id, id))
+            .returning();
+        return updatedCategory;
+    }
+
+    async deleteMenuCategory(id: number): Promise<void> {
+        const itemsInCategory = await db.select({ id: menuItems.id }).from(menuItems).where(eq(menuItems.categoryId, id)).limit(1);
+        if (itemsInCategory.length > 0) {
+            throw new Error("Cannot delete category as it is still in use by menu items.");
+        }
+        await db.delete(restaurantMenuCategories).where(eq(restaurantMenuCategories.id, id));
+    }
 
     async getMenuItems(restaurantId: number, filters?: {
         category?: string;
@@ -1240,7 +1384,7 @@ export class DatabaseStorage implements IStorage {
         limit?: number;
     }): Promise<any[]> {
         const whereConditions = [eq(menuItems.restaurantId, restaurantId)];
-        
+
         if (filters?.category) {
             const categoryResults = await db
                 .select({ id: restaurantMenuCategories.id })
@@ -1251,20 +1395,20 @@ export class DatabaseStorage implements IStorage {
                         eq(restaurantMenuCategories.slug, filters.category)
                     )
                 );
-                
+
             if (categoryResults.length > 0) {
                 whereConditions.push(eq(menuItems.categoryId, categoryResults[0].id));
             }
         }
-        
+
         if (filters?.availableOnly) {
             whereConditions.push(eq(menuItems.isAvailable, true));
         }
-        
+
         if (filters?.popularOnly) {
             whereConditions.push(eq(menuItems.isPopular, true));
         }
-        
+
         if (filters?.searchQuery) {
             whereConditions.push(
                 or(
@@ -1274,7 +1418,7 @@ export class DatabaseStorage implements IStorage {
                 )!
             );
         }
-        
+
         let query = db
             .select({
                 item: menuItems,
@@ -1284,13 +1428,13 @@ export class DatabaseStorage implements IStorage {
             .innerJoin(restaurantMenuCategories, eq(menuItems.categoryId, restaurantMenuCategories.id))
             .where(and(...whereConditions))
             .orderBy(restaurantMenuCategories.displayOrder, menuItems.displayOrder);
-            
+
         if (filters?.limit) {
             query = query.limit(filters.limit) as any;
         }
-            
+
         const results = await query;
-            
+
         return results.map(r => ({
             ...r.item,
             categoryName: r.category.name,
@@ -1312,9 +1456,9 @@ export class DatabaseStorage implements IStorage {
             .from(menuItems)
             .innerJoin(restaurantMenuCategories, eq(menuItems.categoryId, restaurantMenuCategories.id))
             .where(eq(menuItems.id, id));
-        
+
         if (!item) return undefined;
-        
+
         return {
             ...item.item,
             categoryName: item.category.name,
@@ -1335,17 +1479,34 @@ export class DatabaseStorage implements IStorage {
         await db.delete(menuItems).where(eq(menuItems.id, id));
     }
 
-    async getMenuCategoryByName(restaurantId: number, name: string): Promise<RestaurantMenuCategory | undefined> {
-        const [category] = await db
-            .select()
-            .from(restaurantMenuCategories)
-            .where(
-                and(
-                    eq(restaurantMenuCategories.restaurantId, restaurantId),
-                    eq(restaurantMenuCategories.name, name)
-                )
-            );
-        return category;
+    async getOrCreateMenuCategoryByName(restaurantId: number, name: string): Promise<RestaurantMenuCategory> {
+        return await db.transaction(async (tx) => {
+            const [existingCategory] = await tx
+                .select()
+                .from(restaurantMenuCategories)
+                .where(
+                    and(
+                        eq(restaurantMenuCategories.restaurantId, restaurantId),
+                        ilike(restaurantMenuCategories.name, name)
+                    )
+                );
+
+            if (existingCategory) {
+                console.log(`[Storage] Found existing category "${name}" for restaurant ${restaurantId}`);
+                return existingCategory;
+            }
+
+            console.log(`[Storage] Category "${name}" not found for restaurant ${restaurantId}. Creating it.`);
+
+            const [newCategory] = await tx.insert(restaurantMenuCategories).values({
+                restaurantId: restaurantId,
+                name: name,
+                slug: name.toLowerCase().replace(/\s+/g, '-').replace(/[^\w-]+/g, ''),
+            }).returning();
+
+            console.log(`[Storage] Created new category "${name}" (ID: ${newCategory.id}) for restaurant ${restaurantId}`);
+            return newCategory;
+        });
     }
 
     async searchMenuItems(restaurantId: number, options: {
@@ -1355,24 +1516,23 @@ export class DatabaseStorage implements IStorage {
         priceRange?: { min?: number; max?: number };
     }): Promise<MenuItem[]> {
         console.log(`🔍 [Storage] Searching menu items for restaurant ${restaurantId} with options:`, options);
-        
         const searchPromises = [
             this.searchMenuItemsByName(restaurantId, options.query),
             this.searchMenuItemsByDescription(restaurantId, options.query),
             this.fuzzySearchMenuItems(restaurantId, options.query)
         ];
-        
+
         if (options.dietaryRestrictions && options.dietaryRestrictions.length > 0) {
             for (const restriction of options.dietaryRestrictions) {
                 searchPromises.push(this.searchMenuItemsByDietaryTags(restaurantId, restriction));
             }
         }
-        
+
         const searchResults = await Promise.all(searchPromises);
-        
+
         const allResults: MenuItem[] = [];
         const seenIds = new Set<number>();
-        
+
         for (const results of searchResults) {
             for (const item of results) {
                 if (!seenIds.has(item.id)) {
@@ -1381,9 +1541,9 @@ export class DatabaseStorage implements IStorage {
                 }
             }
         }
-        
+
         let filteredResults = allResults;
-        
+
         if (options.category) {
             const categoryFilter = await db
                 .select({ id: restaurantMenuCategories.id })
@@ -1394,13 +1554,13 @@ export class DatabaseStorage implements IStorage {
                         eq(restaurantMenuCategories.slug, options.category)
                     )
                 );
-            
+
             if (categoryFilter.length > 0) {
                 const categoryId = categoryFilter[0].id;
                 filteredResults = filteredResults.filter(item => item.categoryId === categoryId);
             }
         }
-        
+
         if (options.priceRange) {
             filteredResults = filteredResults.filter(item => {
                 const price = parseFloat(item.price);
@@ -1409,9 +1569,9 @@ export class DatabaseStorage implements IStorage {
                 return true;
             });
         }
-        
+
         console.log(`✅ [Storage] Found ${filteredResults.length} items matching search criteria`);
-        
+
         return filteredResults.sort((a, b) => {
             if (a.isPopular && !b.isPopular) return -1;
             if (!a.isPopular && b.isPopular) return 1;
@@ -1424,10 +1584,10 @@ export class DatabaseStorage implements IStorage {
     async bulkUpdateMenuItems(restaurantId: number, items: any[], action: string): Promise<any[]> {
         return await db.transaction(async (tx) => {
             const results = [];
-            
+
             for (const item of items) {
                 let updateData: Partial<InsertMenuItem> = {};
-                
+
                 switch (action) {
                     case 'availability':
                         updateData.isAvailable = item.isAvailable;
@@ -1442,7 +1602,7 @@ export class DatabaseStorage implements IStorage {
                     default:
                         throw new Error(`Unknown bulk update action: ${action}`);
                 }
-                
+
                 const [updated] = await tx
                     .update(menuItems)
                     .set({ ...updateData, updatedAt: new Date() })
@@ -1453,10 +1613,10 @@ export class DatabaseStorage implements IStorage {
                         )
                     )
                     .returning();
-                    
+
                 results.push(updated);
             }
-            
+
             return results;
         });
     }
@@ -1472,7 +1632,7 @@ export class DatabaseStorage implements IStorage {
                     ilike(menuItems.name, query)
                 )
             );
-            
+
         if (results.length === 0) {
             results = await db
                 .select()
@@ -1485,7 +1645,7 @@ export class DatabaseStorage implements IStorage {
                     )
                 );
         }
-        
+
         return results;
     }
 
@@ -1521,7 +1681,7 @@ export class DatabaseStorage implements IStorage {
     async fuzzySearchMenuItems(restaurantId: number, query: string): Promise<MenuItem[]> {
         const words = query.toLowerCase().split(' ');
         const searchPattern = words.join('%');
-        
+
         return await db
             .select()
             .from(menuItems)
@@ -1550,7 +1710,7 @@ export class DatabaseStorage implements IStorage {
             eq(menuItems.restaurantId, restaurantId),
             eq(menuItems.isAvailable, true)
         ];
-        
+
         if (context.category) {
             const categoryResults = await db
                 .select({ id: restaurantMenuCategories.id })
@@ -1561,12 +1721,12 @@ export class DatabaseStorage implements IStorage {
                         eq(restaurantMenuCategories.slug, context.category)
                     )
                 );
-                
+
             if (categoryResults.length > 0) {
                 whereConditions.push(eq(menuItems.categoryId, categoryResults[0].id));
             }
         }
-        
+
         if (context.priceRange) {
             if (context.priceRange.min) {
                 whereConditions.push(gte(menuItems.price, context.priceRange.min.toString()));
@@ -1575,7 +1735,7 @@ export class DatabaseStorage implements IStorage {
                 whereConditions.push(lte(menuItems.price, context.priceRange.max.toString()));
             }
         }
-        
+
         let results = await db
             .select({
                 item: menuItems,
@@ -1590,7 +1750,7 @@ export class DatabaseStorage implements IStorage {
                 menuItems.displayOrder
             )
             .limit(context.limit || 6);
-        
+
         return results.map(r => ({
             ...r.item,
             categoryName: r.category.name,
@@ -1601,8 +1761,8 @@ export class DatabaseStorage implements IStorage {
     private getRecommendationReason(item: any, guestPreferences?: string[]): string {
         if (item.isPopular) return "Popular choice";
         if (item.isNew) return "New addition";
-        if (guestPreferences?.some(pref => 
-            item.dietaryTags?.includes(pref) || 
+        if (guestPreferences?.some(pref =>
+            item.dietaryTags?.includes(pref) ||
             item.subcategory?.toLowerCase().includes(pref.toLowerCase())
         )) {
             return "Matches your preferences";
@@ -1632,14 +1792,10 @@ export class DatabaseStorage implements IStorage {
             resultsCount: 0,
             source
         }).returning();
-        
+
         return searchLog;
     }
 
-    // ================================
-    // ✅ EXISTING INTEGRATION SETTINGS METHODS
-    // ================================
-
     async getIntegrationSettings(restaurantId: number, type: string): Promise<IntegrationSetting | undefined> {
         const [settings] = await db
             .select()
@@ -1674,10 +1830,6 @@ export class DatabaseStorage implements IStorage {
         }
     }
 
-    // ================================
-    // ✅ EXISTING AI ACTIVITIES METHODS
-    // ================================
-
     async getAiActivities(restaurantId: number, limit: number = 10): Promise<AiActivity[]> {
         return db
             .select()
@@ -1692,21 +1844,15 @@ export class DatabaseStorage implements IStorage {
             .insert(aiActivities)
             .values(activity)
             .returning();
-        
-        // Track AI usage for the tenant
+
         await trackTenantUsage(activity.restaurantId, 'ai_request');
-        
+
         return newActivity;
     }
 
-    // ================================
-    // ✅ EXISTING TABLE AVAILABILITY METHODS
-    // ================================
-
     async updateTableStatusFromReservations(tableId: number, restaurantTimezone: string): Promise<void> {
         const nowInRestaurant = DateTime.now().setZone(restaurantTimezone);
         const nowUtc = nowInRestaurant.toUTC();
-
         console.log(`🏢 [Storage] Updating table ${tableId} status using restaurant time converted to UTC: ${nowUtc.toISO()} (${restaurantTimezone})`);
 
         const activeReservations = await db
@@ -1749,9 +1895,9 @@ export class DatabaseStorage implements IStorage {
         } else if (hasUpcomingReservation) {
             newStatus = 'reserved';
         }
-        
+
         console.log(`🏢 [Storage] Table ${tableId} status: ${newStatus}`);
-        
+
         await db
             .update(tables)
             .set({ status: newStatus })
@@ -1804,15 +1950,11 @@ export class DatabaseStorage implements IStorage {
                     )
                 )
             );
-        
+
         console.log(`🏢 [Storage] Found ${availableTables.length} available tables${excludeReservationId ? ` (excluded reservation ${excludeReservationId})` : ''}`);
         return availableTables;
     }
 
-    // ================================
-    // ✅ NEW: MULTI-TENANT MANAGEMENT METHODS
-    // ================================
-
     async getSuperAdmin(id: number): Promise<SuperAdmin | undefined> {
         const [admin] = await db.select().from(superAdmins).where(eq(superAdmins.id, id));
         return admin;
@@ -1855,15 +1997,15 @@ export class DatabaseStorage implements IStorage {
         endDate?: string;
     }): Promise<TenantUsageMetrics[]> {
         const whereConditions = [eq(tenantUsageMetrics.restaurantId, restaurantId)];
-        
+
         if (options?.startDate) {
             whereConditions.push(gte(tenantUsageMetrics.metricDate, options.startDate));
         }
-        
+
         if (options?.endDate) {
             whereConditions.push(lte(tenantUsageMetrics.metricDate, options.endDate));
         }
-        
+
         return await db
             .select()
             .from(tenantUsageMetrics)
@@ -1885,26 +2027,25 @@ export class DatabaseStorage implements IStorage {
         tenantsByPlan: any[];
     }> {
         console.log(`📊 [Storage] Computing platform metrics`);
-        
         const [totalTenantsResult] = await db
             .select({ count: count() })
             .from(restaurants);
-        
+
         const [activeTenantsResult] = await db
             .select({ count: count() })
             .from(restaurants)
             .where(eq(restaurants.tenantStatus, 'active'));
-            
+
         const [trialTenantsResult] = await db
             .select({ count: count() })
             .from(restaurants)
             .where(eq(restaurants.tenantStatus, 'trial'));
-            
+
         const [suspendedTenantsResult] = await db
             .select({ count: count() })
             .from(restaurants)
             .where(eq(restaurants.tenantStatus, 'suspended'));
-        
+
         const tenantsByPlan = await db
             .select({
                 plan: restaurants.tenantPlan,
@@ -1912,44 +2053,33 @@ export class DatabaseStorage implements IStorage {
             })
             .from(restaurants)
             .groupBy(restaurants.tenantPlan);
-        
-        const today = DateTime.now().toISODate();
-        const startOfMonth = DateTime.now().startOf('month').toISODate();
-        
-        const [todayReservationsResult] = await db
-            .select({ total: sql<number>`SUM(${restaurants.monthlyReservationCount})`.mapWith(Number) })
-            .from(restaurants);
-            
+
         const [monthReservationsResult] = await db
             .select({ total: sql<number>`SUM(${restaurants.totalReservationsAllTime})`.mapWith(Number) })
             .from(restaurants);
-        
+
         const metrics = {
             totalTenants: totalTenantsResult?.count || 0,
             activeTenants: activeTenantsResult?.count || 0,
             trialTenants: trialTenantsResult?.count || 0,
             suspendedTenants: suspendedTenantsResult?.count || 0,
-            totalReservationsToday: 0, // Would need more complex calculation
+            totalReservationsToday: 0,
             totalReservationsMonth: monthReservationsResult?.total || 0,
             tenantsByPlan: tenantsByPlan || []
         };
-        
         console.log(`📊 [Storage] Platform metrics computed:`, metrics);
         return metrics;
     }
 
-    // ================================
-    // 🚨 MISSING METHODS ADDED: Super admin tenant management
-    // ================================
-
     async logSuperAdminActivity(adminId: number, action: string, details: object): Promise<void> {
         try {
             await db.insert(tenantAuditLogs).values({
-                restaurantId: null, // Platform-wide action
+                restaurantId: null,
                 action: `superadmin:${action}`,
                 performedBy: `super_admin_id:${adminId}`,
                 performedByType: 'super_admin',
                 details,
+                // @ts-ignore
                 ipAddress: (details as any).ip,
             });
         } catch (error) {
@@ -1983,17 +2113,16 @@ export class DatabaseStorage implements IStorage {
         }
     }> {
         console.log(`[Storage] Getting all tenants with filters:`, filters);
-        
         const whereConditions = [];
 
         if (filters.status) {
             whereConditions.push(eq(restaurants.tenantStatus, filters.status as any));
         }
-        
+
         if (filters.plan) {
             whereConditions.push(eq(restaurants.tenantPlan, filters.plan as any));
         }
-        
+
         if (filters.searchQuery) {
             const query = `%${filters.searchQuery}%`;
             whereConditions.push(
@@ -2014,19 +2143,17 @@ export class DatabaseStorage implements IStorage {
             .leftJoin(users, eq(restaurants.userId, users.id))
             .where(whereConditions.length > 0 ? and(...whereConditions) : undefined);
 
-        // Get total count for pagination
         const totalCountQuery = db
             .select({ count: count() })
             .from(restaurants)
             .leftJoin(users, eq(restaurants.userId, users.id))
             .where(whereConditions.length > 0 ? and(...whereConditions) : undefined);
-            
+
         const [totalResult] = await totalCountQuery;
         const totalCount = totalResult.count;
         const totalPages = Math.ceil(totalCount / filters.limit);
         const offset = (filters.page - 1) * filters.limit;
 
-        // Apply sorting
         const orderByColumn = (restaurants as any)[filters.sortBy] || restaurants.createdAt;
         const finalQuery = queryBuilder
             .orderBy(filters.sortOrder === 'asc' ? orderByColumn : desc(orderByColumn))
@@ -2035,7 +2162,6 @@ export class DatabaseStorage implements IStorage {
 
         const tenants = await finalQuery;
 
-        // Get summary data
         const [summaryResult] = await db.select({
             total: count(),
             active: count(sql`CASE WHEN ${restaurants.tenantStatus} = 'active' THEN 1 END`),
@@ -2050,7 +2176,7 @@ export class DatabaseStorage implements IStorage {
         console.log(`[Storage] Found ${tenants.length} tenants (page ${filters.page}/${totalPages})`);
 
         return {
-            tenants: tenants.map(t => ({...t.tenant, owner: t.owner})),
+            tenants: tenants.map(t => ({ ...t.tenant, owner: t.owner })),
             pagination: {
                 currentPage: filters.page,
                 totalPages,
@@ -2077,7 +2203,6 @@ export class DatabaseStorage implements IStorage {
         return tenant;
     }
 
-    // ✅ BUG FIX: Fixed tenant feature flags in createTenantWithOwner method
     async createTenantWithOwner(data: {
         restaurantName: string;
         subdomain: string;
@@ -2092,8 +2217,6 @@ export class DatabaseStorage implements IStorage {
     }): Promise<{ restaurant: Restaurant, owner: User }> {
         return await db.transaction(async (tx) => {
             console.log(`[Storage] Starting transaction to create tenant ${data.restaurantName}`);
-
-            // ✅ BUG FIX: Ensure feature flags have proper defaults if undefined
             const safeFeatures = {
                 enableAiChat: data.features.enableAiChat !== undefined ? Boolean(data.features.enableAiChat) : true,
                 enableTelegramBot: data.features.enableTelegramBot !== undefined ? Boolean(data.features.enableTelegramBot) : false,
@@ -2101,10 +2224,8 @@ export class DatabaseStorage implements IStorage {
                 enableAdvancedReporting: data.features.enableAdvancedReporting !== undefined ? Boolean(data.features.enableAdvancedReporting) : false,
                 enableMenuManagement: data.features.enableMenuManagement !== undefined ? Boolean(data.features.enableMenuManagement) : true,
             };
-
             console.log(`[Storage] Safe feature flags for tenant ${data.restaurantName}:`, safeFeatures);
 
-            // 1. Create the owner user
             const hashedPassword = await bcrypt.hash(data.initialPassword, 10);
             const [owner] = await tx.insert(users).values({
                 email: data.ownerEmail,
@@ -2114,29 +2235,22 @@ export class DatabaseStorage implements IStorage {
                 role: 'restaurant',
             }).returning();
 
-            // 2. Create the restaurant (tenant) and link it to the owner
             const [restaurant] = await tx.insert(restaurants).values({
-                // Core Tenant Info
                 userId: owner.id,
                 name: data.restaurantName,
                 subdomain: data.subdomain,
                 tenantPlan: data.plan,
                 timezone: data.timezone,
                 tenantStatus: 'trial',
-
-                // ✅ BUG FIX: Use safe feature flags with explicit boolean values
                 enableAiChat: safeFeatures.enableAiChat,
                 enableTelegramBot: safeFeatures.enableTelegramBot,
                 enableGuestAnalytics: safeFeatures.enableGuestAnalytics,
                 enableAdvancedReporting: safeFeatures.enableAdvancedReporting,
                 enableMenuManagement: safeFeatures.enableMenuManagement,
-
-                // Explicitly map limits
                 maxTablesAllowed: data.limits.maxTables,
                 maxStaffAccounts: data.limits.maxUsers
-
             }).returning();
-            
+
             console.log(`[Storage] Successfully created user ${owner.id} and restaurant ${restaurant.id} with features:`, {
                 enableAiChat: restaurant.enableAiChat,
                 enableTelegramBot: restaurant.enableTelegramBot,
@@ -2144,7 +2258,7 @@ export class DatabaseStorage implements IStorage {
                 enableAdvancedReporting: restaurant.enableAdvancedReporting,
                 enableMenuManagement: restaurant.enableMenuManagement,
             });
-            
+
             return { restaurant, owner };
         });
     }
@@ -2152,28 +2266,28 @@ export class DatabaseStorage implements IStorage {
     async getTenantById(tenantId: number): Promise<any | undefined> {
         console.log(`[Storage] Getting tenant details for ID: ${tenantId}`);
         const [tenant] = await db.select({
-                tenant: restaurants,
-                owner: users
-            })
+            tenant: restaurants,
+            owner: users
+        })
             .from(restaurants)
             .leftJoin(users, eq(restaurants.userId, users.id))
             .where(eq(restaurants.id, tenantId));
-            
+
         if (!tenant) return undefined;
         return { ...tenant.tenant, owner: tenant.owner };
     }
 
     async getTenantMetrics(tenantId: number): Promise<any> {
         const [reservationStats] = await db.select({
-                total: count(),
-                completed: count(sql`CASE WHEN ${reservations.status} = 'completed' THEN 1 END`),
-                noShow: count(sql`CASE WHEN ${reservations.status} = 'no_show' THEN 1 END`),
-            }).from(reservations)
+            total: count(),
+            completed: count(sql`CASE WHEN ${reservations.status} = 'completed' THEN 1 END`),
+            noShow: count(sql`CASE WHEN ${reservations.status} = 'no_show' THEN 1 END`),
+        }).from(reservations)
             .where(eq(reservations.restaurantId, tenantId));
 
         const [guestStats] = await db.select({
-                total: count(),
-            }).from(guests)
+            total: count(),
+        }).from(guests)
             .where(eq(guests.restaurantId, tenantId));
 
         return {
@@ -2185,12 +2299,12 @@ export class DatabaseStorage implements IStorage {
     }
 
     async getTenantUsage(tenantId: number): Promise<any> {
-         const [usage] = await db.select({
-                monthlyReservations: restaurants.monthlyReservationCount,
-                maxMonthlyReservations: restaurants.maxMonthlyReservations,
-                tables: count(tables.id),
-                maxTables: restaurants.maxTablesAllowed,
-            })
+        const [usage] = await db.select({
+            monthlyReservations: restaurants.monthlyReservationCount,
+            maxMonthlyReservations: restaurants.maxMonthlyReservations,
+            tables: count(tables.id),
+            maxTables: restaurants.maxTablesAllowed,
+        })
             .from(restaurants)
             .leftJoin(tables, eq(tables.restaurantId, restaurants.id))
             .where(eq(restaurants.id, tenantId))
@@ -2216,4 +2330,4 @@ export class DatabaseStorage implements IStorage {
     }
 }
 
-export const storage = new DatabaseStorage();
\ No newline at end of file
+export const storage = new DatabaseStorage();
diff --git a/server/utils/time-normalization-utils.ts b/server/utils/time-normalization-utils.ts
index bf4a3d4..16ab44f 100644
--- a/server/utils/time-normalization-utils.ts
+++ b/server/utils/time-normalization-utils.ts
@@ -1,13 +1,50 @@
 // server/utils/time-normalization-utils.ts
 
-/**
- * 🚨 CRITICAL BUG FIX: Smart Time Normalization Utility
- * 
- * Handles the various ways people naturally type times in chat conversations.
- * Fixes the circular loop issue where "19-20" is interpreted as a range instead of "19:20".
- * 
- * This utility normalizes time patterns BEFORE AI processing to prevent ambiguity.
- */
+// In server/utils/time-normalization-utils.ts
+
+import { aiService } from '../services/ai-service'; // Import the aiService singleton
+import { TenantContext } from '../services/tenant-context'; // Import TenantContext type
+import { getRestaurantTimeContext } from './timezone-utils';
+import { smartLog } from '../services/smart-logging.service'; // Assuming smartLog is available here
+
+export async function normalizeAfterMidnightTime(
+    message: string,
+    tenantContext: TenantContext
+): Promise<{ date: string | null; time: string | null }> {
+
+    // Get the current date/time context to provide to the AI.
+    const timeContext = getRestaurantTimeContext(tenantContext.restaurant.timezone);
+
+    const prompt = `
+        You are a precise time extraction tool. The user is booking a table at a restaurant that is open past midnight.
+        The current date is ${timeContext.todayDate} (${timeContext.dayOfWeek}). The current time is ${timeContext.currentTime}.
+        Analyze the user's request: "${message}"
+        Your task is to extract the exact calendar date and 24-hour time for the booking.
+        - "today at 2 AM" refers to the current calendar date (${timeContext.todayDate}) at 02:00.
+        - "tonight at 2 AM" also refers to the current calendar date (${timeContext.todayDate}) at 02:00.
+
+        Return ONLY a valid JSON object with the format: { "date": "YYYY-MM-DD", "time": "HH:MM" }
+    `;
+
+    try {
+        const result = await aiService.generateJSON<{ date: string; time: string }>(
+            prompt,
+            {
+                context: 'high-precision-time-normalization',
+                model: 'gpt-4o' // Use a powerful model for this critical, single task.
+            },
+            tenantContext
+        );
+
+        if (result && result.date && result.time) {
+            return { date: result.date, time: result.time };
+        }
+        return { date: null, time: null };
+    } catch (error) {
+        smartLog.error('High-precision time normalization failed', error as Error, { message });
+        return { date: null, time: null };
+    }
+}
 
 export interface TimeNormalizationResult {
     normalizedMessage: string;
diff --git a/shared/schema.ts b/shared/schema.ts
index 502abd5..777e949 100644
--- a/shared/schema.ts
+++ b/shared/schema.ts
@@ -19,7 +19,7 @@ export const timeslotStatusEnum = pgEnum('timeslot_status', ['free', 'pending',
 
 // ✅ NEW: Keep allergen enum (standardized globally)
 export const allergenEnum = pgEnum('allergen', [
-  'gluten', 'dairy', 'eggs', 'nuts', 'peanuts', 'soy', 'fish', 'shellfish'
+    'gluten', 'dairy', 'eggs', 'nuts', 'peanuts', 'soy', 'fish', 'shellfish'
 ]);
 
 // ================================
@@ -35,105 +35,108 @@ export const tenantPlanEnum = pgEnum('tenant_plan', ['free', 'starter', 'profess
 
 // Users table (unchanged)
 export const users = pgTable("users", {
-  id: serial("id").primaryKey(),
-  email: text("email").notNull().unique(),
-  password: text("password").notNull(),
-  role: userRoleEnum("role").notNull().default('restaurant'),
-  name: text("name").notNull(),
-  phone: text("phone"),
-  createdAt: timestamp("created_at").defaultNow().notNull(),
+    id: serial("id").primaryKey(),
+    email: text("email").notNull().unique(),
+    password: text("password").notNull(),
+    role: userRoleEnum("role").notNull().default('restaurant'),
+    name: text("name").notNull(),
+    phone: text("phone"),
+    createdAt: timestamp("created_at").defaultNow().notNull(),
 });
 
 export const usersRelations = relations(users, ({ one, many }) => ({
-  restaurant: one(restaurants, {
-    fields: [users.id],
-    references: [restaurants.userId],
-  }),
+    restaurant: one(restaurants, {
+        fields: [users.id],
+        references: [restaurants.userId],
+    }),
 }));
 
 // ✅ ENHANCED: Restaurants table with multi-tenant fields
 export const restaurants = pgTable("restaurants", {
-  id: serial("id").primaryKey(),
-  userId: integer("user_id").references(() => users.id).notNull(),
-  name: text("name").notNull(),
-  description: text("description"),
-  country: text("country"),
-  city: text("city"),
-  address: text("address"),
-  photo: text("photo"),
-  openingTime: time("opening_time"),
-  closingTime: time("closing_time"),
-  cuisine: text("cuisine"),
-  atmosphere: text("atmosphere"),
-  features: text("features").array(),
-  tags: text("tags").array(),
-  languages: text("languages").array(),
-  avgReservationDuration: integer("avg_reservation_duration").default(120),
-  minGuests: integer("min_guests").default(1),
-  maxGuests: integer("max_guests").default(12),
-  phone: text("phone"),
-  googleMapsLink: text("google_maps_link"),
-  tripAdvisorLink: text("trip_advisor_link"),
-  timezone: text("timezone").notNull().default('Europe/Moscow'),
-  
-  // ✅ EXISTING: Flexible time booking configuration
-  slotInterval: integer("slot_interval").default(30),
-  allowAnyTime: boolean("allow_any_time").default(true),
-  minTimeIncrement: integer("min_time_increment").default(15),
-  
-  // ================================
-  // MULTI-TENANT FIELDS
-  // ================================
-  
-  // Tenant identification & status
-  subdomain: text("subdomain").unique(),
-  tenantStatus: tenantStatusEnum("tenant_status").default('trial'),
-  tenantPlan: tenantPlanEnum("tenant_plan").default('free'),
-  trialEndsAt: timestamp("trial_ends_at"),
-  suspendedAt: timestamp("suspended_at"),
-  suspendedReason: text("suspended_reason"),
-
-  // Service configuration
-  primaryAiModel: text("primary_ai_model").default('gpt-4'),
-  fallbackAiModel: text("fallback_ai_model").default('gpt-3.5-turbo'),
-  aiTemperature: decimal("ai_temperature", { precision: 2, scale: 1 }).default('0.7'),
-  maxTablesAllowed: integer("max_tables_allowed").default(10),
-  maxMonthlyReservations: integer("max_monthly_reservations").default(1000),
-  maxStaffAccounts: integer("max_staff_accounts").default(5),
-
-  // Feature flags
-  enableAiChat: boolean("enable_ai_chat").default(true),
-  enableTelegramBot: boolean("enable_telegram_bot").default(false),
-  enableMenuManagement: boolean("enable_menu_management").default(true),
-  enableGuestAnalytics: boolean("enable_guest_analytics").default(true),
-  enableAdvancedReporting: boolean("enable_advanced_reporting").default(false),
-
-  // Billing & usage tracking
-  monthlyReservationCount: integer("monthly_reservation_count").default(0),
-  lastBillingResetDate: timestamp("last_billing_reset_date").defaultNow(),
-  totalReservationsAllTime: integer("total_reservations_all_time").default(0),
-
-  // Onboarding
-  onboardingCompleted: boolean("onboarding_completed").default(false),
-  onboardingStep: text("onboarding_step").default('restaurant_info'),
-  
-  createdAt: timestamp("created_at").defaultNow().notNull(),
+    id: serial("id").primaryKey(),
+    userId: integer("user_id").references(() => users.id).notNull(),
+    name: text("name").notNull(),
+    description: text("description"),
+    country: text("country"),
+    city: text("city"),
+    address: text("address"),
+    photo: text("photo"),
+    openingTime: time("opening_time"),
+    closingTime: time("closing_time"),
+    cuisine: text("cuisine"),
+    atmosphere: text("atmosphere"),
+    features: text("features").array(),
+    tags: text("tags").array(),
+    languages: text("languages").array(),
+    avgReservationDuration: integer("avg_reservation_duration").default(120),
+    minGuests: integer("min_guests").default(1),
+    maxGuests: integer("max_guests").default(12),
+    phone: text("phone"),
+    googleMapsLink: text("google_maps_link"),
+    tripAdvisorLink: text("trip_advisor_link"),
+    timezone: text("timezone").notNull().default('Europe/Moscow'),
+
+    // ✅ EXISTING: Flexible time booking configuration
+    slotInterval: integer("slot_interval").default(30),
+    allowAnyTime: boolean("allow_any_time").default(true),
+    minTimeIncrement: integer("min_time_increment").default(15),
+
+    // ================================
+    // MULTI-TENANT FIELDS
+    // ================================
+
+    // Tenant identification & status
+    subdomain: text("subdomain").unique(),
+    tenantStatus: tenantStatusEnum("tenant_status").default('trial'),
+    tenantPlan: tenantPlanEnum("tenant_plan").default('free'),
+    trialEndsAt: timestamp("trial_ends_at"),
+    suspendedAt: timestamp("suspended_at"),
+    suspendedReason: text("suspended_reason"),
+
+    // Service configuration
+    primaryAiModel: text("primary_ai_model").default('gpt-4'),
+    fallbackAiModel: text("fallback_ai_model").default('gpt-3.5-turbo'),
+    aiTemperature: decimal("ai_temperature", { precision: 2, scale: 1 }).default('0.7'),
+    maxTablesAllowed: integer("max_tables_allowed").default(10),
+    maxMonthlyReservations: integer("max_monthly_reservations").default(1000),
+    maxStaffAccounts: integer("max_staff_accounts").default(5),
+
+    // Feature flags
+    enableAiChat: boolean("enable_ai_chat").default(true),
+    enableTelegramBot: boolean("enable_telegram_bot").default(false),
+    enableMenuManagement: boolean("enable_menu_management").default(true),
+    enableGuestAnalytics: boolean("enable_guest_analytics").default(true),
+    enableAdvancedReporting: boolean("enable_advanced_reporting").default(false),
+
+    // Billing & usage tracking
+    monthlyReservationCount: integer("monthly_reservation_count").default(0),
+    lastBillingResetDate: timestamp("last_billing_reset_date").defaultNow(),
+    totalReservationsAllTime: integer("total_reservations_all_time").default(0),
+
+    // Onboarding
+    onboardingCompleted: boolean("onboarding_completed").default(false),
+    onboardingStep: text("onboarding_step").default('restaurant_info'),
+
+    createdAt: timestamp("created_at").defaultNow().notNull(),
 });
 
+// 🔄 MODIFIED: Added relation to the new 'floors' table
 export const restaurantsRelations = relations(restaurants, ({ one, many }) => ({
-  user: one(users, {
-    fields: [restaurants.userId],
-    references: [users.id],
-  }),
-  tables: many(tables),
-  reservations: many(reservations),
-  timeslots: many(timeslots),
-  policies: many(restaurantPolicies),
-  menuCategories: many(restaurantMenuCategories),
-  menuItems: many(menuItems),
-  guests: many(guests), // ✅ SECURITY FIX: Add guest relation
-  auditLogs: many(tenantAuditLogs),
-  usageMetrics: many(tenantUsageMetrics),
+    user: one(users, {
+        fields: [restaurants.userId],
+        references: [users.id],
+    }),
+    tables: many(tables),
+    reservations: many(reservations),
+    timeslots: many(timeslots),
+    policies: many(restaurantPolicies),
+    menuCategories: many(restaurantMenuCategories),
+    menuItems: many(menuItems),
+    guests: many(guests), // ✅ SECURITY FIX: Add guest relation
+    auditLogs: many(tenantAuditLogs),
+    usageMetrics: many(tenantUsageMetrics),
+    // ✅ NEW: Relation to floors
+    floors: many(floors),
 }));
 
 // ================================
@@ -154,115 +157,148 @@ export const superAdmins = pgTable("super_admins", {
 
 // Tenant audit logs
 export const tenantAuditLogs = pgTable("tenant_audit_logs", {
-  id: serial("id").primaryKey(),
-  restaurantId: integer("restaurant_id").references(() => restaurants.id),
-  action: text("action").notNull(),
-  performedBy: text("performed_by").notNull(),
-  performedByType: text("performed_by_type").notNull(),
-  details: json("details").$type<any>(),
-  ipAddress: text("ip_address"),
-  userAgent: text("user_agent"),
-  timestamp: timestamp("timestamp").defaultNow().notNull(),
+    id: serial("id").primaryKey(),
+    restaurantId: integer("restaurant_id").references(() => restaurants.id),
+    action: text("action").notNull(),
+    performedBy: text("performed_by").notNull(),
+    performedByType: text("performed_by_type").notNull(),
+    details: json("details").$type<any>(),
+    ipAddress: text("ip_address"),
+    userAgent: text("user_agent"),
+    timestamp: timestamp("timestamp").defaultNow().notNull(),
 });
 
 export const tenantAuditLogsRelations = relations(tenantAuditLogs, ({ one }) => ({
-  restaurant: one(restaurants, {
-    fields: [tenantAuditLogs.restaurantId],
-    references: [restaurants.id],
-  }),
+    restaurant: one(restaurants, {
+        fields: [tenantAuditLogs.restaurantId],
+        references: [restaurants.id],
+    }),
 }));
 
 // Tenant usage metrics
 export const tenantUsageMetrics = pgTable("tenant_usage_metrics", {
-  id: serial("id").primaryKey(),
-  restaurantId: integer("restaurant_id").references(() => restaurants.id).notNull(),
-  metricDate: date("metric_date").notNull(),
-  reservationCount: integer("reservation_count").default(0),
-  guestCount: integer("guest_count").default(0),
-  aiRequestCount: integer("ai_request_count").default(0),
-  storageUsedMb: decimal("storage_used_mb", { precision: 10, scale: 2 }).default('0'),
-  activeTableCount: integer("active_table_count").default(0),
-  activeStaffCount: integer("active_staff_count").default(0),
-  createdAt: timestamp("created_at").defaultNow().notNull(),
+    id: serial("id").primaryKey(),
+    restaurantId: integer("restaurant_id").references(() => restaurants.id).notNull(),
+    metricDate: date("metric_date").notNull(),
+    reservationCount: integer("reservation_count").default(0),
+    guestCount: integer("guest_count").default(0),
+    aiRequestCount: integer("ai_request_count").default(0),
+    storageUsedMb: decimal("storage_used_mb", { precision: 10, scale: 2 }).default('0'),
+    activeTableCount: integer("active_table_count").default(0),
+    activeStaffCount: integer("active_staff_count").default(0),
+    createdAt: timestamp("created_at").defaultNow().notNull(),
 }, (table) => ({
-  uniqueRestaurantDate: unique().on(table.restaurantId, table.metricDate)
+    uniqueRestaurantDate: unique().on(table.restaurantId, table.metricDate)
 }));
 
 export const tenantUsageMetricsRelations = relations(tenantUsageMetrics, ({ one }) => ({
-  restaurant: one(restaurants, {
-    fields: [tenantUsageMetrics.restaurantId],
-    references: [restaurants.id],
-  }),
+    restaurant: one(restaurants, {
+        fields: [tenantUsageMetrics.restaurantId],
+        references: [restaurants.id],
+    }),
 }));
 
 // Plan limits configuration
 export const planLimits = pgTable("plan_limits", {
-  id: serial("id").primaryKey(),
-  planName: text("plan_name").notNull().unique(),
-  maxTables: integer("max_tables").notNull(),
-  maxMonthlyReservations: integer("max_monthly_reservations").notNull(),
-  maxStaffAccounts: integer("max_staff_accounts").notNull(),
-  maxStorageMb: integer("max_storage_mb").notNull(),
-  features: json("features").$type<{
-    aiChat: boolean;
-    telegramBot: boolean;
-    advancedAnalytics: boolean;
-    customBranding: boolean;
-    apiAccess: boolean;
-    prioritySupport: boolean;
-  }>().notNull(),
-  monthlyPrice: decimal("monthly_price", { precision: 10, scale: 2 }).notNull(),
-  yearlyPrice: decimal("yearly_price", { precision: 10, scale: 2 }).notNull(),
-  isActive: boolean("is_active").default(true),
-  createdAt: timestamp("created_at").defaultNow().notNull(),
+    id: serial("id").primaryKey(),
+    planName: text("plan_name").notNull().unique(),
+    maxTables: integer("max_tables").notNull(),
+    maxMonthlyReservations: integer("max_monthly_reservations").notNull(),
+    maxStaffAccounts: integer("max_staff_accounts").notNull(),
+    maxStorageMb: integer("max_storage_mb").notNull(),
+    features: json("features").$type<{
+        aiChat: boolean;
+        telegramBot: boolean;
+        advancedAnalytics: boolean;
+        customBranding: boolean;
+        apiAccess: boolean;
+        prioritySupport: boolean;
+    }>().notNull(),
+    monthlyPrice: decimal("monthly_price", { precision: 10, scale: 2 }).notNull(),
+    yearlyPrice: decimal("yearly_price", { precision: 10, scale: 2 }).notNull(),
+    isActive: boolean("is_active").default(true),
+    createdAt: timestamp("created_at").defaultNow().notNull(),
+});
+
+// ✅ NEW: Table to store restaurant floors/areas (e.g., Main Hall, Terrace)
+export const floors = pgTable("floors", {
+    id: serial("id").primaryKey(),
+    restaurantId: integer("restaurant_id").references(() => restaurants.id, { onDelete: 'cascade' }).notNull(),
+    name: text("name").notNull(),
+    displayOrder: integer("display_order").default(0).notNull(),
+    createdAt: timestamp("created_at").defaultNow().notNull(),
 });
 
-// Tables table (unchanged)
+// ✅ NEW: Relations for the floors table
+export const floorsRelations = relations(floors, ({ one, many }) => ({
+    restaurant: one(restaurants, {
+        fields: [floors.restaurantId],
+        references: [restaurants.id],
+    }),
+    tables: many(tables),
+}));
+
+// 🔄 MODIFIED: Added floor plan fields to the 'tables' table
 export const tables = pgTable("tables", {
-  id: serial("id").primaryKey(),
-  restaurantId: integer("restaurant_id").references(() => restaurants.id).notNull(),
-  name: text("name").notNull(),
-  minGuests: integer("min_guests").notNull().default(1),
-  maxGuests: integer("max_guests").notNull(),
-  status: tableStatusEnum("status").default('free'),
-  features: text("features").array(),
-  comments: text("comments"),
-  createdAt: timestamp("created_at").defaultNow().notNull(),
+    id: serial("id").primaryKey(),
+    restaurantId: integer("restaurant_id").references(() => restaurants.id).notNull(),
+    name: text("name").notNull(),
+    minGuests: integer("min_guests").notNull().default(1),
+    maxGuests: integer("max_guests").notNull(),
+    status: tableStatusEnum("status").default('free'),
+    features: text("features").array(),
+    comments: text("comments"),
+
+    // ✅ NEW: Fields for the floor plan layout
+    floorId: integer("floor_id").references(() => floors.id, { onDelete: 'set null' }),
+    posX: integer("pos_x").default(50).notNull(),
+    posY: integer("pos_y").default(50).notNull(),
+    shape: text("shape", { enum: ["square", "round"] }).default("square").notNull(),
+    rotation: integer("rotation").default(0).notNull(),
+
+    createdAt: timestamp("created_at").defaultNow().notNull(),
 });
 
+// 🔄 MODIFIED: Added relation to the new 'floors' table
 export const tablesRelations = relations(tables, ({ one, many }) => ({
-  restaurant: one(restaurants, {
-    fields: [tables.restaurantId],
-    references: [restaurants.id],
-  }),
-  timeslots: many(timeslots),
-  reservations: many(reservations),
+    restaurant: one(restaurants, {
+        fields: [tables.restaurantId],
+        references: [restaurants.id],
+    }),
+    // ✅ NEW: Relation to a floor
+    floor: one(floors, {
+        fields: [tables.floorId],
+        references: [floors.id],
+    }),
+    timeslots: many(timeslots),
+    reservations: many(reservations),
 }));
 
+
 // Timeslots table (unchanged)
 export const timeslots = pgTable("timeslots", {
-  id: serial("id").primaryKey(),
-  restaurantId: integer("restaurant_id").references(() => restaurants.id).notNull(),
-  tableId: integer("table_id").references(() => tables.id).notNull(),
-  date: date("date").notNull(),
-  time: time("time").notNull(),
-  status: timeslotStatusEnum("status").default('free'),
-  createdAt: timestamp("created_at").defaultNow().notNull(),
+    id: serial("id").primaryKey(),
+    restaurantId: integer("restaurant_id").references(() => restaurants.id).notNull(),
+    tableId: integer("table_id").references(() => tables.id).notNull(),
+    date: date("date").notNull(),
+    time: time("time").notNull(),
+    status: timeslotStatusEnum("status").default('free'),
+    createdAt: timestamp("created_at").defaultNow().notNull(),
 });
 
 export const timeslotsRelations = relations(timeslots, ({ one, many }) => ({
-  restaurant: one(restaurants, {
-    fields: [timeslots.restaurantId],
-    references: [restaurants.id],
-  }),
-  table: one(tables, {
-    fields: [timeslots.tableId],
-    references: [tables.id],
-  }),
-  reservation: one(reservations, {
-    fields: [timeslots.id],
-    references: [reservations.timeslotId],
-  }),
+    restaurant: one(restaurants, {
+        fields: [timeslots.restaurantId],
+        references: [restaurants.id],
+    }),
+    table: one(tables, {
+        fields: [timeslots.tableId],
+        references: [tables.id],
+    }),
+    reservation: one(reservations, {
+        fields: [timeslots.id],
+        references: [reservations.timeslotId],
+    }),
 }));
 
 // ================================
@@ -270,47 +306,47 @@ export const timeslotsRelations = relations(timeslots, ({ one, many }) => ({
 // ================================
 
 export const guests = pgTable("guests", {
-  id: serial("id").primaryKey(),
-  // 🚨 CRITICAL SECURITY FIX: Add restaurant ID for tenant isolation
-  restaurantId: integer("restaurant_id").references(() => restaurants.id, { onDelete: 'cascade' }).notNull(),
-  name: text("name").notNull(),
-  phone: text("phone"),
-  email: text("email"),
-  telegram_user_id: text("telegram_user_id"),
-  language: text("language").default('en'),
-  birthday: date("birthday"),
-  comments: text("comments"),
-  tags: text("tags").array(),
-  
-  // ✅ NEW: Guest analytics and intelligence fields
-  visit_count: integer("visit_count").default(0).notNull(),
-  no_show_count: integer("no_show_count").default(0).notNull(),
-  total_spent: decimal("total_spent", { precision: 10, scale: 2 }).default('0').notNull(), // ✅ CURRENCY FIX: decimal type
-  average_duration: integer("average_duration").default(120),
-  preferences: json("preferences").$type<{
-    dietary_restrictions?: string[];
-    preferred_seating?: string;
-    special_occasions?: string[];
-    communication_preference?: 'telegram' | 'phone' | 'email';
-  }>(),
-  vip_level: integer("vip_level").default(0),
-  last_visit_date: timestamp("last_visit_date"),
-  reputation_score: integer("reputation_score").default(100),
-  
-  createdAt: timestamp("created_at").defaultNow().notNull(),
+    id: serial("id").primaryKey(),
+    // 🚨 CRITICAL SECURITY FIX: Add restaurant ID for tenant isolation
+    restaurantId: integer("restaurant_id").references(() => restaurants.id, { onDelete: 'cascade' }).notNull(),
+    name: text("name").notNull(),
+    phone: text("phone"),
+    email: text("email"),
+    telegram_user_id: text("telegram_user_id"),
+    language: text("language").default('en'),
+    birthday: date("birthday"),
+    comments: text("comments"),
+    tags: text("tags").array(),
+
+    // ✅ NEW: Guest analytics and intelligence fields
+    visit_count: integer("visit_count").default(0).notNull(),
+    no_show_count: integer("no_show_count").default(0).notNull(),
+    total_spent: decimal("total_spent", { precision: 10, scale: 2 }).default('0').notNull(), // ✅ CURRENCY FIX: decimal type
+    average_duration: integer("average_duration").default(120),
+    preferences: json("preferences").$type<{
+        dietary_restrictions?: string[];
+        preferred_seating?: string;
+        special_occasions?: string[];
+        communication_preference?: 'telegram' | 'phone' | 'email';
+    }>(),
+    vip_level: integer("vip_level").default(0),
+    last_visit_date: timestamp("last_visit_date"),
+    reputation_score: integer("reputation_score").default(100),
+
+    createdAt: timestamp("created_at").defaultNow().notNull(),
 }, (table) => ({
-  // ✅ SECURITY: Add composite indexes for performance with restaurant scoping
-  phoneRestaurantIdx: unique().on(table.phone, table.restaurantId),
-  telegramRestaurantIdx: unique().on(table.telegram_user_id, table.restaurantId),
+    // ✅ SECURITY: Add composite indexes for performance with restaurant scoping
+    phoneRestaurantIdx: unique().on(table.phone, table.restaurantId),
+    telegramRestaurantIdx: unique().on(table.telegram_user_id, table.restaurantId),
 }));
 
 export const guestsRelations = relations(guests, ({ one, many }) => ({
-  // ✅ SECURITY FIX: Add restaurant relation
-  restaurant: one(restaurants, {
-    fields: [guests.restaurantId],
-    references: [restaurants.id],
-  }),
-  reservations: many(reservations),
+    // ✅ SECURITY FIX: Add restaurant relation
+    restaurant: one(restaurants, {
+        fields: [guests.restaurantId],
+        references: [restaurants.id],
+    }),
+    reservations: many(reservations),
 }));
 
 // ================================
@@ -318,53 +354,53 @@ export const guestsRelations = relations(guests, ({ one, many }) => ({
 // ================================
 
 export const reservations = pgTable("reservations", {
-  id: serial("id").primaryKey(),
-  restaurantId: integer("restaurant_id").references(() => restaurants.id).notNull(),
-  guestId: integer("guest_id").references(() => guests.id).notNull(),
-  tableId: integer("table_id").references(() => tables.id),
-  timeslotId: integer("timeslot_id").references(() => timeslots.id),
-  reservation_utc: timestamp("reservation_utc", { withTimezone: true, mode: 'string' }).notNull(),
-  duration: integer("duration").default(120),
-  guests: integer("guests").notNull(),
-  status: reservationStatusEnum("status").default('created'),
-  booking_guest_name: text("booking_guest_name"), 
-  comments: text("comments"),
-  specialRequests: text("special_requests"),
-  staffNotes: text("staff_notes"),
-  // 🚨 CRITICAL CURRENCY FIX: Change from text to decimal for proper financial calculations
-  totalAmount: decimal("total_amount", { precision: 10, scale: 2 }),
-  currency: text("currency").default('USD'),
-  guestRating: integer("guest_rating"),
-  confirmation24h: boolean("confirmation_24h").default(false),
-  confirmation2h: boolean("confirmation_2h").default(false),
-  source: text("source").default('direct'),
-  lastModifiedAt: timestamp("last_modified_at").defaultNow(),
-  createdAt: timestamp("created_at").defaultNow().notNull(),
+    id: serial("id").primaryKey(),
+    restaurantId: integer("restaurant_id").references(() => restaurants.id).notNull(),
+    guestId: integer("guest_id").references(() => guests.id).notNull(),
+    tableId: integer("table_id").references(() => tables.id),
+    timeslotId: integer("timeslot_id").references(() => timeslots.id),
+    reservation_utc: timestamp("reservation_utc", { withTimezone: true, mode: 'string' }).notNull(),
+    duration: integer("duration").default(120),
+    guests: integer("guests").notNull(),
+    status: reservationStatusEnum("status").default('created'),
+    booking_guest_name: text("booking_guest_name"),
+    comments: text("comments"),
+    specialRequests: text("special_requests"),
+    staffNotes: text("staff_notes"),
+    // 🚨 CRITICAL CURRENCY FIX: Change from text to decimal for proper financial calculations
+    totalAmount: decimal("total_amount", { precision: 10, scale: 2 }),
+    currency: text("currency").default('USD'),
+    guestRating: integer("guest_rating"),
+    confirmation24h: boolean("confirmation_24h").default(false),
+    confirmation2h: boolean("confirmation_2h").default(false),
+    source: text("source").default('direct'),
+    lastModifiedAt: timestamp("last_modified_at").defaultNow(),
+    createdAt: timestamp("created_at").defaultNow().notNull(),
 });
 
 export const reservationsRelations = relations(reservations, ({ one, many }) => ({
-  restaurant: one(restaurants, {
-    fields: [reservations.restaurantId],
-    references: [restaurants.id],
-  }),
-  guest: one(guests, {
-    fields: [reservations.guestId],
-    references: [guests.id],
-  }),
-  table: one(tables, {
-    fields: [reservations.tableId],
-    references: [tables.id],
-  }),
-  timeslot: one(timeslots, {
-    fields: [reservations.timeslotId],
-    references: [reservations.id],
-  }),
-  modifications: many(reservationModifications),
-  cancellation: one(reservationCancellations, {
-    fields: [reservations.id],
-    references: [reservationCancellations.reservationId],
-  }),
-  statusHistory: many(reservationStatusHistory),
+    restaurant: one(restaurants, {
+        fields: [reservations.restaurantId],
+        references: [restaurants.id],
+    }),
+    guest: one(guests, {
+        fields: [reservations.guestId],
+        references: [guests.id],
+    }),
+    table: one(tables, {
+        fields: [reservations.tableId],
+        references: [tables.id],
+    }),
+    timeslot: one(timeslots, {
+        fields: [reservations.timeslotId],
+        references: [reservations.id],
+    }),
+    modifications: many(reservationModifications),
+    cancellation: one(reservationCancellations, {
+        fields: [reservations.id],
+        references: [reservationCancellations.reservationId],
+    }),
+    statusHistory: many(reservationStatusHistory),
 }));
 
 // ================================
@@ -372,25 +408,25 @@ export const reservationsRelations = relations(reservations, ({ one, many }) =>
 // ================================
 
 export const reservationStatusHistory = pgTable("reservation_status_history", {
-  id: serial("id").primaryKey(),
-  reservationId: integer("reservation_id").references(() => reservations.id, { onDelete: 'cascade' }).notNull(),
-  fromStatus: reservationStatusEnum("from_status"),
-  toStatus: reservationStatusEnum("to_status").notNull(),
-  changedBy: text("changed_by"),
-  changeReason: text("change_reason"),
-  timestamp: timestamp("timestamp").defaultNow().notNull(),
-  metadata: json("metadata").$type<{
-    staffMember?: string;
-    automaticTrigger?: string;
-    guestAction?: string;
-  }>(),
+    id: serial("id").primaryKey(),
+    reservationId: integer("reservation_id").references(() => reservations.id, { onDelete: 'cascade' }).notNull(),
+    fromStatus: reservationStatusEnum("from_status"),
+    toStatus: reservationStatusEnum("to_status").notNull(),
+    changedBy: text("changed_by"),
+    changeReason: text("change_reason"),
+    timestamp: timestamp("timestamp").defaultNow().notNull(),
+    metadata: json("metadata").$type<{
+        staffMember?: string;
+        automaticTrigger?: string;
+        guestAction?: string;
+    }>(),
 });
 
 export const reservationStatusHistoryRelations = relations(reservationStatusHistory, ({ one }) => ({
-  reservation: one(reservations, {
-    fields: [reservationStatusHistory.reservationId],
-    references: [reservations.id],
-  }),
+    reservation: one(reservations, {
+        fields: [reservationStatusHistory.reservationId],
+        references: [reservations.id],
+    }),
 }));
 
 // ================================
@@ -399,141 +435,141 @@ export const reservationStatusHistoryRelations = relations(reservationStatusHist
 
 // Restaurant-specific menu categories (flexible, not hardcoded)
 export const restaurantMenuCategories = pgTable("restaurant_menu_categories", {
-  id: serial("id").primaryKey(),
-  restaurantId: integer("restaurant_id").references(() => restaurants.id, { onDelete: 'cascade' }).notNull(),
-  name: text("name").notNull(),
-  slug: text("slug").notNull(),
-  description: text("description"),
-  displayOrder: integer("display_order").default(0).notNull(),
-  isActive: boolean("is_active").default(true).notNull(),
-  color: text("color"),
-  icon: text("icon"),
-  createdAt: timestamp("created_at").defaultNow().notNull(),
-  updatedAt: timestamp("updated_at").defaultNow().notNull(),
+    id: serial("id").primaryKey(),
+    restaurantId: integer("restaurant_id").references(() => restaurants.id, { onDelete: 'cascade' }).notNull(),
+    name: text("name").notNull(),
+    slug: text("slug").notNull(),
+    description: text("description"),
+    displayOrder: integer("display_order").default(0).notNull(),
+    isActive: boolean("is_active").default(true).notNull(),
+    color: text("color"),
+    icon: text("icon"),
+    createdAt: timestamp("created_at").defaultNow().notNull(),
+    updatedAt: timestamp("updated_at").defaultNow().notNull(),
 }, (table) => ({
-  uniqueRestaurantSlug: unique().on(table.restaurantId, table.slug)
+    uniqueRestaurantSlug: unique().on(table.restaurantId, table.slug)
 }));
 
 export const restaurantMenuCategoriesRelations = relations(restaurantMenuCategories, ({ one, many }) => ({
-  restaurant: one(restaurants, {
-    fields: [restaurantMenuCategories.restaurantId],
-    references: [restaurants.id],
-  }),
-  menuItems: many(menuItems),
+    restaurant: one(restaurants, {
+        fields: [restaurantMenuCategories.restaurantId],
+        references: [restaurants.id],
+    }),
+    menuItems: many(menuItems),
 }));
 
 // Menu items table with comprehensive features
 export const menuItems = pgTable("menu_items", {
-  id: serial("id").primaryKey(),
-  restaurantId: integer("restaurant_id").references(() => restaurants.id, { onDelete: 'cascade' }).notNull(),
-  categoryId: integer("category_id").references(() => restaurantMenuCategories.id).notNull(),
-  name: text("name").notNull(),
-  description: text("description"),
-  shortDescription: text("short_description"),
-  price: decimal("price", { precision: 10, scale: 2 }).notNull(), // ✅ CURRENCY FIX: decimal type
-  originalPrice: decimal("original_price", { precision: 10, scale: 2 }), // ✅ CURRENCY FIX: decimal type
-  subcategory: text("subcategory"),
-  allergens: allergenEnum("allergens").array(),
-  dietaryTags: text("dietary_tags").array(),
-  spicyLevel: integer("spicy_level").default(0),
-  isAvailable: boolean("is_available").default(true).notNull(),
-  isPopular: boolean("is_popular").default(false).notNull(),
-  isNew: boolean("is_new").default(false).notNull(),
-  isSeasonal: boolean("is_seasonal").default(false).notNull(),
-  preparationTime: integer("preparation_time"),
-  calories: integer("calories"),
-  servingSize: text("serving_size"),
-  displayOrder: integer("display_order").default(0),
-  availableFrom: time("available_from"),
-  availableTo: time("available_to"),
-  createdAt: timestamp("created_at").defaultNow().notNull(),
-  updatedAt: timestamp("updated_at").defaultNow().notNull(),
+    id: serial("id").primaryKey(),
+    restaurantId: integer("restaurant_id").references(() => restaurants.id, { onDelete: 'cascade' }).notNull(),
+    categoryId: integer("category_id").references(() => restaurantMenuCategories.id).notNull(),
+    name: text("name").notNull(),
+    description: text("description"),
+    shortDescription: text("short_description"),
+    price: decimal("price", { precision: 10, scale: 2 }).notNull(), // ✅ CURRENCY FIX: decimal type
+    originalPrice: decimal("original_price", { precision: 10, scale: 2 }), // ✅ CURRENCY FIX: decimal type
+    subcategory: text("subcategory"),
+    allergens: allergenEnum("allergens").array(),
+    dietaryTags: text("dietary_tags").array(),
+    spicyLevel: integer("spicy_level").default(0),
+    isAvailable: boolean("is_available").default(true).notNull(),
+    isPopular: boolean("is_popular").default(false).notNull(),
+    isNew: boolean("is_new").default(false).notNull(),
+    isSeasonal: boolean("is_seasonal").default(false).notNull(),
+    preparationTime: integer("preparation_time"),
+    calories: integer("calories"),
+    servingSize: text("serving_size"),
+    displayOrder: integer("display_order").default(0),
+    availableFrom: time("available_from"),
+    availableTo: time("available_to"),
+    createdAt: timestamp("created_at").defaultNow().notNull(),
+    updatedAt: timestamp("updated_at").defaultNow().notNull(),
 });
 
 export const menuItemsRelations = relations(menuItems, ({ one, many }) => ({
-  restaurant: one(restaurants, {
-    fields: [menuItems.restaurantId],
-    references: [restaurants.id],
-  }),
-  category: one(restaurantMenuCategories, {
-    fields: [menuItems.categoryId],
-    references: [restaurantMenuCategories.id],
-  }),
-  options: many(menuItemOptions),
-  searchLogs: many(menuSearchLog),
+    restaurant: one(restaurants, {
+        fields: [menuItems.restaurantId],
+        references: [restaurants.id],
+    }),
+    category: one(restaurantMenuCategories, {
+        fields: [menuItems.categoryId],
+        references: [restaurantMenuCategories.id],
+    }),
+    options: many(menuItemOptions),
+    searchLogs: many(menuSearchLog),
 }));
 
 // Menu item customization options
 export const menuItemOptions = pgTable("menu_item_options", {
-  id: serial("id").primaryKey(),
-  menuItemId: integer("menu_item_id").references(() => menuItems.id, { onDelete: 'cascade' }).notNull(),
-  name: text("name").notNull(),
-  type: text("type").notNull(),
-  isRequired: boolean("is_required").default(false).notNull(),
-  displayOrder: integer("display_order").default(0),
+    id: serial("id").primaryKey(),
+    menuItemId: integer("menu_item_id").references(() => menuItems.id, { onDelete: 'cascade' }).notNull(),
+    name: text("name").notNull(),
+    type: text("type").notNull(),
+    isRequired: boolean("is_required").default(false).notNull(),
+    displayOrder: integer("display_order").default(0),
 });
 
 export const menuItemOptionsRelations = relations(menuItemOptions, ({ one, many }) => ({
-  menuItem: one(menuItems, {
-    fields: [menuItemOptions.menuItemId],
-    references: [menuItems.id],
-  }),
-  values: many(menuItemOptionValues),
+    menuItem: one(menuItems, {
+        fields: [menuItemOptions.menuItemId],
+        references: [menuItems.id],
+    }),
+    values: many(menuItemOptionValues),
 }));
 
 // Values for menu item options
 export const menuItemOptionValues = pgTable("menu_item_option_values", {
-  id: serial("id").primaryKey(),
-  optionId: integer("option_id").references(() => menuItemOptions.id, { onDelete: 'cascade' }).notNull(),
-  value: text("value").notNull(),
-  priceModifier: decimal("price_modifier", { precision: 10, scale: 2 }).default('0'), // ✅ CURRENCY FIX: decimal type
-  displayOrder: integer("display_order").default(0),
+    id: serial("id").primaryKey(),
+    optionId: integer("option_id").references(() => menuItemOptions.id, { onDelete: 'cascade' }).notNull(),
+    value: text("value").notNull(),
+    priceModifier: decimal("price_modifier", { precision: 10, scale: 2 }).default('0'), // ✅ CURRENCY FIX: decimal type
+    displayOrder: integer("display_order").default(0),
 });
 
 export const menuItemOptionValuesRelations = relations(menuItemOptionValues, ({ one }) => ({
-  option: one(menuItemOptions, {
-    fields: [menuItemOptionValues.optionId],
-    references: [menuItemOptions.id],
-  }),
+    option: one(menuItemOptions, {
+        fields: [menuItemOptionValues.optionId],
+        references: [menuItemOptions.id],
+    }),
 }));
 
 // Menu search analytics
 export const menuSearchLog = pgTable("menu_search_log", {
-  id: serial("id").primaryKey(),
-  restaurantId: integer("restaurant_id").references(() => restaurants.id).notNull(),
-  query: text("query").notNull(),
-  resultsCount: integer("results_count").notNull(),
-  clickedItemId: integer("clicked_item_id").references(() => menuItems.id),
-  source: text("source").notNull(),
-  timestamp: timestamp("timestamp").defaultNow().notNull(),
+    id: serial("id").primaryKey(),
+    restaurantId: integer("restaurant_id").references(() => restaurants.id).notNull(),
+    query: text("query").notNull(),
+    resultsCount: integer("results_count").notNull(),
+    clickedItemId: integer("clicked_item_id").references(() => menuItems.id),
+    source: text("source").notNull(),
+    timestamp: timestamp("timestamp").defaultNow().notNull(),
 });
 
 export const menuSearchLogRelations = relations(menuSearchLog, ({ one }) => ({
-  restaurant: one(restaurants, {
-    fields: [menuSearchLog.restaurantId],
-    references: [restaurants.id],
-  }),
-  clickedItem: one(menuItems, {
-    fields: [menuSearchLog.clickedItemId],
-    references: [menuItems.id],
-  }),
+    restaurant: one(restaurants, {
+        fields: [menuSearchLog.restaurantId],
+        references: [restaurants.id],
+    }),
+    clickedItem: one(menuItems, {
+        fields: [menuSearchLog.clickedItemId],
+        references: [menuItems.id],
+    }),
 }));
 
 // ✅ NEW: Category templates for quick restaurant setup
 export const menuCategoryTemplates = pgTable("menu_category_templates", {
-  id: serial("id").primaryKey(),
-  templateName: text("template_name").notNull(),
-  description: text("description").notNull(),
-  categories: json("categories").$type<Array<{
-    name: string;
-    slug: string;
-    description?: string;
-    displayOrder: number;
-    color?: string;
-    icon?: string;
-  }>>().notNull(),
-  isDefault: boolean("is_default").default(false).notNull(),
-  createdAt: timestamp("created_at").defaultNow().notNull(),
+    id: serial("id").primaryKey(),
+    templateName: text("template_name").notNull(),
+    description: text("description").notNull(),
+    categories: json("categories").$type<Array<{
+        name: string;
+        slug: string;
+        description?: string;
+        displayOrder: number;
+        color?: string;
+        icon?: string;
+    }>>().notNull(),
+    isDefault: boolean("is_default").default(false).notNull(),
+    createdAt: timestamp("created_at").defaultNow().notNull(),
 });
 
 // ================================
@@ -541,71 +577,71 @@ export const menuCategoryTemplates = pgTable("menu_category_templates", {
 // ================================
 
 export const reservationModifications = pgTable("reservation_modifications", {
-  id: serial("id").primaryKey(),
-  reservationId: integer("reservation_id").references(() => reservations.id).notNull(),
-  fieldChanged: text("field_changed").notNull(),
-  oldValue: text("old_value"),
-  newValue: text("new_value"),
-  modifiedBy: text("modified_by"),
-  modifiedAt: timestamp("modified_at").defaultNow().notNull(),
-  reason: text("reason"),
-  source: text("source"),
-  createdAt: timestamp("created_at").defaultNow().notNull(),
+    id: serial("id").primaryKey(),
+    reservationId: integer("reservation_id").references(() => reservations.id).notNull(),
+    fieldChanged: text("field_changed").notNull(),
+    oldValue: text("old_value"),
+    newValue: text("new_value"),
+    modifiedBy: text("modified_by"),
+    modifiedAt: timestamp("modified_at").defaultNow().notNull(),
+    reason: text("reason"),
+    source: text("source"),
+    createdAt: timestamp("created_at").defaultNow().notNull(),
 });
 
 export const reservationCancellations = pgTable("reservation_cancellations", {
-  id: serial("id").primaryKey(),
-  reservationId: integer("reservation_id").references(() => reservations.id).notNull(),
-  cancelledAt: timestamp("cancelled_at").defaultNow().notNull(),
-  cancelledBy: text("cancelled_by"),
-  reason: text("reason"),
-  cancellationPolicy: text("cancellation_policy"),
-  // 🚨 CRITICAL CURRENCY FIX: Change from text to decimal for financial calculations
-  feeAmount: decimal("fee_amount", { precision: 10, scale: 2 }),
-  refundStatus: text("refund_status"),
-  refundAmount: decimal("refund_amount", { precision: 10, scale: 2 }),
-  source: text("source"),
-  createdAt: timestamp("created_at").defaultNow().notNull(),
+    id: serial("id").primaryKey(),
+    reservationId: integer("reservation_id").references(() => reservations.id).notNull(),
+    cancelledAt: timestamp("cancelled_at").defaultNow().notNull(),
+    cancelledBy: text("cancelled_by"),
+    reason: text("reason"),
+    cancellationPolicy: text("cancellation_policy"),
+    // 🚨 CRITICAL CURRENCY FIX: Change from text to decimal for financial calculations
+    feeAmount: decimal("fee_amount", { precision: 10, scale: 2 }),
+    refundStatus: text("refund_status"),
+    refundAmount: decimal("refund_amount", { precision: 10, scale: 2 }),
+    source: text("source"),
+    createdAt: timestamp("created_at").defaultNow().notNull(),
 });
 
 export const restaurantPolicies = pgTable("restaurant_policies", {
-  id: serial("id").primaryKey(),
-  restaurantId: integer("restaurant_id").references(() => restaurants.id).notNull(),
-  policyType: text("policy_type").notNull(),
-  policyData: json("policy_data").$type<{
-    freeModificationHours?: number;
-    maxModificationsPerReservation?: number;
-    allowedModifications?: string[];
-    freeCancellationHours?: number;
-    cancellationFeePercentage?: number;
-    noRefundHours?: number;
-    verificationRequired?: boolean;
-    verificationMethods?: string[];
-  }>(),
-  isActive: boolean("is_active").default(true),
-  createdAt: timestamp("created_at").defaultNow().notNull(),
-  updatedAt: timestamp("updated_at").defaultNow().notNull(),
+    id: serial("id").primaryKey(),
+    restaurantId: integer("restaurant_id").references(() => restaurants.id).notNull(),
+    policyType: text("policy_type").notNull(),
+    policyData: json("policy_data").$type<{
+        freeModificationHours?: number;
+        maxModificationsPerReservation?: number;
+        allowedModifications?: string[];
+        freeCancellationHours?: number;
+        cancellationFeePercentage?: number;
+        noRefundHours?: number;
+        verificationRequired?: boolean;
+        verificationMethods?: string[];
+    }>(),
+    isActive: boolean("is_active").default(true),
+    createdAt: timestamp("created_at").defaultNow().notNull(),
+    updatedAt: timestamp("updated_at").defaultNow().notNull(),
 });
 
 export const reservationModificationsRelations = relations(reservationModifications, ({ one }) => ({
-  reservation: one(reservations, {
-    fields: [reservationModifications.reservationId],
-    references: [reservations.id],
-  }),
+    reservation: one(reservations, {
+        fields: [reservationModifications.reservationId],
+        references: [reservations.id],
+    }),
 }));
 
 export const reservationCancellationsRelations = relations(reservationCancellations, ({ one }) => ({
-  reservation: one(reservations, {
-    fields: [reservationCancellations.reservationId],
-    references: [reservations.id],
-  }),
+    reservation: one(reservations, {
+        fields: [reservationCancellations.reservationId],
+        references: [reservations.id],
+    }),
 }));
 
 export const restaurantPoliciesRelations = relations(restaurantPolicies, ({ one }) => ({
-  restaurant: one(restaurants, {
-    fields: [restaurantPolicies.restaurantId],
-    references: [restaurants.id],
-  }),
+    restaurant: one(restaurants, {
+        fields: [restaurantPolicies.restaurantId],
+        references: [restaurants.id],
+    }),
 }));
 
 // ================================
@@ -613,37 +649,37 @@ export const restaurantPoliciesRelations = relations(restaurantPolicies, ({ one
 // ================================
 
 export const integrationSettings = pgTable("integration_settings", {
-  id: serial("id").primaryKey(),
-  restaurantId: integer("restaurant_id").references(() => restaurants.id).notNull(),
-  type: text("type").notNull(),
-  apiKey: text("api_key"),
-  token: text("token"),
-  enabled: boolean("enabled").default(false),
-  settings: json("settings"),
-  createdAt: timestamp("created_at").defaultNow().notNull(),
+    id: serial("id").primaryKey(),
+    restaurantId: integer("restaurant_id").references(() => restaurants.id).notNull(),
+    type: text("type").notNull(),
+    apiKey: text("api_key"),
+    token: text("token"),
+    enabled: boolean("enabled").default(false),
+    settings: json("settings"),
+    createdAt: timestamp("created_at").defaultNow().notNull(),
 });
 
 export const integrationSettingsRelations = relations(integrationSettings, ({ one }) => ({
-  restaurant: one(restaurants, {
-    fields: [integrationSettings.restaurantId],
-    references: [restaurants.id],
-  }),
+    restaurant: one(restaurants, {
+        fields: [integrationSettings.restaurantId],
+        references: [restaurants.id],
+    }),
 }));
 
 export const aiActivities = pgTable("ai_activities", {
-  id: serial("id").primaryKey(),
-  restaurantId: integer("restaurant_id").references(() => restaurants.id).notNull(),
-  type: text("type").notNull(),
-  description: text("description").notNull(),
-  data: json("data"),
-  createdAt: timestamp("created_at").defaultNow().notNull(),
+    id: serial("id").primaryKey(),
+    restaurantId: integer("restaurant_id").references(() => restaurants.id).notNull(),
+    type: text("type").notNull(),
+    description: text("description").notNull(),
+    data: json("data"),
+    createdAt: timestamp("created_at").defaultNow().notNull(),
 });
 
 export const aiActivitiesRelations = relations(aiActivities, ({ one }) => ({
-  restaurant: one(restaurants, {
-    fields: [aiActivities.restaurantId],
-    references: [restaurants.id],
-  }),
+    restaurant: one(restaurants, {
+        fields: [aiActivities.restaurantId],
+        references: [restaurants.id],
+    }),
 }));
 
 // ================================
@@ -653,23 +689,23 @@ export const aiActivitiesRelations = relations(aiActivities, ({ one }) => ({
 export const insertUserSchema = createInsertSchema(users).omit({ id: true, createdAt: true });
 
 export const insertRestaurantSchema = createInsertSchema(restaurants, {
-  timezone: z.string().min(1, "Timezone is required")
-    .refine((tz) => {
-      try {
-        Intl.DateTimeFormat(undefined, { timeZone: tz });
-        return true;
-      } catch {
-        return false;
-      }
-    }, "Invalid timezone format"),
-  slotInterval: z.number().min(15).max(60).optional(),
-  allowAnyTime: z.boolean().optional(),
-  minTimeIncrement: z.number().min(5).max(30).optional(),
-  subdomain: z.string().min(1).max(50).regex(/^[a-z0-9-]+$/, "Subdomain must contain only lowercase letters, numbers, and hyphens").optional(),
-  aiTemperature: z.string().optional(),
-  maxTablesAllowed: z.number().min(1).optional(),
-  maxMonthlyReservations: z.number().min(1).optional(),
-  maxStaffAccounts: z.number().min(1).optional(),
+    timezone: z.string().min(1, "Timezone is required")
+        .refine((tz) => {
+            try {
+                Intl.DateTimeFormat(undefined, { timeZone: tz });
+                return true;
+            } catch {
+                return false;
+            }
+        }, "Invalid timezone format"),
+    slotInterval: z.number().min(15).max(60).optional(),
+    allowAnyTime: z.boolean().optional(),
+    minTimeIncrement: z.number().min(5).max(30).optional(),
+    subdomain: z.string().min(1).max(50).regex(/^[a-z0-9-]+$/, "Subdomain must contain only lowercase letters, numbers, and hyphens").optional(),
+    aiTemperature: z.string().optional(),
+    maxTablesAllowed: z.number().min(1).optional(),
+    maxMonthlyReservations: z.number().min(1).optional(),
+    maxStaffAccounts: z.number().min(1).optional(),
 }).omit({ id: true, createdAt: true });
 
 // Multi-tenant table schemas
@@ -678,81 +714,92 @@ export const insertTenantAuditLogSchema = createInsertSchema(tenantAuditLogs).om
 export const insertTenantUsageMetricsSchema = createInsertSchema(tenantUsageMetrics).omit({ id: true, createdAt: true });
 export const insertPlanLimitsSchema = createInsertSchema(planLimits).omit({ id: true, createdAt: true });
 
-export const insertTableSchema = createInsertSchema(tables).omit({ id: true, createdAt: true });
+// ✅ NEW: Zod schema for inserting a new floor
+export const insertFloorSchema = createInsertSchema(floors).omit({ id: true, createdAt: true });
+
+// 🔄 MODIFIED: Add new optional fields to the table insert schema
+export const insertTableSchema = createInsertSchema(tables, {
+    posX: z.number().optional(),
+    posY: z.number().optional(),
+    shape: z.enum(["square", "round"]).optional(),
+    rotation: z.number().optional(),
+    floorId: z.number().nullable().optional(), // floorId can be null or a number
+}).omit({ id: true, createdAt: true });
+
 export const insertTimeslotSchema = createInsertSchema(timeslots).omit({ id: true, createdAt: true });
 
 // 🔒 SECURITY FIX: Guest schema with required restaurant ID
 export const insertGuestSchema = createInsertSchema(guests, {
-  restaurantId: z.number().min(1, "Restaurant ID is required"), // ✅ SECURITY: Require restaurant ID
-  visit_count: z.number().min(0).optional(),
-  no_show_count: z.number().min(0).optional(),
-  total_spent: z.string().optional(), // ✅ CURRENCY: Validated as decimal string
-  vip_level: z.number().min(0).max(5).optional(),
-  reputation_score: z.number().min(0).max(100).optional(),
+    restaurantId: z.number().min(1, "Restaurant ID is required"), // ✅ SECURITY: Require restaurant ID
+    visit_count: z.number().min(0).optional(),
+    no_show_count: z.number().min(0).optional(),
+    total_spent: z.string().optional(), // ✅ CURRENCY: Validated as decimal string
+    vip_level: z.number().min(0).max(5).optional(),
+    reputation_score: z.number().min(0).max(100).optional(),
 }).omit({ id: true, createdAt: true });
 
 // ✅ CURRENCY FIX: Proper decimal validation for reservations
 export const insertReservationSchema = createInsertSchema(reservations, {
-  booking_guest_name: z.string().optional().nullable(),
-  reservation_utc: z.string().datetime({ message: "Invalid ISO 8601 UTC timestamp format" }),
-  totalAmount: z.string().regex(/^\d+(\.\d{1,2})?$/, "Invalid currency format").optional(), // ✅ CURRENCY: Decimal validation
-  lastModifiedAt: z.date().optional(),
+    booking_guest_name: z.string().optional().nullable(),
+    reservation_utc: z.string().datetime({ message: "Invalid ISO 8601 UTC timestamp format" }),
+    totalAmount: z.string().regex(/^\d+(\.\d{1,2})?$/, "Invalid currency format").optional(), // ✅ CURRENCY: Decimal validation
+    lastModifiedAt: z.date().optional(),
 }).omit({ id: true, createdAt: true });
 
 // ✅ NEW: Status history schema
-export const insertReservationStatusHistorySchema = createInsertSchema(reservationStatusHistory).omit({ 
-  id: true, 
-  timestamp: true 
+export const insertReservationStatusHistorySchema = createInsertSchema(reservationStatusHistory).omit({
+    id: true,
+    timestamp: true
 });
 
 // ✅ NEW: Menu category schemas with currency validation
 export const insertRestaurantMenuCategorySchema = createInsertSchema(restaurantMenuCategories, {
-  name: z.string().min(1, "Category name is required"),
-  slug: z.string().min(1).regex(/^[a-z0-9-_]+$/, "Slug must contain only lowercase letters, numbers, hyphens, and underscores"),
-  displayOrder: z.number().min(0).optional(),
-  color: z.string().regex(/^#[0-9A-Fa-f]{6}$/, "Color must be a valid hex color").optional(),
+    name: z.string().min(1, "Category name is required"),
+    slug: z.string().min(1).regex(/^[a-z0-9-_]+$/, "Slug must contain only lowercase letters, numbers, hyphens, and underscores"),
+    displayOrder: z.number().min(0).optional(),
+    color: z.string().regex(/^#[0-9A-Fa-f]{6}$/, "Color must be a valid hex color").optional(),
 }).omit({ id: true, createdAt: true, updatedAt: true });
 
 // ✅ CURRENCY FIX: Menu item schema with decimal price validation
 export const insertMenuItemSchema = createInsertSchema(menuItems, {
-  price: z.string().regex(/^\d+(\.\d{1,2})?$/, "Invalid price format"), // ✅ CURRENCY: Decimal validation
-  originalPrice: z.string().regex(/^\d+(\.\d{1,2})?$/, "Invalid price format").optional(), // ✅ CURRENCY: Decimal validation
-  spicyLevel: z.number().min(0).max(5).optional(),
-  displayOrder: z.number().min(0).optional(),
-  categoryId: z.number().min(1, "Category is required"),
+    price: z.string().regex(/^\d+(\.\d{1,2})?$/, "Invalid price format"), // ✅ CURRENCY: Decimal validation
+    originalPrice: z.string().regex(/^\d+(\.\d{1,2})?$/, "Invalid price format").optional(), // ✅ CURRENCY: Decimal validation
+    spicyLevel: z.number().min(0).max(5).optional(),
+    displayOrder: z.number().min(0).optional(),
+    categoryId: z.number().min(1, "Category is required"),
 }).omit({ id: true, createdAt: true, updatedAt: true });
 
 export const insertMenuItemOptionSchema = createInsertSchema(menuItemOptions).omit({ id: true });
 
 // ✅ CURRENCY FIX: Menu option value schema with decimal validation
 export const insertMenuItemOptionValueSchema = createInsertSchema(menuItemOptionValues, {
-  priceModifier: z.string().regex(/^-?\d+(\.\d{1,2})?$/, "Invalid price modifier format").optional(), // ✅ CURRENCY: Decimal validation
+    priceModifier: z.string().regex(/^-?\d+(\.\d{1,2})?$/, "Invalid price modifier format").optional(), // ✅ CURRENCY: Decimal validation
 }).omit({ id: true });
 
 export const insertMenuSearchLogSchema = createInsertSchema(menuSearchLog).omit({ id: true, timestamp: true });
-export const insertMenuCategoryTemplateSchema = createInsertSchema(menuCategoryTemplates).omit({ 
-  id: true, 
-  createdAt: true 
+export const insertMenuCategoryTemplateSchema = createInsertSchema(menuCategoryTemplates).omit({
+    id: true,
+    createdAt: true
 });
 
 // ✅ CURRENCY FIX: Audit schemas with decimal validation
-export const insertReservationModificationSchema = createInsertSchema(reservationModifications).omit({ 
-  id: true, 
-  createdAt: true 
+export const insertReservationModificationSchema = createInsertSchema(reservationModifications).omit({
+    id: true,
+    createdAt: true
 });
 
 export const insertReservationCancellationSchema = createInsertSchema(reservationCancellations, {
-  feeAmount: z.string().regex(/^\d+(\.\d{1,2})?$/, "Invalid fee amount format").optional(), // ✅ CURRENCY: Decimal validation
-  refundAmount: z.string().regex(/^\d+(\.\d{1,2})?$/, "Invalid refund amount format").optional(), // ✅ CURRENCY: Decimal validation
-}).omit({ 
-  id: true, 
-  createdAt: true 
+    feeAmount: z.string().regex(/^\d+(\.\d{1,2})?$/, "Invalid fee amount format").optional(), // ✅ CURRENCY: Decimal validation
+    refundAmount: z.string().regex(/^\d+(\.\d{1,2})?$/, "Invalid refund amount format").optional(), // ✅ CURRENCY: Decimal validation
+}).omit({
+    id: true,
+    createdAt: true
 });
 
-export const insertRestaurantPolicySchema = createInsertSchema(restaurantPolicies).omit({ 
-  id: true, 
-  createdAt: true, 
-  updatedAt: true 
+export const insertRestaurantPolicySchema = createInsertSchema(restaurantPolicies).omit({
+    id: true,
+    createdAt: true,
+    updatedAt: true
 });
 
 export const insertIntegrationSettingSchema = createInsertSchema(integrationSettings).omit({ id: true, createdAt: true });
@@ -781,6 +828,10 @@ export type InsertTenantUsageMetrics = z.infer<typeof insertTenantUsageMetricsSc
 export type PlanLimits = typeof planLimits.$inferSelect;
 export type InsertPlanLimits = z.infer<typeof insertPlanLimitsSchema>;
 
+// ✅ NEW: Export types for the new floors table
+export type Floor = typeof floors.$inferSelect;
+export type InsertFloor = z.infer<typeof insertFloorSchema>;
+
 export type Table = typeof tables.$inferSelect;
 export type InsertTable = z.infer<typeof insertTableSchema>;
 
@@ -830,4 +881,4 @@ export type IntegrationSetting = typeof integrationSettings.$inferSelect;
 export type InsertIntegrationSetting = z.infer<typeof insertIntegrationSettingSchema>;
 
 export type AiActivity = typeof aiActivities.$inferSelect;
-export type InsertAiActivity = z.infer<typeof insertAiActivitySchema>;
\ No newline at end of file
+export type InsertAiActivity = z.infer<typeof insertAiActivitySchema>;
